<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Takeoff Tuner - SimGlass</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            background: #0a0e14;
            color: #c0c8d8;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 13px;
            display: flex; flex-direction: column;
        }
        .top-fixed {
            flex-shrink: 0; padding: 12px 16px 0;
        }
        .phases-scroll {
            flex: 1; overflow-y: auto; padding: 0 16px 16px;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #1a2030;
        }
        .header h1 { font-size: 18px; font-weight: 600; color: #ffab40; letter-spacing: 1px; }
        .header-actions { display: flex; gap: 8px; align-items: center; }
        .btn {
            background: #1a2030; color: #c0c8d8; border: 1px solid #2a3040;
            padding: 5px 12px; border-radius: 4px; cursor: pointer;
            font-size: 11px; font-family: inherit; transition: background 0.15s;
        }
        .btn:hover { background: #2a3040; }
        .btn-reset { border-color: #ff5252; color: #ff5252; }
        .btn-reset:hover { background: #2a1515; }
        .btn-nuke { border-color: #ff9800; color: #ff9800; }
        .btn-nuke:hover { background: #2a1a08; }
        .btn-clear-convos { border-color: #4fc3f7; color: #4fc3f7; }
        .btn-clear-convos:hover { background: #0d2233; }
        .btn-copy { border-color: #4fc3f7; color: #4fc3f7; }
        .btn-copy:hover { background: #152a30; }

        /* ── Control buttons ── */
        .ctrl-bar {
            display: flex; gap: 8px; align-items: center;
            margin-bottom: 12px;
        }
        .ctrl-btn {
            padding: 7px 16px; border-radius: 4px; cursor: pointer;
            font-size: 12px; font-weight: 600; font-family: inherit;
            letter-spacing: 0.5px; transition: all 0.15s; border: 1px solid;
        }
        .ctrl-btn-ai {
            background: #1a2030; color: #ff5252; border-color: #ff5252;
        }
        .ctrl-btn-ai.on { background: #1a3020; color: #66bb6a; border-color: #66bb6a; }
        .ctrl-btn-controls {
            background: #1a2030; color: #a0b0c0; border-color: #2a3040;
        }
        .ctrl-btn-controls.on { background: #1a2530; color: #4fc3f7; border-color: #4fc3f7; }
        .ctrl-btn-fpl {
            background: #1a2030; color: #a0b0c0; border-color: #2a3040;
        }
        .ctrl-btn-fpl:hover { background: #2a3040; }
        .ctrl-btn-fpl.on { background: #1a2520; color: #ffab40; border-color: #ffab40; }
        .ctrl-btn:hover { opacity: 0.85; }
        .ctrl-spacer { flex: 1; }

        /* ── Live data strip ── */
        .live-strip {
            background: #0d1218; border: 1px solid #1a2030; border-radius: 6px;
            padding: 8px 14px; margin-bottom: 12px;
            display: flex; gap: 20px; align-items: center; flex-wrap: wrap;
        }
        .live-strip .ls-item { display: flex; flex-direction: column; align-items: center; min-width: 55px; }
        .live-strip .ls-label { font-size: 9px; color: #a0b0c0; text-transform: uppercase; letter-spacing: 0.5px; }
        .live-strip .ls-val { font-size: 15px; font-family: 'Consolas', monospace; color: #e0e8f0; }
        .live-strip .ls-conn { margin-left: auto; font-size: 11px; }
        .ls-conn.connected { color: #66bb6a; }
        .ls-conn.disconnected { color: #ff5252; }
        .live-strip .ls-phase-label { font-size: 10px; color: #a0b0c0; }
        .live-strip .ls-phase-val { font-size: 14px; font-weight: 600; color: #ffab40; font-family: 'Consolas', monospace; }
        .live-strip .ls-sub { font-size: 12px; color: #4fc3f7; font-family: 'Consolas', monospace; }

        /* ── Phase cards ── */
        .phases { display: flex; flex-direction: column; gap: 0; }

        .phase-card {
            background: #0d1218; border: 1px solid #1a2030; border-radius: 6px;
            overflow: hidden; transition: border-color 0.3s, box-shadow 0.3s;
        }
        .phase-card.active { border-color: #ffab40; box-shadow: 0 0 12px rgba(255, 171, 64, 0.15); }
        .phase-card.active.phase-air { border-color: #4fc3f7; box-shadow: 0 0 12px rgba(79, 195, 247, 0.15); }
        .phase-card.active.phase-ap { border-color: #66bb6a; box-shadow: 0 0 12px rgba(102, 187, 106, 0.15); }
        .phase-card.completed { opacity: 0.5; }

        .phase-header {
            padding: 8px 14px; font-size: 13px; font-weight: 600; letter-spacing: 0.5px;
            display: flex; align-items: center; gap: 10px; cursor: default;
        }
        .phase-header .phase-name-text { flex: 1; display: flex; align-items: center; gap: 8px; }
        .phase-time { font-size: 10px; font-weight: 400; opacity: 0.5; font-family: 'Consolas', monospace; }
        .phase-card.active .phase-time, .phase-card.completed .phase-time { opacity: 0.8; }
        .phase-header .condition { font-weight: 400; font-size: 10px; opacity: 0.6; flex: 1; text-align: right; }
        .phase-ground .phase-header { background: #1a1500; color: #ffab40; border-left: 3px solid #ffab40; }
        .phase-air .phase-header { background: #001520; color: #4fc3f7; border-left: 3px solid #4fc3f7; }
        .phase-ap .phase-header { background: #001a10; color: #66bb6a; border-left: 3px solid #66bb6a; }

        /* Go/Hold button */
        .hold-btn {
            background: none; border: 1px solid #404850; color: #a0b0c0;
            padding: 2px 10px; border-radius: 3px; cursor: pointer;
            font-size: 10px; font-weight: 600; letter-spacing: 0.5px;
            font-family: inherit; transition: all 0.15s; flex-shrink: 0;
        }
        .hold-btn:hover { opacity: 0.8; }
        .hold-btn.go { background: #1a3020; border-color: #66bb6a; color: #66bb6a; }
        .hold-btn.go:hover { background: #1a3a20; }
        .hold-btn.held { background: #ff5252; border-color: #ff5252; color: #fff; }
        .hold-btn.held:hover { background: #e04848; }

        /* Active indicator dot */
        .active-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
            background: transparent; transition: background 0.3s;
        }
        .phase-card.active .active-dot { background: currentColor; animation: pulse-dot 1.2s infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .phase-connector { width: 2px; height: 6px; background: #2a3040; margin: 0 auto; }

        .phase-body { padding: 8px 14px 10px; }

        /* ── Live readout per phase ── */
        .phase-live {
            display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 8px;
            padding: 5px 8px; background: #080c10; border-radius: 4px;
            min-height: 26px; align-items: center;
        }
        .phase-live:empty { display: none; }
        .phase-set {
            display: flex; flex-wrap: wrap; gap: 6px 16px;
            padding: 4px 8px;
            background: rgba(79, 195, 247, 0.06);
            border-radius: 3px;
            border-left: 2px solid #4fc3f740;
            margin-bottom: 4px;
        }
        .set-item { display: flex; align-items: baseline; gap: 4px; }
        .set-label { font-size: 9px; color: #4fc3f7; text-transform: uppercase; letter-spacing: 0.5px; }
        .set-val { font-size: 12px; font-family: 'Consolas', monospace; color: #4fc3f7; font-weight: 600; }
        .pl-item { display: flex; align-items: baseline; gap: 4px; }
        .pl-label { font-size: 9px; color: #a0b0c0; text-transform: uppercase; }
        .pl-val { font-size: 12px; font-family: 'Consolas', monospace; color: #e0e8f0; }
        .pl-val.warn { color: #ffab40; }
        .pl-val.good { color: #66bb6a; }
        .pl-val.danger { color: #ff5252; }
        /* Progress bar for threshold values */
        .pl-bar { width: 60px; height: 4px; background: #1a2030; border-radius: 2px; position: relative; overflow: hidden; }
        .pl-bar-fill { height: 100%; border-radius: 2px; transition: width 0.2s; }
        .pl-bar-fill.low { background: #ffab40; }
        .pl-bar-fill.mid { background: #4fc3f7; }
        .pl-bar-fill.full { background: #66bb6a; }

        /* ── Inputs grid ── */
        .inputs-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(165px, 1fr)); gap: 6px; }
        .input-group { display: flex; flex-direction: column; gap: 1px; }
        .input-group label { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; color: #a0b0c0; }
        .input-group input {
            background: #0a0e14; border: 1px solid #2a3040; color: #e0e8f0;
            padding: 4px 7px; border-radius: 3px; font-size: 13px;
            font-family: 'Consolas', monospace; width: 100%; outline: none;
            transition: border-color 0.15s;
        }
        .input-group input:focus { border-color: #4fc3f7; }
        .input-group input::-webkit-inner-spin-button { opacity: 0.3; }
        .input-group .unit { font-size: 9px; color: #90a0b0; }

        .checklist { margin-top: 6px; padding-top: 6px; border-top: 1px solid #1a2030; }
        .checklist-item {
            font-size: 10px; color: #a0b0c0; padding: 1px 0;
            display: flex; align-items: center; gap: 5px;
        }
        .checklist-item::before { content: '\2610'; font-size: 11px; }
        .checklist-item.done { color: #66bb6a; }
        .checklist-item.done::before { content: '\2611'; }

        .no-inputs { font-size: 11px; color: #90a0b0; font-style: italic; }

        .toast {
            position: fixed; bottom: 20px; right: 20px; background: #1a2030;
            border: 1px solid #4fc3f7; color: #4fc3f7; padding: 10px 18px;
            border-radius: 6px; font-size: 12px; opacity: 0;
            transition: opacity 0.3s; pointer-events: none; z-index: 100;
        }
        .toast.show { opacity: 1; }

    </style>
</head>
<body>
    <div class="top-fixed">
        <div class="header">
            <h1>TAKEOFF TUNER</h1>
            <div class="header-actions">
                <button class="btn" id="btn-release-all">Release All Holds</button>
                <button class="btn btn-copy" id="btn-copy">Copy JSON</button>
                <button class="btn btn-clear-convos" id="btn-clear-convos">Clear Convos</button>
                <button class="btn btn-nuke" id="btn-nuke">Reset Sally</button>
                <button class="btn btn-reset" id="btn-reset">Reset Defaults</button>
            </div>
        </div>

        <div class="ctrl-bar">
            <button class="ctrl-btn ctrl-btn-fpl" id="ctrl-fpl">FPL</button>
            <button class="ctrl-btn ctrl-btn-ai" id="ctrl-ai">OFF</button>
            <button class="ctrl-btn ctrl-btn-controls" id="ctrl-controls">AI CONTROLS</button>
            <div class="ctrl-spacer"></div>
        </div>

        <div class="live-strip" id="live-strip">
            <div class="ls-item"><span class="ls-label">IAS</span><span class="ls-val" id="ls-ias">--</span></div>
            <div class="ls-item"><span class="ls-label">GS</span><span class="ls-val" id="ls-gs">--</span></div>
            <div class="ls-item"><span class="ls-label">AGL</span><span class="ls-val" id="ls-agl">--</span></div>
            <div class="ls-item"><span class="ls-label">VS</span><span class="ls-val" id="ls-vs">--</span></div>
            <div class="ls-item"><span class="ls-label">PITCH</span><span class="ls-val" id="ls-pitch">--</span></div>
            <div class="ls-item"><span class="ls-label">BANK</span><span class="ls-val" id="ls-bank">--</span></div>
            <div class="ls-item"><span class="ls-label">HDG</span><span class="ls-val" id="ls-hdg">--</span></div>
            <div class="ls-item"><span class="ls-label">THR</span><span class="ls-val" id="ls-thr">--</span></div>
            <div class="ls-item"><span class="ls-label">ELEV</span><span class="ls-val" id="ls-elev">--</span></div>
            <div class="ls-item"><span class="ls-label">AIL</span><span class="ls-val" id="ls-ail">--</span></div>
            <div class="ls-item"><span class="ls-label">RUD</span><span class="ls-val" id="ls-rud">--</span></div>
            <div class="ls-item">
                <span class="ls-phase-label">PHASE</span>
                <span class="ls-phase-val" id="ls-phase">--</span>
            </div>
            <div class="ls-item">
                <span class="ls-phase-label">SUB</span>
                <span class="ls-sub" id="ls-sub">--</span>
            </div>
            <span class="ls-conn disconnected" id="ls-conn">DISCONNECTED</span>
        </div>
    </div>

    <div class="phases-scroll">
        <div class="phases" id="phases"></div>
    </div>
    <div class="toast" id="toast"></div>

    <script src="/ui/shared/safe-channel.js"></script>
    <script>
    (function() {
        const STORAGE_KEY = 'simglass-takeoff-tuning';
        const HOLDS_KEY = 'simglass-takeoff-holds';
        const CHANNEL_NAME = 'SimGlass-sync';
        function esc(str) { const d = document.createElement('div'); d.textContent = str; return d.innerHTML; }

        // ── Phase definitions ──
        const PHASES = [
            {
                id: 'PREFLIGHT', name: 'PREFLIGHT', type: 'ground',
                condition: 'On ground, AI enabled',
                inputs: [
                    { key: 'preflightMixture', label: 'Mixture', default: 100, unit: '%' },
                    { key: 'preflightThrottle', label: 'Idle-up throttle', default: 35, unit: '%' },
                    { key: 'preflightFlaps', label: 'Flaps index', default: 2, unit: 'notch' }
                ],
                checklist: ['Mixture rich', 'Flaps set', 'Trim set', 'Parking brake released'],
                liveFields: ['mixture', 'flaps', 'parkingBrake'],
                isFlight: true
            },
            {
                id: 'TAXI', name: 'TAXI', type: 'ground',
                condition: 'GS > 0.5 kt',
                inputs: [
                    { key: 'taxiThrottleMax', label: 'Throttle aligned max', default: 70, unit: '%' },
                    { key: 'taxiThrottleMin', label: 'Throttle misaligned min', default: 25, unit: '%' },
                    { key: 'taxiTargetGS', label: 'Target ground speed', default: 25, unit: 'kt' },
                    { key: 'taxiRudderMaxLow', label: 'Rudder authority (low speed)', default: 90, unit: '%' },
                    { key: 'taxiHdgErrorThreshold', label: 'Heading error for throttle cut', default: 15, unit: '°' },
                    { key: 'taxiSpeedGain', label: 'Speed error gain', default: 0.8, unit: 'x' },
                    { key: 'taxiHdgPenalty', label: 'Heading penalty gain', default: 0.3, unit: 'x' },
                    { key: 'steerGainBase', label: 'Steer gain (base)', default: 8.0, unit: 'x' },
                    { key: 'steerGainDecay', label: 'Steer gain decay /kt', default: 0.06, unit: 'x' },
                    { key: 'steerDeadband', label: 'Steer deadband', default: 0.5, unit: '°' },
                    { key: 'rudderBias', label: 'P-factor rudder bias', default: 15, unit: '%' }
                ],
                checklist: ['Brake released', 'Heading captured', 'Rudder steering active'],
                liveFields: ['gs', 'hdgError', 'throttle', 'rudder'],
                setFields: [{ key: 'taxiThrottleMax', label: 'THR MAX' }, { key: 'taxiTargetGS', label: 'GS TGT' }, { key: 'taxiRudderMaxLow', label: 'RUD MAX' }],
                isFlight: true
            },
            {
                id: 'BEFORE_ROLL', name: 'BEFORE_ROLL', type: 'ground',
                condition: 'Phase enters TAKEOFF',
                inputs: [
                    { key: 'beforeRollMixture', label: 'Mixture', default: 100, unit: '%' }
                ],
                checklist: ['Mixture 100%', 'Parking brake released'],
                liveFields: ['mixture', 'parkingBrake']
            },
            {
                id: 'ROLL', name: 'ROLL', type: 'ground',
                condition: 'After BEFORE_ROLL',
                inputs: [
                    { key: 'rollThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'vrSpeed', label: 'Vr (rotate speed)', default: 55, unit: 'kt' },
                    { key: 'rollRudderBias', label: 'P-factor rudder bias', default: 8, unit: '%' }
                ],
                checklist: ['Full power applied', 'Runway heading locked', 'Rudder steering active'],
                liveFields: ['ias', 'vrBar', 'throttle', 'rudder'],
                setFields: [{ key: 'rollThrottle', label: 'THR SET' }, { key: 'vrSpeed', label: 'Vr' }]
            },
            {
                id: 'ROTATE', name: 'ROTATE', type: 'air',
                condition: 'IAS >= Vr',
                inputs: [
                    { key: 'rotateElevator', label: 'Elevator value', default: -30, unit: '(-) = nose up' },
                    { key: 'rotateTimeout', label: 'Max rotate time', default: 15, unit: 'sec' },
                    { key: 'rotateThrottle', label: 'Throttle', default: 100, unit: '%' }
                ],
                checklist: ['Elevator applied', 'Trim nose up', 'Waiting for liftoff (onGround=false)'],
                liveFields: ['ias', 'pitch', 'elevator', 'onGround'],
                setFields: [{ key: 'rotateElevator', label: 'ELEV SET' }, { key: 'rotateThrottle', label: 'THR SET' }, { key: 'rotateTimeout', label: 'TIMEOUT' }]
            },
            {
                id: 'LIFTOFF', name: 'LIFTOFF', type: 'air',
                condition: 'Not on ground',
                inputs: [
                    { key: 'liftoffElevator', label: 'Elevator value', default: -20, unit: '(-) = nose up' },
                    { key: 'liftoffThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'liftoffAileronGain', label: 'Aileron gain (prop.)', default: 5, unit: 'x bank deg' },
                    { key: 'liftoffAileronMax', label: 'Max aileron deflection', default: 30, unit: '%' },
                    { key: 'liftoffBankThreshold', label: 'Wings-level bank threshold', default: 2, unit: '°' },
                    { key: 'liftoffVsThreshold', label: 'VS threshold for next phase', default: 100, unit: 'fpm' },
                    { key: 'liftoffClimbAgl', label: 'Climb AGL for next phase', default: 200, unit: 'ft AGL' }
                ],
                checklist: ['Nose up hold', 'Wings level (proportional)', 'VS > threshold', 'Waiting for AGL threshold'],
                liveFields: ['agl', 'aglBar', 'vs', 'bank', 'elevator'],
                setFields: [{ key: 'liftoffElevator', label: 'ELEV SET' }, { key: 'liftoffVsThreshold', label: 'VS TRIG' }, { key: 'liftoffClimbAgl', label: 'AGL TRIG' }]
            },
            {
                id: 'INITIAL_CLIMB', name: 'INITIAL_CLIMB', type: 'air',
                condition: 'VS > 100 AND AGL > climb threshold',
                inputs: [
                    { key: 'climbElevator', label: 'Elevator value', default: -30, unit: '(-) = nose up' },
                    { key: 'climbPhaseThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'climbAileronGain', label: 'Aileron gain (prop.)', default: 5, unit: 'x bank deg' },
                    { key: 'climbAileronMax', label: 'Max aileron deflection', default: 30, unit: '%' },
                    { key: 'climbBankThreshold', label: 'Wings-level bank threshold', default: 3, unit: '°' },
                    { key: 'handoffAgl', label: 'AP handoff AGL', default: 500, unit: 'ft AGL' },
                    { key: 'handoffSpeedMargin', label: 'Speed margin above Vs1', default: 15, unit: 'kt' }
                ],
                checklist: ['Climbing steadily', 'Wings level', 'Waiting for AP handoff conditions'],
                liveFields: ['agl', 'handoffBar', 'ias', 'vs', 'bank'],
                setFields: [{ key: 'climbElevator', label: 'ELEV SET' }, { key: 'handoffAgl', label: 'HANDOFF AGL' }, { key: 'handoffSpeedMargin', label: 'SPD MARGIN' }]
            },
            {
                id: 'DEPARTURE', name: 'DEPARTURE', type: 'ap',
                condition: 'IAS >= Vs1+margin AND AGL > handoff',
                inputs: [
                    { key: 'departureVS', label: 'VS rate after AP engage', default: 500, unit: 'fpm' },
                    { key: 'departureSpeed', label: 'Climb speed (Vy)', default: 79, unit: 'kt' },
                    { key: 'departureCruiseAlt', label: 'Cruise altitude', default: 8500, unit: 'ft' }
                ],
                checklist: ['AP engaged', 'HDG hold active', 'VS hold active', 'Flaps retracted'],
                liveFields: ['vs', 'apMaster', 'flaps'],
                setFields: [{ key: 'departureVS', label: 'VS SET' }, { key: 'departureSpeed', label: 'SPD SET' }, { key: 'departureCruiseAlt', label: 'CRZ ALT' }]
            },
            {
                id: 'CLIMB', name: 'CLIMB', type: 'ap',
                condition: 'Phase transitions from flight-phase.js',
                inputs: [
                    { key: 'climbThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'climbVS', label: 'VS rate', default: 700, unit: 'fpm' }
                ],
                checklist: ['Full power maintained', 'Lateral nav active', 'ALT target set to cruise'],
                liveFields: ['throttle', 'vs', 'alt', 'ias'],
                setFields: [{ key: 'climbThrottle', label: 'THR SET' }, { key: 'climbVS', label: 'VS SET' }],
                isFlight: true
            }
        ];

        // Defaults
        const DEFAULTS = {};
        PHASES.forEach(p => p.inputs.forEach(i => { DEFAULTS[i.key] = i.default; }));

        // ── SimBrief pilot ID ──
        if (!localStorage.getItem('simbrief-pilot-id')) localStorage.setItem('simbrief-pilot-id', 'kingcobra74');

        // ── State ──
        let values = loadValues();
        let holds = loadHolds();
        let flightData = {};
        let currentPhase = '';
        let currentSubPhase = '';
        let aiEnabled = false;
        let aiControls = false;
        let fplLoaded = false;
        let wsConnected = false;
        let channel = null;
        let ws = null;
        let phaseStartTimes = {};  // { phaseId: Date timestamp }

        function loadValues() {
            try { const r = localStorage.getItem(STORAGE_KEY); return r ? { ...DEFAULTS, ...JSON.parse(r) } : { ...DEFAULTS }; }
            catch { return { ...DEFAULTS }; }
        }
        function loadHolds() {
            try { const r = localStorage.getItem(HOLDS_KEY); return r ? JSON.parse(r) : {}; }
            catch { return {}; }
        }
        // Map tuner keys → direct sim commands (sent immediately on change)
        const DIRECT_CMD_MAP = {
            preflightMixture: 'MIXTURE_SET',
            preflightThrottle: 'THROTTLE_SET',
            beforeRollMixture: 'MIXTURE_SET',
            taxiThrottleMax: 'THROTTLE_SET',
            taxiThrottleMin: 'THROTTLE_SET',
            rollThrottle: 'THROTTLE_SET',
            rotateThrottle: 'THROTTLE_SET',
            liftoffThrottle: 'THROTTLE_SET',
            climbPhaseThrottle: 'THROTTLE_SET',
            climbThrottle: 'THROTTLE_SET',
            rotateElevator: 'AXIS_ELEVATOR_SET',
            liftoffElevator: 'AXIS_ELEVATOR_SET',
            climbElevator: 'AXIS_ELEVATOR_SET',
        };

        const BASE = 'http://192.168.1.42:8080';

        function sendDirectCommand(key, value) {
            const cmd = DIRECT_CMD_MAP[key];
            if (!cmd) return;
            fetch(BASE + '/api/ai-pilot/command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: cmd, value: value })
            }).catch(() => {});
        }

        function saveValues(changedKey) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
            if (channel) channel.postMessage({ type: 'takeoff-tuning', values, timestamp: Date.now() });
            if (changedKey) sendDirectCommand(changedKey, values[changedKey]);
        }
        function saveHolds() {
            localStorage.setItem(HOLDS_KEY, JSON.stringify(holds));
            if (channel) channel.postMessage({ type: 'takeoff-holds', holds, timestamp: Date.now() });
        }

        // ── SafeChannel ──
        try { channel = new SafeChannel(CHANNEL_NAME); } catch(e) {}
        if (channel) {
            channel.onmessage = function(event) {
                const msg = event.data;
                if (!msg || !msg.type) return;
                if (msg.type === 'autopilot-state' && msg.data) {
                    currentPhase = msg.data.phase || '';
                    currentSubPhase = msg.data.takeoffSubPhase || '';
                    aiEnabled = !!msg.data.enabled;
                    aiControls = !!msg.data.autoControls;
                    fplLoaded = !!msg.data.fplLoaded;
                    updateActivePhase();
                    updateControlButtons();
                }
            };
        }

        // ── WebSocket ──
        function connectWS() {
            try { ws = new WebSocket('ws://192.168.1.42:8080'); } catch { return; }
            ws.onopen = function() {
                wsConnected = true;
                const el = document.getElementById('ls-conn');
                el.textContent = 'CONNECTED';
                el.className = 'ls-conn connected';
            };
            ws.onclose = function() {
                wsConnected = false;
                const el = document.getElementById('ls-conn');
                el.textContent = 'DISCONNECTED';
                el.className = 'ls-conn disconnected';
                setTimeout(connectWS, 3000);
            };
            ws.onerror = function() { ws.close(); };
            ws.onmessage = function(event) {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'flightData' && msg.data) {
                        flightData = msg.data;
                        updateLiveStrip();
                        updatePhaseLive();
                    }
                } catch {}
            };
        }
        connectWS();

        // ── Live strip update ──
        function updateLiveStrip() {
            const d = flightData;
            setText('ls-ias', Math.round(d.speed || 0));
            setText('ls-gs', Math.round(d.groundSpeed || 0));
            setText('ls-agl', Math.round(d.altitudeAGL || 0));
            setText('ls-vs', Math.round(d.verticalSpeed || 0));
            setText('ls-pitch', (d.pitch || 0).toFixed(1) + '\u00B0');
            setText('ls-bank', (d.bank || 0).toFixed(1) + '\u00B0');
            setText('ls-hdg', Math.round(d.heading || 0) + '\u00B0');
            setText('ls-thr', Math.round(d.throttle || 0) + '%');
            setText('ls-elev', Math.round(d.elevator || 0) + '%');
            setText('ls-ail', Math.round(d.aileron || 0) + '%');
            setText('ls-rud', Math.round(d.rudder || 0) + '%');
            setText('ls-phase', currentPhase || '--');
            setText('ls-sub', currentSubPhase || '--');
        }

        function setText(id, val) {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        }

        // ── Determine active phase ──
        function getActivePhaseId() {
            // Takeoff sub-phases during TAKEOFF flight phase
            if (currentPhase === 'TAKEOFF' && currentSubPhase) {
                return currentSubPhase;
            }
            // Flight-level phases
            return currentPhase;
        }

        // Phase ordering for "completed" detection
        const PHASE_ORDER = PHASES.map(p => p.id);

        function formatTime(date) {
            const h = String(date.getHours()).padStart(2, '0');
            const m = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            return h + ':' + m + ':' + s;
        }

        function updateActivePhase() {
            const activeId = getActivePhaseId();
            const activeIdx = PHASE_ORDER.indexOf(activeId);

            // Record start time when a phase becomes active for the first time
            if (activeId && !phaseStartTimes[activeId]) {
                phaseStartTimes[activeId] = new Date();
            }

            PHASES.forEach((phase, idx) => {
                const card = document.getElementById('card-' + phase.id);
                if (!card) return;
                card.classList.remove('active', 'completed');
                if (phase.id === activeId) {
                    card.classList.add('active');
                } else if (activeIdx >= 0 && idx < activeIdx) {
                    card.classList.add('completed');
                }
                // Update time display
                const timeEl = document.getElementById('time-' + phase.id);
                if (timeEl) {
                    timeEl.textContent = phaseStartTimes[phase.id] ? formatTime(phaseStartTimes[phase.id]) : '';
                }
            });
        }

        // ── Per-phase live values ──
        function updatePhaseLive() {
            const d = flightData;
            PHASES.forEach(phase => {
                const container = document.getElementById('live-' + phase.id);
                if (!container) return;
                const html = buildLiveHTML(phase, d);
                if (container._lastHTML !== html) {
                    container.innerHTML = html;
                    container._lastHTML = html;
                }
            });
        }

        function buildLiveHTML(phase, d) {
            const items = [];
            const ias = d.speed || 0;
            const gs = d.groundSpeed || 0;
            const agl = d.altitudeAGL || 0;
            const vs = d.verticalSpeed || 0;

            (phase.liveFields || []).forEach(field => {
                switch (field) {
                    case 'ias': items.push(lv('IAS', Math.round(ias) + ' kt')); break;
                    case 'gs': items.push(lv('GS', Math.round(gs) + ' kt')); break;
                    case 'agl': items.push(lv('AGL', Math.round(agl) + ' ft')); break;
                    case 'vs': items.push(lv('VS', Math.round(vs) + ' fpm', vs > 50 ? 'good' : vs < -100 ? 'danger' : '')); break;
                    case 'alt': items.push(lv('ALT', Math.round(d.altitude || 0) + ' ft')); break;
                    case 'pitch': items.push(lv('PITCH', (d.pitch || 0).toFixed(1) + '\u00B0')); break;
                    case 'bank': {
                        const b = Math.abs(d.bank || 0);
                        items.push(lv('BANK', (d.bank || 0).toFixed(1) + '\u00B0', b > 10 ? 'warn' : ''));
                        break;
                    }
                    case 'throttle': items.push(lv('THR', Math.round(d.throttle || 0) + '%')); break;
                    case 'elevator': items.push(lv('ELEV', Math.round(d.elevator || 0) + '%')); break;
                    case 'rudder': items.push(lv('RUD', Math.round(d.rudder || 0) + '%')); break;
                    case 'mixture': items.push(lv('MIX', Math.round(d.mixture || 0) + '%')); break;
                    case 'flaps': items.push(lv('FLAPS', d.flapsIndex || 0)); break;
                    case 'parkingBrake': items.push(lv('BRK', d.parkingBrake ? 'ON' : 'OFF', d.parkingBrake ? 'warn' : 'good')); break;
                    case 'onGround': {
                        const og = d.onGround || (agl < 50 && Math.abs(vs) < 200);
                        items.push(lv('GND', og ? 'YES' : 'NO', og ? 'warn' : 'good'));
                        break;
                    }
                    case 'apMaster': items.push(lv('AP', d.apMaster ? 'ON' : 'OFF', d.apMaster ? 'good' : '')); break;
                    case 'hdgError': {
                        // Can't compute hdg error without runway heading, show heading
                        items.push(lv('HDG', Math.round(d.heading || 0) + '\u00B0'));
                        break;
                    }
                    case 'vrBar': {
                        const vr = values.vrSpeed ?? 55;
                        const pct = Math.min(100, Math.max(0, (ias / vr) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 70 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">Vr ${Math.round(vr)}</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(ias)}</span></div>`);
                        break;
                    }
                    case 'aglBar': {
                        const thresh = values.liftoffClimbAgl ?? 200;
                        const pct = Math.min(100, Math.max(0, (agl / thresh) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 50 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">${Math.round(thresh)}ft</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(agl)}</span></div>`);
                        break;
                    }
                    case 'handoffBar': {
                        const thresh = values.handoffAgl ?? 500;
                        const pct = Math.min(100, Math.max(0, (agl / thresh) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 50 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">${Math.round(thresh)}ft</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(agl)}</span></div>`);
                        break;
                    }
                }
            });
            return items.join('');
        }

        function lv(label, val, cls) {
            return `<div class="pl-item"><span class="pl-label">${label}</span><span class="pl-val ${cls || ''}">${val}</span></div>`;
        }

        // ── Toast ──
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        // ── Render ──
        function render() {
            const container = document.getElementById('phases');
            container.innerHTML = '';

            PHASES.forEach((phase, idx) => {
                if (idx > 0) {
                    const conn = document.createElement('div');
                    conn.className = 'phase-connector';
                    container.appendChild(conn);
                }

                const card = document.createElement('div');
                const typeClass = phase.type === 'ground' ? 'phase-ground' : phase.type === 'air' ? 'phase-air' : 'phase-ap';
                card.className = `phase-card ${typeClass}`;
                card.id = 'card-' + phase.id;

                // Header with hold button
                const header = document.createElement('div');
                header.className = 'phase-header';

                const dot = document.createElement('div');
                dot.className = 'active-dot';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'phase-name-text';
                const nameText = document.createTextNode(phase.name);
                const timeSpan = document.createElement('span');
                timeSpan.className = 'phase-time';
                timeSpan.id = 'time-' + phase.id;
                timeSpan.textContent = phaseStartTimes[phase.id] ? formatTime(phaseStartTimes[phase.id]) : '';
                nameSpan.appendChild(nameText);
                nameSpan.appendChild(timeSpan);

                const condSpan = document.createElement('span');
                condSpan.className = 'condition';
                condSpan.textContent = phase.condition;

                // Go/Hold button — 3 states: default GO (gray), active GO (green), HOLD (red)
                const holdBtn = document.createElement('button');
                holdBtn.id = 'hold-' + phase.id;
                if (holds[phase.id]) {
                    holdBtn.className = 'hold-btn held';
                    holdBtn.textContent = 'HOLD';
                } else {
                    holdBtn.className = 'hold-btn';
                    holdBtn.textContent = 'GO';
                }
                holdBtn.addEventListener('click', function() {
                    if (holds[phase.id]) {
                        // HOLD → GO (highlighted): release hold + force-start phase
                        holds[phase.id] = false;
                        this.className = 'hold-btn go';
                        this.textContent = 'GO';
                        saveHolds();
                        // Force-start this phase via SafeChannel
                        if (channel) channel.postMessage({ type: 'tuner-command', command: 'set-phase', phase: phase.id });
                        showToast(phase.name + ' GO');
                    } else if (this.classList.contains('go')) {
                        // GO (highlighted) → HOLD: set hold
                        holds[phase.id] = true;
                        this.className = 'hold-btn held';
                        this.textContent = 'HOLD';
                        saveHolds();
                        showToast(phase.name + ' HOLD');
                    } else {
                        // GO (gray) → GO (highlighted): activate + force-start phase
                        this.className = 'hold-btn go';
                        if (channel) channel.postMessage({ type: 'tuner-command', command: 'set-phase', phase: phase.id });
                        showToast(phase.name + ' GO');
                    }
                });

                header.appendChild(dot);
                header.appendChild(nameSpan);
                header.appendChild(condSpan);
                header.appendChild(holdBtn);
                card.appendChild(header);

                // Body
                const body = document.createElement('div');
                body.className = 'phase-body';

                // Live readout
                const liveDiv = document.createElement('div');
                liveDiv.className = 'phase-live';
                liveDiv.id = 'live-' + phase.id;
                body.appendChild(liveDiv);

                // Set values strip — shows current tuner targets at a glance
                if (phase.setFields && phase.setFields.length > 0) {
                    const setDiv = document.createElement('div');
                    setDiv.className = 'phase-set';
                    setDiv.id = 'set-' + phase.id;
                    phase.setFields.forEach(sf => {
                        const v = values[sf.key] ?? DEFAULTS[sf.key] ?? '?';
                        const input = (phase.inputs || []).find(i => i.key === sf.key);
                        const unit = input ? input.unit.replace('(-) = nose up', '%') : '';
                        const span = document.createElement('span');
                        span.className = 'set-item';
                        span.dataset.key = sf.key;
                        span.innerHTML = `<span class="set-label">${esc(sf.label)}</span><span class="set-val">${esc(String(v))}${unit ? ' ' + esc(unit) : ''}</span>`;
                        setDiv.appendChild(span);
                    });
                    body.appendChild(setDiv);
                }

                // Inputs
                if (phase.inputs.length > 0) {
                    const grid = document.createElement('div');
                    grid.className = 'inputs-grid';
                    phase.inputs.forEach(input => {
                        const group = document.createElement('div');
                        group.className = 'input-group';
                        const label = document.createElement('label');
                        label.textContent = input.label;
                        const inp = document.createElement('input');
                        inp.type = 'number';
                        inp.step = 'any';
                        inp.id = 'input-' + input.key;
                        inp.value = values[input.key] ?? input.default;
                        inp.addEventListener('input', function() {
                            const v = parseFloat(this.value);
                            if (!isNaN(v)) {
                                values[input.key] = v;
                                saveValues(input.key);
                                // Update matching set-value display
                                document.querySelectorAll(`.set-item[data-key="${input.key}"] .set-val`).forEach(el => {
                                    const u = input.unit.replace('(-) = nose up', '%');
                                    el.textContent = v + (u ? ' ' + u : '');
                                });
                            }
                        });
                        const unit = document.createElement('div');
                        unit.className = 'unit';
                        unit.textContent = input.unit;
                        group.appendChild(label);
                        group.appendChild(inp);
                        group.appendChild(unit);
                        grid.appendChild(group);
                    });
                    body.appendChild(grid);
                } else {
                    const ni = document.createElement('div');
                    ni.className = 'no-inputs';
                    ni.textContent = 'No tunable values';
                    body.appendChild(ni);
                }

                // Checklist
                if (phase.checklist.length > 0) {
                    const cl = document.createElement('div');
                    cl.className = 'checklist';
                    phase.checklist.forEach((item, ci) => {
                        const div = document.createElement('div');
                        div.className = 'checklist-item';
                        div.id = `cl-${phase.id}-${ci}`;
                        div.textContent = item;
                        cl.appendChild(div);
                    });
                    body.appendChild(cl);
                }

                card.appendChild(body);
                container.appendChild(card);
            });

            updateActivePhase();
        }

        // ── Control buttons (AI toggle, Controls, FPL) ──
        function sendTunerCommand(cmd) {
            if (channel) channel.postMessage({ type: 'tuner-command', command: cmd });
        }
        function updateControlButtons() {
            const aiBtn = document.getElementById('ctrl-ai');
            const ctrlBtn = document.getElementById('ctrl-controls');
            if (aiBtn) {
                aiBtn.textContent = aiEnabled ? 'ON' : 'OFF';
                aiBtn.classList.toggle('on', aiEnabled);
            }
            if (ctrlBtn) {
                ctrlBtn.classList.toggle('on', aiControls);
            }
            const fplBtn = document.getElementById('ctrl-fpl');
            if (fplBtn) {
                fplBtn.classList.toggle('on', fplLoaded);
            }
        }
        document.getElementById('ctrl-ai').addEventListener('click', function() {
            sendTunerCommand('toggle-ai');
        });
        document.getElementById('ctrl-controls').addEventListener('click', function() {
            sendTunerCommand('toggle-controls');
        });
        document.getElementById('ctrl-fpl').addEventListener('click', function() {
            sendTunerCommand('import-fpl');
            showToast('SimBrief import requested');
        });

        // ── Buttons ──
        document.getElementById('btn-clear-convos').addEventListener('click', function() {
            if (!confirm('Clear conversation log?\n\nOld conversations will be archived to a timestamped file.')) return;
            fetch(BASE + '/api/ai-pilot/conversations', { method: 'DELETE' })
                .then(r => r.json())
                .then(res => showToast(res.ok ? 'Conversations archived & cleared' : 'Failed'))
                .catch(() => showToast('Failed — server error'));
        });

        document.getElementById('btn-nuke').addEventListener('click', function() {
            if (!confirm('Reset ALL Sally learning?\n\nThis clears:\n- All learnings & observations\n- All takeoff attempt history\n- All tuner overrides\n- LocalStorage tuning on all browsers')) return;
            fetch(BASE + '/api/ai-pilot/reset-learning', { method: 'POST' })
                .then(r => r.json())
                .then(res => {
                    // Also reset local tuner to defaults
                    values = { ...DEFAULTS };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
                    holds = {};
                    saveHolds();
                    if (channel) channel.postMessage({ type: 'takeoff-tuning', values, timestamp: Date.now() });
                    render();
                    showToast(res.ok ? 'Sally learning fully reset' : 'Reset failed');
                })
                .catch(() => showToast('Reset failed — server error'));
        });

        document.getElementById('btn-reset').addEventListener('click', function() {
            values = { ...DEFAULTS };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
            if (channel) channel.postMessage({ type: 'takeoff-tuning', values, timestamp: Date.now() });
            render();
            showToast('Reset to defaults');
        });

        document.getElementById('btn-copy').addEventListener('click', function() {
            const combined = { tuning: values, holds };
            const json = JSON.stringify(combined, null, 2);
            navigator.clipboard.writeText(json).then(() => showToast('Copied to clipboard'))
                .catch(() => { showToast('Copied to clipboard'); });
        });

        document.getElementById('btn-release-all').addEventListener('click', function() {
            holds = {};
            saveHolds();
            document.querySelectorAll('.hold-btn').forEach(btn => {
                btn.className = 'hold-btn';
                btn.textContent = 'GO';
            });
            showToast('All holds released');
        });

        render();
    })();
    </script>
</body>
</html>
