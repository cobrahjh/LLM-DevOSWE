<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Takeoff Tuner - SimGlass</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e14;
            color: #c0c8d8;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 13px;
            padding: 16px;
            min-height: 100vh;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #1a2030;
        }
        .header h1 { font-size: 18px; font-weight: 600; color: #ffab40; letter-spacing: 1px; }
        .header-actions { display: flex; gap: 8px; align-items: center; }
        .btn {
            background: #1a2030; color: #c0c8d8; border: 1px solid #2a3040;
            padding: 5px 12px; border-radius: 4px; cursor: pointer;
            font-size: 11px; font-family: inherit; transition: background 0.15s;
        }
        .btn:hover { background: #2a3040; }
        .btn-reset { border-color: #ff5252; color: #ff5252; }
        .btn-reset:hover { background: #2a1515; }
        .btn-copy { border-color: #4fc3f7; color: #4fc3f7; }
        .btn-copy:hover { background: #152a30; }

        /* ── Control buttons ── */
        .ctrl-bar {
            display: flex; gap: 8px; align-items: center;
            margin-bottom: 12px;
        }
        .ctrl-btn {
            padding: 7px 16px; border-radius: 4px; cursor: pointer;
            font-size: 12px; font-weight: 600; font-family: inherit;
            letter-spacing: 0.5px; transition: all 0.15s; border: 1px solid;
        }
        .ctrl-btn-ai {
            background: #1a2030; color: #ff5252; border-color: #ff5252;
        }
        .ctrl-btn-ai.on { background: #1a3020; color: #66bb6a; border-color: #66bb6a; }
        .ctrl-btn-controls {
            background: #1a2030; color: #607080; border-color: #2a3040;
        }
        .ctrl-btn-controls.on { background: #1a2530; color: #4fc3f7; border-color: #4fc3f7; }
        .ctrl-btn-fpl {
            background: #1a2030; color: #607080; border-color: #2a3040;
        }
        .ctrl-btn-fpl:hover { background: #2a3040; }
        .ctrl-btn-fpl.on { background: #1a2520; color: #ffab40; border-color: #ffab40; }
        .ctrl-btn:hover { opacity: 0.85; }
        .ctrl-spacer { flex: 1; }

        /* ── Live data strip ── */
        .live-strip {
            background: #0d1218; border: 1px solid #1a2030; border-radius: 6px;
            padding: 8px 14px; margin-bottom: 12px;
            display: flex; gap: 20px; align-items: center; flex-wrap: wrap;
        }
        .live-strip .ls-item { display: flex; flex-direction: column; align-items: center; min-width: 55px; }
        .live-strip .ls-label { font-size: 9px; color: #506070; text-transform: uppercase; letter-spacing: 0.5px; }
        .live-strip .ls-val { font-size: 15px; font-family: 'Consolas', monospace; color: #e0e8f0; }
        .live-strip .ls-conn { margin-left: auto; font-size: 11px; }
        .ls-conn.connected { color: #66bb6a; }
        .ls-conn.disconnected { color: #ff5252; }
        .live-strip .ls-phase-label { font-size: 10px; color: #506070; }
        .live-strip .ls-phase-val { font-size: 14px; font-weight: 600; color: #ffab40; font-family: 'Consolas', monospace; }
        .live-strip .ls-sub { font-size: 12px; color: #4fc3f7; font-family: 'Consolas', monospace; }

        /* ── Phase cards ── */
        .phases { display: flex; flex-direction: column; gap: 0; }

        .phase-card {
            background: #0d1218; border: 1px solid #1a2030; border-radius: 6px;
            overflow: hidden; transition: border-color 0.3s, box-shadow 0.3s;
        }
        .phase-card.active { border-color: #ffab40; box-shadow: 0 0 12px rgba(255, 171, 64, 0.15); }
        .phase-card.active.phase-air { border-color: #4fc3f7; box-shadow: 0 0 12px rgba(79, 195, 247, 0.15); }
        .phase-card.active.phase-ap { border-color: #66bb6a; box-shadow: 0 0 12px rgba(102, 187, 106, 0.15); }
        .phase-card.completed { opacity: 0.5; }

        .phase-header {
            padding: 8px 14px; font-size: 13px; font-weight: 600; letter-spacing: 0.5px;
            display: flex; align-items: center; gap: 10px; cursor: default;
        }
        .phase-header .phase-name-text { flex: 1; }
        .phase-header .condition { font-weight: 400; font-size: 10px; opacity: 0.6; flex: 1; text-align: right; }
        .phase-ground .phase-header { background: #1a1500; color: #ffab40; border-left: 3px solid #ffab40; }
        .phase-air .phase-header { background: #001520; color: #4fc3f7; border-left: 3px solid #4fc3f7; }
        .phase-ap .phase-header { background: #001a10; color: #66bb6a; border-left: 3px solid #66bb6a; }

        /* Hold button */
        .hold-btn {
            background: none; border: 1px solid currentColor; color: inherit;
            padding: 2px 8px; border-radius: 3px; cursor: pointer;
            font-size: 10px; font-weight: 600; letter-spacing: 0.5px;
            font-family: inherit; transition: all 0.15s; flex-shrink: 0;
        }
        .hold-btn:hover { opacity: 0.8; }
        .hold-btn.held { background: #ff5252; border-color: #ff5252; color: #fff; }
        .hold-btn.held:hover { background: #e04848; }

        /* Active indicator dot */
        .active-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
            background: transparent; transition: background 0.3s;
        }
        .phase-card.active .active-dot { background: currentColor; animation: pulse-dot 1.2s infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .phase-connector { width: 2px; height: 6px; background: #2a3040; margin: 0 auto; }

        .phase-body { padding: 8px 14px 10px; }

        /* ── Live readout per phase ── */
        .phase-live {
            display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 8px;
            padding: 5px 8px; background: #080c10; border-radius: 4px;
            min-height: 26px; align-items: center;
        }
        .phase-live:empty { display: none; }
        .pl-item { display: flex; align-items: baseline; gap: 4px; }
        .pl-label { font-size: 9px; color: #506070; text-transform: uppercase; }
        .pl-val { font-size: 12px; font-family: 'Consolas', monospace; color: #e0e8f0; }
        .pl-val.warn { color: #ffab40; }
        .pl-val.good { color: #66bb6a; }
        .pl-val.danger { color: #ff5252; }
        /* Progress bar for threshold values */
        .pl-bar { width: 60px; height: 4px; background: #1a2030; border-radius: 2px; position: relative; overflow: hidden; }
        .pl-bar-fill { height: 100%; border-radius: 2px; transition: width 0.2s; }
        .pl-bar-fill.low { background: #ffab40; }
        .pl-bar-fill.mid { background: #4fc3f7; }
        .pl-bar-fill.full { background: #66bb6a; }

        /* ── Inputs grid ── */
        .inputs-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(165px, 1fr)); gap: 6px; }
        .input-group { display: flex; flex-direction: column; gap: 1px; }
        .input-group label { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; color: #506070; }
        .input-group input {
            background: #0a0e14; border: 1px solid #2a3040; color: #e0e8f0;
            padding: 4px 7px; border-radius: 3px; font-size: 13px;
            font-family: 'Consolas', monospace; width: 100%; outline: none;
            transition: border-color 0.15s;
        }
        .input-group input:focus { border-color: #4fc3f7; }
        .input-group input::-webkit-inner-spin-button { opacity: 0.3; }
        .input-group .unit { font-size: 9px; color: #404850; }

        .checklist { margin-top: 6px; padding-top: 6px; border-top: 1px solid #1a2030; }
        .checklist-item {
            font-size: 10px; color: #506070; padding: 1px 0;
            display: flex; align-items: center; gap: 5px;
        }
        .checklist-item::before { content: '\2610'; font-size: 11px; }
        .checklist-item.done { color: #66bb6a; }
        .checklist-item.done::before { content: '\2611'; }

        .no-inputs { font-size: 11px; color: #404850; font-style: italic; }

        .toast {
            position: fixed; bottom: 20px; right: 20px; background: #1a2030;
            border: 1px solid #4fc3f7; color: #4fc3f7; padding: 10px 18px;
            border-radius: 6px; font-size: 12px; opacity: 0;
            transition: opacity 0.3s; pointer-events: none; z-index: 100;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>
    <div class="header">
        <h1>TAKEOFF TUNER</h1>
        <div class="header-actions">
            <button class="btn" id="btn-release-all">Release All Holds</button>
            <button class="btn btn-copy" id="btn-copy">Copy JSON</button>
            <button class="btn btn-reset" id="btn-reset">Reset Defaults</button>
        </div>
    </div>

    <div class="ctrl-bar">
        <button class="ctrl-btn ctrl-btn-fpl" id="ctrl-fpl">FPL</button>
        <button class="ctrl-btn ctrl-btn-ai" id="ctrl-ai">OFF</button>
        <button class="ctrl-btn ctrl-btn-controls" id="ctrl-controls">AI CONTROLS</button>
        <div class="ctrl-spacer"></div>
    </div>

    <div class="live-strip" id="live-strip">
        <div class="ls-item"><span class="ls-label">IAS</span><span class="ls-val" id="ls-ias">--</span></div>
        <div class="ls-item"><span class="ls-label">GS</span><span class="ls-val" id="ls-gs">--</span></div>
        <div class="ls-item"><span class="ls-label">AGL</span><span class="ls-val" id="ls-agl">--</span></div>
        <div class="ls-item"><span class="ls-label">VS</span><span class="ls-val" id="ls-vs">--</span></div>
        <div class="ls-item"><span class="ls-label">PITCH</span><span class="ls-val" id="ls-pitch">--</span></div>
        <div class="ls-item"><span class="ls-label">BANK</span><span class="ls-val" id="ls-bank">--</span></div>
        <div class="ls-item"><span class="ls-label">HDG</span><span class="ls-val" id="ls-hdg">--</span></div>
        <div class="ls-item"><span class="ls-label">THR</span><span class="ls-val" id="ls-thr">--</span></div>
        <div class="ls-item">
            <span class="ls-phase-label">PHASE</span>
            <span class="ls-phase-val" id="ls-phase">--</span>
        </div>
        <div class="ls-item">
            <span class="ls-phase-label">SUB</span>
            <span class="ls-sub" id="ls-sub">--</span>
        </div>
        <span class="ls-conn disconnected" id="ls-conn">DISCONNECTED</span>
    </div>

    <div class="phases" id="phases"></div>
    <div class="toast" id="toast"></div>

    <script src="/ui/shared/safe-channel.js"></script>
    <script>
    (function() {
        const STORAGE_KEY = 'simglass-takeoff-tuning';
        const HOLDS_KEY = 'simglass-takeoff-holds';
        const CHANNEL_NAME = 'SimGlass-sync';

        // ── Phase definitions ──
        const PHASES = [
            {
                id: 'PREFLIGHT', name: 'PREFLIGHT', type: 'ground',
                condition: 'On ground, AI enabled',
                inputs: [],
                checklist: ['Mixture rich', 'Flaps set', 'Trim set', 'Parking brake ON'],
                liveFields: ['mixture', 'flaps', 'parkingBrake'],
                isFlight: true  // flight-level phase (not takeoff sub-phase)
            },
            {
                id: 'TAXI', name: 'TAXI', type: 'ground',
                condition: 'GS > 0.5 kt',
                inputs: [
                    { key: 'taxiThrottleMax', label: 'Throttle aligned max', default: 70, unit: '%' },
                    { key: 'taxiThrottleMin', label: 'Throttle misaligned min', default: 25, unit: '%' },
                    { key: 'taxiTargetGS', label: 'Target ground speed', default: 25, unit: 'kt' },
                    { key: 'taxiRudderMaxLow', label: 'Rudder authority (low speed)', default: 60, unit: '%' }
                ],
                checklist: ['Brake released', 'Heading captured', 'Rudder steering active'],
                liveFields: ['gs', 'hdgError', 'throttle', 'rudder'],
                isFlight: true
            },
            {
                id: 'BEFORE_ROLL', name: 'BEFORE_ROLL', type: 'ground',
                condition: 'Phase enters TAKEOFF',
                inputs: [],
                checklist: ['Mixture 100%', 'Parking brake released'],
                liveFields: ['mixture', 'parkingBrake']
            },
            {
                id: 'ROLL', name: 'ROLL', type: 'ground',
                condition: 'After BEFORE_ROLL',
                inputs: [
                    { key: 'rollThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'vrSpeed', label: 'Vr (rotate speed)', default: 55, unit: 'kt' }
                ],
                checklist: ['Full power applied', 'Runway heading locked', 'Rudder steering active'],
                liveFields: ['ias', 'vrBar', 'throttle', 'rudder']
            },
            {
                id: 'ROTATE', name: 'ROTATE', type: 'air',
                condition: 'IAS >= Vr',
                inputs: [
                    { key: 'rotateElevator', label: 'Elevator value', default: -50, unit: '(-) = nose up' },
                    { key: 'rotateTimeout', label: 'Max rotate time', default: 15, unit: 'sec' }
                ],
                checklist: ['Elevator applied', 'Trim nose up', 'Waiting for liftoff (onGround=false)'],
                liveFields: ['ias', 'pitch', 'elevator', 'onGround']
            },
            {
                id: 'LIFTOFF', name: 'LIFTOFF', type: 'air',
                condition: 'Not on ground',
                inputs: [
                    { key: 'liftoffElevator', label: 'Elevator value', default: -40, unit: '(-) = nose up' },
                    { key: 'liftoffAileronGain', label: 'Aileron gain (prop.)', default: 2, unit: 'x bank deg' },
                    { key: 'liftoffAileronMax', label: 'Max aileron deflection', default: 30, unit: '%' },
                    { key: 'liftoffClimbAgl', label: 'Climb AGL for next phase', default: 200, unit: 'ft AGL' }
                ],
                checklist: ['Nose up hold', 'Wings level (proportional)', 'VS > 100 fpm', 'Waiting for AGL threshold'],
                liveFields: ['agl', 'aglBar', 'vs', 'bank', 'elevator']
            },
            {
                id: 'INITIAL_CLIMB', name: 'INITIAL_CLIMB', type: 'air',
                condition: 'VS > 100 AND AGL > climb threshold',
                inputs: [
                    { key: 'climbElevator', label: 'Elevator value', default: -30, unit: '(-) = nose up' },
                    { key: 'climbAileronGain', label: 'Aileron gain (prop.)', default: 2, unit: 'x bank deg' },
                    { key: 'climbAileronMax', label: 'Max aileron deflection', default: 30, unit: '%' },
                    { key: 'handoffAgl', label: 'AP handoff AGL', default: 500, unit: 'ft AGL' },
                    { key: 'handoffSpeedMargin', label: 'Speed margin above Vs1', default: 15, unit: 'kt' }
                ],
                checklist: ['Climbing steadily', 'Wings level', 'Waiting for AP handoff conditions'],
                liveFields: ['agl', 'handoffBar', 'ias', 'vs', 'bank']
            },
            {
                id: 'DEPARTURE', name: 'DEPARTURE', type: 'ap',
                condition: 'IAS >= Vs1+margin AND AGL > handoff',
                inputs: [
                    { key: 'departureVS', label: 'VS rate after AP engage', default: 500, unit: 'fpm' }
                ],
                checklist: ['AP engaged', 'HDG hold active', 'VS hold active', 'Flaps retracted'],
                liveFields: ['vs', 'apMaster', 'flaps']
            },
            {
                id: 'CLIMB', name: 'CLIMB', type: 'ap',
                condition: 'Phase transitions from flight-phase.js',
                inputs: [
                    { key: 'climbThrottle', label: 'Throttle', default: 100, unit: '%' },
                    { key: 'climbVS', label: 'VS rate', default: 700, unit: 'fpm' }
                ],
                checklist: ['Full power maintained', 'Lateral nav active', 'ALT target set to cruise'],
                liveFields: ['throttle', 'vs', 'alt', 'ias'],
                isFlight: true
            }
        ];

        // Defaults
        const DEFAULTS = {};
        PHASES.forEach(p => p.inputs.forEach(i => { DEFAULTS[i.key] = i.default; }));

        // ── SimBrief pilot ID ──
        if (!localStorage.getItem('simbrief-pilot-id')) localStorage.setItem('simbrief-pilot-id', 'kingcobra74');

        // ── State ──
        let values = loadValues();
        let holds = loadHolds();
        let flightData = {};
        let currentPhase = '';
        let currentSubPhase = '';
        let aiEnabled = false;
        let aiControls = false;
        let fplLoaded = false;
        let wsConnected = false;
        let channel = null;
        let ws = null;

        function loadValues() {
            try { const r = localStorage.getItem(STORAGE_KEY); return r ? { ...DEFAULTS, ...JSON.parse(r) } : { ...DEFAULTS }; }
            catch { return { ...DEFAULTS }; }
        }
        function loadHolds() {
            try { const r = localStorage.getItem(HOLDS_KEY); return r ? JSON.parse(r) : {}; }
            catch { return {}; }
        }
        function saveValues() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
            if (channel) channel.postMessage({ type: 'takeoff-tuning', values, timestamp: Date.now() });
        }
        function saveHolds() {
            localStorage.setItem(HOLDS_KEY, JSON.stringify(holds));
            if (channel) channel.postMessage({ type: 'takeoff-holds', holds, timestamp: Date.now() });
        }

        // ── SafeChannel ──
        try { channel = new SafeChannel(CHANNEL_NAME); } catch(e) {}
        if (channel) {
            channel.onmessage = function(event) {
                const msg = event.data;
                if (!msg || !msg.type) return;
                if (msg.type === 'autopilot-state' && msg.data) {
                    currentPhase = msg.data.phase || '';
                    currentSubPhase = msg.data.takeoffSubPhase || '';
                    aiEnabled = !!msg.data.enabled;
                    aiControls = !!msg.data.autoControls;
                    fplLoaded = !!msg.data.fplLoaded;
                    updateActivePhase();
                    updateControlButtons();
                }
            };
        }

        // ── WebSocket ──
        function connectWS() {
            const host = location.hostname || 'localhost';
            const port = location.port || '8080';
            try { ws = new WebSocket(`ws://${host}:${port}`); } catch { return; }
            ws.onopen = function() {
                wsConnected = true;
                const el = document.getElementById('ls-conn');
                el.textContent = 'CONNECTED';
                el.className = 'ls-conn connected';
            };
            ws.onclose = function() {
                wsConnected = false;
                const el = document.getElementById('ls-conn');
                el.textContent = 'DISCONNECTED';
                el.className = 'ls-conn disconnected';
                setTimeout(connectWS, 3000);
            };
            ws.onerror = function() { ws.close(); };
            ws.onmessage = function(event) {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'flightData' && msg.data) {
                        flightData = msg.data;
                        updateLiveStrip();
                        updatePhaseLive();
                    }
                } catch {}
            };
        }
        connectWS();

        // ── Live strip update ──
        function updateLiveStrip() {
            const d = flightData;
            setText('ls-ias', Math.round(d.speed || 0));
            setText('ls-gs', Math.round(d.groundSpeed || 0));
            setText('ls-agl', Math.round(d.altitudeAGL || 0));
            setText('ls-vs', Math.round(d.verticalSpeed || 0));
            setText('ls-pitch', (d.pitch || 0).toFixed(1) + '\u00B0');
            setText('ls-bank', (d.bank || 0).toFixed(1) + '\u00B0');
            setText('ls-hdg', Math.round(d.heading || 0) + '\u00B0');
            setText('ls-thr', Math.round(d.throttle || 0) + '%');
            setText('ls-phase', currentPhase || '--');
            setText('ls-sub', currentSubPhase || '--');
        }

        function setText(id, val) {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        }

        // ── Determine active phase ──
        function getActivePhaseId() {
            // Takeoff sub-phases during TAKEOFF flight phase
            if (currentPhase === 'TAKEOFF' && currentSubPhase) {
                return currentSubPhase;
            }
            // Flight-level phases
            return currentPhase;
        }

        // Phase ordering for "completed" detection
        const PHASE_ORDER = PHASES.map(p => p.id);

        function updateActivePhase() {
            const activeId = getActivePhaseId();
            const activeIdx = PHASE_ORDER.indexOf(activeId);

            PHASES.forEach((phase, idx) => {
                const card = document.getElementById('card-' + phase.id);
                if (!card) return;
                card.classList.remove('active', 'completed');
                if (phase.id === activeId) {
                    card.classList.add('active');
                } else if (activeIdx >= 0 && idx < activeIdx) {
                    card.classList.add('completed');
                }
            });
        }

        // ── Per-phase live values ──
        function updatePhaseLive() {
            const d = flightData;
            PHASES.forEach(phase => {
                const container = document.getElementById('live-' + phase.id);
                if (!container) return;
                const html = buildLiveHTML(phase, d);
                if (container._lastHTML !== html) {
                    container.innerHTML = html;
                    container._lastHTML = html;
                }
            });
        }

        function buildLiveHTML(phase, d) {
            const items = [];
            const ias = d.speed || 0;
            const gs = d.groundSpeed || 0;
            const agl = d.altitudeAGL || 0;
            const vs = d.verticalSpeed || 0;

            (phase.liveFields || []).forEach(field => {
                switch (field) {
                    case 'ias': items.push(lv('IAS', Math.round(ias) + ' kt')); break;
                    case 'gs': items.push(lv('GS', Math.round(gs) + ' kt')); break;
                    case 'agl': items.push(lv('AGL', Math.round(agl) + ' ft')); break;
                    case 'vs': items.push(lv('VS', Math.round(vs) + ' fpm', vs > 50 ? 'good' : vs < -100 ? 'danger' : '')); break;
                    case 'alt': items.push(lv('ALT', Math.round(d.altitude || 0) + ' ft')); break;
                    case 'pitch': items.push(lv('PITCH', (d.pitch || 0).toFixed(1) + '\u00B0')); break;
                    case 'bank': {
                        const b = Math.abs(d.bank || 0);
                        items.push(lv('BANK', (d.bank || 0).toFixed(1) + '\u00B0', b > 10 ? 'warn' : ''));
                        break;
                    }
                    case 'throttle': items.push(lv('THR', Math.round(d.throttle || 0) + '%')); break;
                    case 'elevator': items.push(lv('ELEV', Math.round(d.elevator || 0) + '%')); break;
                    case 'rudder': items.push(lv('RUD', Math.round(d.rudder || 0) + '%')); break;
                    case 'mixture': items.push(lv('MIX', Math.round(d.mixture || 0) + '%')); break;
                    case 'flaps': items.push(lv('FLAPS', d.flapsIndex || 0)); break;
                    case 'parkingBrake': items.push(lv('BRK', d.parkingBrake ? 'ON' : 'OFF', d.parkingBrake ? 'warn' : 'good')); break;
                    case 'onGround': {
                        const og = d.onGround || (agl < 50 && Math.abs(vs) < 200);
                        items.push(lv('GND', og ? 'YES' : 'NO', og ? 'warn' : 'good'));
                        break;
                    }
                    case 'apMaster': items.push(lv('AP', d.apMaster ? 'ON' : 'OFF', d.apMaster ? 'good' : '')); break;
                    case 'hdgError': {
                        // Can't compute hdg error without runway heading, show heading
                        items.push(lv('HDG', Math.round(d.heading || 0) + '\u00B0'));
                        break;
                    }
                    case 'vrBar': {
                        const vr = values.vrSpeed ?? 55;
                        const pct = Math.min(100, Math.max(0, (ias / vr) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 70 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">Vr ${Math.round(vr)}</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(ias)}</span></div>`);
                        break;
                    }
                    case 'aglBar': {
                        const thresh = values.liftoffClimbAgl ?? 200;
                        const pct = Math.min(100, Math.max(0, (agl / thresh) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 50 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">${Math.round(thresh)}ft</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(agl)}</span></div>`);
                        break;
                    }
                    case 'handoffBar': {
                        const thresh = values.handoffAgl ?? 500;
                        const pct = Math.min(100, Math.max(0, (agl / thresh) * 100));
                        const cls = pct >= 100 ? 'full' : pct >= 50 ? 'mid' : 'low';
                        items.push(`<div class="pl-item"><span class="pl-label">${Math.round(thresh)}ft</span><div class="pl-bar"><div class="pl-bar-fill ${cls}" style="width:${pct}%"></div></div><span class="pl-val" style="min-width:30px">${Math.round(agl)}</span></div>`);
                        break;
                    }
                }
            });
            return items.join('');
        }

        function lv(label, val, cls) {
            return `<div class="pl-item"><span class="pl-label">${label}</span><span class="pl-val ${cls || ''}">${val}</span></div>`;
        }

        // ── Toast ──
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        // ── Render ──
        function render() {
            const container = document.getElementById('phases');
            container.innerHTML = '';

            PHASES.forEach((phase, idx) => {
                if (idx > 0) {
                    const conn = document.createElement('div');
                    conn.className = 'phase-connector';
                    container.appendChild(conn);
                }

                const card = document.createElement('div');
                const typeClass = phase.type === 'ground' ? 'phase-ground' : phase.type === 'air' ? 'phase-air' : 'phase-ap';
                card.className = `phase-card ${typeClass}`;
                card.id = 'card-' + phase.id;

                // Header with hold button
                const header = document.createElement('div');
                header.className = 'phase-header';

                const dot = document.createElement('div');
                dot.className = 'active-dot';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'phase-name-text';
                nameSpan.textContent = phase.name;

                const condSpan = document.createElement('span');
                condSpan.className = 'condition';
                condSpan.textContent = phase.condition;

                // Hold/Go button (not for PREFLIGHT or BEFORE_ROLL — they're instant)
                const holdBtn = document.createElement('button');
                holdBtn.className = 'hold-btn' + (holds[phase.id] ? ' held' : '');
                holdBtn.textContent = holds[phase.id] ? 'HELD' : 'HOLD';
                holdBtn.id = 'hold-' + phase.id;
                holdBtn.addEventListener('click', function() {
                    holds[phase.id] = !holds[phase.id];
                    this.classList.toggle('held');
                    this.textContent = holds[phase.id] ? 'HELD' : 'HOLD';
                    saveHolds();
                    showToast(holds[phase.id] ? phase.name + ' HELD' : phase.name + ' RELEASED');
                });

                header.appendChild(dot);
                header.appendChild(nameSpan);
                header.appendChild(condSpan);
                header.appendChild(holdBtn);
                card.appendChild(header);

                // Body
                const body = document.createElement('div');
                body.className = 'phase-body';

                // Live readout
                const liveDiv = document.createElement('div');
                liveDiv.className = 'phase-live';
                liveDiv.id = 'live-' + phase.id;
                body.appendChild(liveDiv);

                // Inputs
                if (phase.inputs.length > 0) {
                    const grid = document.createElement('div');
                    grid.className = 'inputs-grid';
                    phase.inputs.forEach(input => {
                        const group = document.createElement('div');
                        group.className = 'input-group';
                        const label = document.createElement('label');
                        label.textContent = input.label;
                        const inp = document.createElement('input');
                        inp.type = 'number';
                        inp.id = 'input-' + input.key;
                        inp.value = values[input.key] ?? input.default;
                        inp.step = Math.abs(input.default) >= 10 ? 1 : 0.5;
                        inp.addEventListener('input', function() {
                            const v = parseFloat(this.value);
                            if (!isNaN(v)) { values[input.key] = v; saveValues(); }
                        });
                        const unit = document.createElement('div');
                        unit.className = 'unit';
                        unit.textContent = input.unit;
                        group.appendChild(label);
                        group.appendChild(inp);
                        group.appendChild(unit);
                        grid.appendChild(group);
                    });
                    body.appendChild(grid);
                } else {
                    const ni = document.createElement('div');
                    ni.className = 'no-inputs';
                    ni.textContent = 'No tunable values';
                    body.appendChild(ni);
                }

                // Checklist
                if (phase.checklist.length > 0) {
                    const cl = document.createElement('div');
                    cl.className = 'checklist';
                    phase.checklist.forEach((item, ci) => {
                        const div = document.createElement('div');
                        div.className = 'checklist-item';
                        div.id = `cl-${phase.id}-${ci}`;
                        div.textContent = item;
                        cl.appendChild(div);
                    });
                    body.appendChild(cl);
                }

                card.appendChild(body);
                container.appendChild(card);
            });

            updateActivePhase();
        }

        // ── Control buttons (AI toggle, Controls, FPL) ──
        function sendTunerCommand(cmd) {
            if (channel) channel.postMessage({ type: 'tuner-command', command: cmd });
        }
        function updateControlButtons() {
            const aiBtn = document.getElementById('ctrl-ai');
            const ctrlBtn = document.getElementById('ctrl-controls');
            if (aiBtn) {
                aiBtn.textContent = aiEnabled ? 'ON' : 'OFF';
                aiBtn.classList.toggle('on', aiEnabled);
            }
            if (ctrlBtn) {
                ctrlBtn.classList.toggle('on', aiControls);
            }
            const fplBtn = document.getElementById('ctrl-fpl');
            if (fplBtn) {
                fplBtn.classList.toggle('on', fplLoaded);
            }
        }
        document.getElementById('ctrl-ai').addEventListener('click', function() {
            sendTunerCommand('toggle-ai');
        });
        document.getElementById('ctrl-controls').addEventListener('click', function() {
            sendTunerCommand('toggle-controls');
        });
        document.getElementById('ctrl-fpl').addEventListener('click', function() {
            sendTunerCommand('import-fpl');
            showToast('SimBrief import requested');
        });

        // ── Buttons ──
        document.getElementById('btn-reset').addEventListener('click', function() {
            values = { ...DEFAULTS };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
            if (channel) channel.postMessage({ type: 'takeoff-tuning', values, timestamp: Date.now() });
            render();
            showToast('Reset to defaults');
        });

        document.getElementById('btn-copy').addEventListener('click', function() {
            const combined = { tuning: values, holds };
            const json = JSON.stringify(combined, null, 2);
            navigator.clipboard.writeText(json).then(() => showToast('Copied to clipboard'))
                .catch(() => { showToast('Copied to clipboard'); });
        });

        document.getElementById('btn-release-all').addEventListener('click', function() {
            holds = {};
            saveHolds();
            document.querySelectorAll('.hold-btn.held').forEach(btn => {
                btn.classList.remove('held');
                btn.textContent = 'HOLD';
            });
            showToast('All holds released');
        });

        render();
    })();
    </script>
</body>
</html>
