var garminsdk = (function (exports, msfssdk) {
    'use strict';

    /// <reference types="msfstypes/JS/simvar" />
    /**
     * A director that handles OBS Lateral Navigation.
     */
    class GarminObsDirector {
        /**
         * Creates an instance of the GPS OBS Director.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            this.bus = bus;
            this.geoPointCache = [new msfssdk.GeoPoint(0, 0)];
            this.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];
            this.obsSetting = 0;
            this.obsActive = false;
            this.dtk = undefined;
            this.xtk = undefined;
            this.legIndex = 0;
            this.leg = null;
            this.currentBankRef = 0;
            this.bankServo = new msfssdk.LinearServo(10);
            this.planePos = new msfssdk.GeoPoint(0, 0);
            this.groundTrack = 0;
            this.obsFix = msfssdk.GeoPointSubject.create(new msfssdk.GeoPoint(0, 0));
            this.obsMagVar = this.obsFix.map(fix => msfssdk.MagVar.get(fix));
            this.isTracking = false;
            this.needSubLNavData = false;
            this.lnavData = msfssdk.ObjectSubject.create({
                dtk: 0,
                xtk: 0,
                isTracking: false,
                legIndex: 0,
                transitionMode: msfssdk.LNavTransitionMode.None,
                vectorIndex: 0,
                courseToSteer: 0,
                isSuspended: true,
                alongLegDistance: 0,
                legDistanceRemaining: 0,
                alongVectorDistance: 0,
                vectorDistanceRemaining: 0
            });
            this.lnavDataHandler = (obj, key, value) => {
                switch (key) {
                    case 'dtk':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.DTK, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'xtk':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.XTK, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'isTracking':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.IsTracking, msfssdk.SimVarValueType.Bool, value);
                        break;
                    case 'legIndex':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.TrackedLegIndex, msfssdk.SimVarValueType.Number, value);
                        break;
                    case 'transitionMode':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.TransitionMode, msfssdk.SimVarValueType.Number, value);
                        break;
                    case 'vectorIndex':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.TrackedVectorIndex, msfssdk.SimVarValueType.Number, value);
                        break;
                    case 'courseToSteer':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.CourseToSteer, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'isSuspended':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.IsSuspended, msfssdk.SimVarValueType.Bool, value);
                        break;
                    case 'alongLegDistance':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.LegDistanceAlong, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'legDistanceRemaining':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.LegDistanceRemaining, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'alongVectorDistance':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.VectorDistanceAlong, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'vectorDistanceRemaining':
                        SimVar.SetSimVarValue(msfssdk.LNavVars.VectorDistanceRemaining, msfssdk.SimVarValueType.NM, value);
                        break;
                }
            };
            const sub = bus.getSubscriber();
            const adjustCourseSub = sub.on('hEvent').handle((e) => {
                if (e === 'AS1000_PFD_CRS_INC' || e === 'AS1000_MFD_CRS_INC') {
                    this.incrementObs(true);
                }
                else if (e === 'AS1000_PFD_CRS_DEC' || e === 'AS1000_MFD_CRS_DEC') {
                    this.incrementObs(false);
                }
            }, true);
            sub.on('cdi_select').handle(source => {
                if (source.type === msfssdk.NavSourceType.Gps) {
                    adjustCourseSub.resume();
                }
                else {
                    adjustCourseSub.pause();
                }
            });
            sub.on('gps_obs_active').whenChanged().handle((state) => {
                var _a;
                this.obsActive = state;
                if (this.obsActive) {
                    const calc = (_a = this.leg) === null || _a === void 0 ? void 0 : _a.calculated;
                    let courseMag = undefined;
                    if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                        this.obsFix.set(calc.endLat, calc.endLon);
                        const courseTrue = msfssdk.FlightPathUtils.getLegFinalCourse(calc);
                        if (courseTrue !== undefined) {
                            courseMag = msfssdk.MagVar.trueToMagnetic(courseTrue, this.obsMagVar.get());
                        }
                    }
                    if (courseMag !== undefined) {
                        this.obsSetting = courseMag;
                    }
                    else if (this.obsSetting < 0 || this.obsSetting > 360) {
                        this.obsSetting = 0;
                    }
                    SimVar.SetSimVarValue('K:GPS_OBS_SET', msfssdk.SimVarValueType.Degree, this.obsSetting);
                }
                else {
                    this.deactivate();
                }
            });
            sub.on('lnav_is_suspended').whenChanged().handle(isSuspended => {
                if (this.obsActive && !isSuspended) {
                    SimVar.SetSimVarValue('K:GPS_OBS_OFF', 'number', 0);
                }
            });
            sub.on('gps_obs_value').whenChanged().handle((value) => {
                this.obsSetting = value;
            });
            sub.on('track_deg_magnetic').whenChanged().handle((v) => {
                this.groundTrack = v;
            });
            sub.on('gps-position').whenChanged().handle((v) => {
                this.planePos.set(v.lat, v.long);
            });
            this.state = msfssdk.DirectorState.Inactive;
        }
        /** @inheritdoc */
        activate() {
            this.state = msfssdk.DirectorState.Active;
            if (this.onActivate !== undefined) {
                this.onActivate();
            }
        }
        /** @inheritdoc */
        arm() {
            this.state = msfssdk.DirectorState.Armed;
            if (this.onArm !== undefined) {
                this.onArm();
            }
        }
        /** @inheritdoc */
        deactivate() {
            this.state = msfssdk.DirectorState.Inactive;
            if (this.onDeactivate !== undefined) {
                this.onDeactivate();
            }
        }
        /** @inheritdoc */
        setLeg(index, leg) {
            this.legIndex = index;
            this.leg = leg;
        }
        /** @inheritdoc */
        startTracking() {
            if (this.isTracking) {
                return;
            }
            this.needSubLNavData = true;
            this.isTracking = true;
        }
        /** @inheritdoc */
        stopTracking() {
            if (!this.isTracking) {
                return;
            }
            this.lnavData.unsub(this.lnavDataHandler);
            this.needSubLNavData = false;
            this.isTracking = false;
            SimVar.SetSimVarValue('K:GPS_OBS_OFF', msfssdk.SimVarValueType.Number, 0);
        }
        /**
         * Increments or Decrements the OBS Setting for GPS if in GPS OBS MODE.
         * @param increment is whether to increment (or decrement) the value.
         */
        incrementObs(increment) {
            if (this.obsActive) {
                if (increment) {
                    SimVar.SetSimVarValue('K:GPS_OBS_INC', msfssdk.SimVarValueType.Number, 0);
                }
                else {
                    SimVar.SetSimVarValue('K:GPS_OBS_DEC', msfssdk.SimVarValueType.Number, 0);
                }
            }
        }
        /**
         * Updates the lateral director.
         */
        update() {
            this.lnavData.set('legIndex', this.legIndex);
            if (this.isTracking) {
                this.calculateTracking();
            }
            if (this.dtk === undefined || this.xtk === undefined) {
                SimVar.SetSimVarValue('K:GPS_OBS_OFF', msfssdk.SimVarValueType.Number, 0);
            }
            if (this.state === msfssdk.DirectorState.Active) {
                this.navigateFlightPath();
            }
            if (this.needSubLNavData) {
                this.lnavData.sub(this.lnavDataHandler, true);
                this.needSubLNavData = false;
            }
        }
        /**
         * Gets the current obs xtk.
         */
        calculateTracking() {
            var _a, _b, _c, _d, _e, _f;
            let distanceRemaining = 0;
            if (((_b = (_a = this.leg) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endLat) !== undefined && ((_d = (_c = this.leg) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.endLon) !== undefined) {
                const end = this.geoPointCache[0].set(this.leg.calculated.endLat, this.leg.calculated.endLon);
                this.obsFix.set(end);
                const obsTrue = msfssdk.MagVar.magneticToTrue(this.obsSetting, this.obsMagVar.get());
                const path = this.geoCircleCache[0].setAsGreatCircle(end, obsTrue);
                this.dtk = path.bearingAt(this.planePos, Math.PI);
                this.xtk = msfssdk.UnitType.GA_RADIAN.convertTo(path.distance(this.planePos), msfssdk.UnitType.NMILE);
                const angleRemaining = (path.angleAlong(this.planePos, end, Math.PI) + Math.PI) % msfssdk.MathUtils.TWO_PI - Math.PI;
                distanceRemaining = msfssdk.UnitType.GA_RADIAN.convertTo(angleRemaining, msfssdk.UnitType.NMILE);
            }
            else {
                this.dtk = undefined;
                this.xtk = undefined;
            }
            this.lnavData.set('isTracking', this.dtk !== undefined && this.xtk !== undefined);
            this.lnavData.set('dtk', (_e = this.dtk) !== null && _e !== void 0 ? _e : 0);
            this.lnavData.set('xtk', (_f = this.xtk) !== null && _f !== void 0 ? _f : 0);
            this.lnavData.set('legDistanceRemaining', distanceRemaining);
            this.lnavData.set('vectorDistanceRemaining', distanceRemaining);
        }
        /**
         * Navigates the provided leg flight path.
         */
        navigateFlightPath() {
            if (this.xtk === undefined || this.dtk === undefined) {
                return;
            }
            const absInterceptAngle = Math.min(Math.pow(Math.abs(this.xtk) * 20, 1.35) + (Math.abs(this.xtk) * 50), 45);
            const interceptAngle = this.xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
            const courseToSteer = msfssdk.NavMath.normalizeHeading(this.dtk + interceptAngle);
            const bankAngle = this.desiredBank(courseToSteer, this.xtk);
            if (this.state === msfssdk.DirectorState.Active) {
                this.setBank(bankAngle);
            }
            this.lnavData.set('courseToSteer', courseToSteer);
        }
        /**
         * Tries to activate when armed.
         * @returns whether OBS can activate
         */
        canActivate() {
            if (this.xtk !== undefined && Math.abs(this.xtk) < 1) {
                return true;
            }
            return false;
        }
        /**
         * Gets a desired bank from a desired track.
         * @param desiredTrack The desired track.
         * @param xtk The cross track.
         * @returns The desired bank angle.
         */
        desiredBank(desiredTrack, xtk) {
            const turnDirection = msfssdk.NavMath.getTurnDirection(this.groundTrack, desiredTrack);
            const headingDiff = Math.abs(msfssdk.NavMath.diffAngle(this.groundTrack, desiredTrack));
            let baseBank = Math.min(1.25 * headingDiff, 25);
            if (baseBank <= 2.5) {
                baseBank = msfssdk.NavMath.clamp(xtk * 100, -2.5, 2.5);
            }
            else {
                baseBank *= (turnDirection === 'left' ? 1 : -1);
            }
            return baseBank;
        }
        /**
         * Sets the desired AP bank angle.
         * @param bankAngle The desired AP bank angle.
         */
        setBank(bankAngle) {
            if (isFinite(bankAngle)) {
                this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
                SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
            }
        }
    }

    /**
     * A Garmin nav-to-nav manager.
     */
    class GarminNavToNavManager {
        /**
         * Creates an instance of the LateralDirector.
         * @param bus The event bus to use with this instance.
         * @param flightPlanner The flight planner.
         * @param apValues are the ap state values.
         */
        constructor(bus, flightPlanner, apValues) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.apValues = apValues;
            this.onTransferred = () => { };
            this.currentHeading = 0;
            this.approachFrequency = undefined;
            this.nav1Frequency = 0;
            this.nav2Frequency = 0;
            this.isSourceChanging = false;
            /** Index of nav radio that has a localizer and frequency matches loaded approach. */
            this.canArmIndex = 0;
            this.navToNavCompleted = false;
            this.lnavDataCurrentLegIndex = -1;
            this.planePos = new msfssdk.GeoPoint(0, 0);
            /**
             * Callback to handle the nav source changed event when received.
             * @param e is the NavSourceId event
             */
            this.handleNavToNavSourceChanged = (e) => {
                if (e.type === msfssdk.NavSourceType.Nav && e.index === this.canArmIndex) {
                    this.onTransferred();
                    this.isSourceChanging = false;
                    if (this.navToNavCdiConsumer !== undefined) {
                        this.navToNavCdiConsumer.off(this.handleNavToNavSourceChanged);
                        this.navToNavCdiConsumer = undefined;
                        this.navToNavCompleted = true;
                        return;
                    }
                }
            };
            this.monitorEvents();
        }
        /** @inheritdoc */
        canLocArm() {
            return this.canArmIndex > 0;
        }
        /** @inheritdoc */
        canLocActivate() {
            if (this.canArmIndex < 1) {
                return false;
            }
            const cdi = this.canArmIndex === 1 ? this.nav1Cdi : this.nav2Cdi;
            const loc = this.canArmIndex === 1 ? this.nav1Localizer : this.nav2Localizer;
            if (cdi && cdi.deviation !== null && Math.abs(cdi.deviation) < 127 && (loc === null || loc === void 0 ? void 0 : loc.course)) {
                const dtk = loc && loc.isValid && loc.course ? loc.course * Avionics.Utils.RAD2DEG : undefined;
                if (dtk === null || dtk === undefined) {
                    return false;
                }
                const headingDiff = msfssdk.NavMath.diffAngle(this.currentHeading, dtk);
                if (cdi.deviation > 0 && cdi.deviation < 65 && headingDiff < 0 && headingDiff > -90) {
                    return true;
                }
                else if (cdi.deviation < 0 && cdi.deviation > -65 && headingDiff > 0 && headingDiff < 90) {
                    return true;
                }
                else if (Math.abs(cdi.deviation) < 35 && Math.abs(headingDiff) < 20) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Updates the canArmIndex after inputs from the event bus or changes in the approach frequency.
         */
        updateState() {
            if (this.approachFrequency !== undefined && this.apValues.approachIsActive.get()) {
                const apprFreq = Math.round(this.approachFrequency.freqMHz * 100) / 100;
                if (apprFreq > 107) {
                    if (apprFreq == this.nav1Frequency && this.nav1Localizer && this.nav1Localizer.isValid) {
                        this.canArmIndex = 1;
                    }
                    else if (apprFreq == this.nav2Frequency && this.nav2Localizer && this.nav2Localizer.isValid) {
                        this.canArmIndex = 2;
                    }
                    else {
                        this.canArmIndex = 0;
                    }
                }
                else {
                    this.canArmIndex = 0;
                }
            }
            else {
                this.canArmIndex = 0;
            }
        }
        /**
         * Updates the nav 1 and nav 2 frequency from the bus.
         * @param radioState A radiostate event.
         */
        updateRadioState(radioState) {
            if (radioState.radioType === msfssdk.RadioType.Nav) {
                switch (radioState.index) {
                    case 1:
                        this.nav1Frequency = Math.round(radioState.activeFrequency * 100) / 100;
                        break;
                    case 2:
                        this.nav2Frequency = Math.round(radioState.activeFrequency * 100) / 100;
                        break;
                }
                this.updateState();
            }
        }
        /**
         * Tries to auto switch the source if criteria are met.
         */
        tryAutoSwitchSource() {
            var _a, _b, _c;
            const plan = this.flightPlanner.hasActiveFlightPlan() && this.flightPlanner.getActiveFlightPlan();
            const currentLeg = plan && this.lnavDataCurrentLegIndex >= 0 && this.lnavDataCurrentLegIndex < plan.length ? plan.getLeg(this.lnavDataCurrentLegIndex) : undefined;
            if (!this.navToNavCompleted
                && !this.isSourceChanging
                && ((_a = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined
                && ((_b = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                const fafIsActive = (currentLeg.leg.fixTypeFlags & msfssdk.FixTypeFlags.FAF) !== 0;
                const fafDistance = msfssdk.UnitType.GA_RADIAN.convertTo(this.planePos.distance(currentLeg.calculated.endLat, currentLeg.calculated.endLon), msfssdk.UnitType.NMILE);
                if (fafIsActive && fafDistance < 15 && this.canArmIndex > 0 && this.canLocActivate() && ((_c = this.activeSource) === null || _c === void 0 ? void 0 : _c.type) === msfssdk.NavSourceType.Gps) {
                    this.changeSource();
                    this.navToNavCdiConsumer = this.bus.getSubscriber().on('cdi_select');
                    this.navToNavCdiConsumer.handle(this.handleNavToNavSourceChanged);
                }
            }
        }
        /**
         * Method to set the HSI/NAV Source to the Can Arm Index.
         */
        changeSource() {
            const controlPublisher = this.bus.getPublisher();
            const navSource = {
                type: msfssdk.NavSourceType.Nav,
                index: this.canArmIndex
            };
            this.isSourceChanging = true;
            controlPublisher.pub('cdi_src_set', navSource, true);
        }
        /**
         * Method to monitor nav events to keep track of NAV related data needed for guidance.
         */
        monitorEvents() {
            const sub = this.bus.getSubscriber();
            sub.on('set_radio_state').handle((state) => {
                this.updateRadioState(state);
            });
            sub.on('set_frequency').handle((frequency) => {
                if (frequency.bank == msfssdk.FrequencyBank.Active && frequency.radio.radioType === msfssdk.RadioType.Nav) {
                    switch (frequency.radio.index) {
                        case 1:
                            this.nav1Frequency = Math.round(frequency.frequency * 100) / 100;
                            break;
                        case 2:
                            this.nav2Frequency = Math.round(frequency.frequency * 100) / 100;
                    }
                    this.updateState();
                }
            });
            sub.on('nav_radio_localizer_1').handle((loc) => {
                this.nav1Localizer = loc;
                this.updateState();
            });
            sub.on('nav_radio_localizer_2').handle((loc) => {
                this.nav2Localizer = loc;
                this.updateState();
            });
            sub.on('nav_radio_cdi_1').handle((cdi) => {
                this.nav1Cdi = cdi;
            });
            sub.on('nav_radio_cdi_2').handle((cdi) => {
                this.nav2Cdi = cdi;
            });
            sub.on('cdi_select').handle((source) => this.activeSource = source);
            sub.on('hdg_deg').withPrecision(0).handle((h) => {
                this.currentHeading = h;
            });
            sub.on('gps-position').handle(lla => { this.planePos.set(lla.lat, lla.long); });
            sub.on('approach_freq_set').handle((v) => {
                this.approachFrequency = v;
                this.navToNavCompleted = false;
                this.updateState();
            });
            sub.on('lnav_tracked_leg_index').handle(index => {
                this.lnavDataCurrentLegIndex = index;
            });
            sub.on('realTime').atFrequency(1).handle(() => {
                if (!this.navToNavCompleted && !this.isSourceChanging && this.canArmIndex > 0) {
                    this.tryAutoSwitchSource();
                }
            });
            this.apValues.approachIsActive.sub((v) => {
                this.updateState();
                if (v) {
                    this.navToNavCompleted = false;
                }
            });
        }
    }

    /**
     * A Garmin VNAV Manager.
     */
    class GarminVNavManager {
        /**
         * Creates an instance of the Garmin VNAV Manager.
         * @param bus The event bus to use with this instance.
         * @param flightPlanner The flight planner to use with this instance.
         * @param calculator The VNAV path calculator to use with this instance.
         * @param apValues are the autopilot ap values.
         * @param primaryPlanIndex The index of the flightplan to follow vertical guidance from.
         * @param hasNonPathVnav Whether this VNav Director provides non-path climb and descent restriction adherence (false by default).
         * @param guidanceEndsAtFaf Whether this VNav Director terminates vertical guidance at the FAF (true by default).
         */
        constructor(bus, flightPlanner, calculator, apValues, primaryPlanIndex, hasNonPathVnav = false, guidanceEndsAtFaf = true) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.calculator = calculator;
            this.apValues = apValues;
            this.primaryPlanIndex = primaryPlanIndex;
            this.hasNonPathVnav = hasNonPathVnav;
            this.guidanceEndsAtFaf = guidanceEndsAtFaf;
            this.state = msfssdk.VNavState.Disabled;
            this.pathMode = msfssdk.VNavPathMode.None;
            this.gpAvailable = false;
            this.planePos = new msfssdk.GeoPoint(0, 0);
            this.currentAltitude = 0;
            this.currentGpsAltitude = 0;
            this.preselectedAltitude = 0;
            this.currentGroundSpeed = 0;
            this.currentVS = 0;
            this.vnavUnavailable = msfssdk.Subject.create(false);
            this.cdiSource = { type: msfssdk.NavSourceType.Nav, index: 0 };
            this.capturedAltitude = 0;
            this.isAltCaptured = false;
            this.awaitingAltCap = -1;
            this.awaitingRearm = -1;
            /** The leg distance from the current leg to the constraint leg, not including the distance from ppos to the current leg target. */
            this.constraintDistance = -1;
            this.vnavNextConstraintAltitude = msfssdk.Subject.create(undefined);
            /** The active leg altitude from VNAV in Meters. */
            this.vnavNextLegTargetAltitude = msfssdk.Subject.create(undefined);
            this.lpvDeviation = msfssdk.Subject.create(0);
            this.glidepathCalculator = new msfssdk.GlidePathCalculator(this.bus, this.flightPlanner, this.primaryPlanIndex);
            this.todBodDetails = {
                todLegIndex: -1,
                bodLegIndex: -1,
                todLegDistance: 0,
                distanceFromTod: 0,
                distanceFromBod: 0,
                currentConstraintLegIndex: -1
            };
            this.todBodDetailsSub = msfssdk.ObjectSubject.create(Object.assign({}, this.todBodDetails));
            const lnav = this.bus.getSubscriber();
            this.lnavLegIndex = msfssdk.ConsumerSubject.create(lnav.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceAlong = msfssdk.ConsumerSubject.create(lnav.on('lnav_leg_distance_along'), 0);
            this.bus.getSubscriber().on('ap_altitude_selected').handle(selected => this.preselectedAltitude = selected);
            this.bus.getSubscriber().on('indicated_alt').whenChangedBy(1).handle(alt => this.currentAltitude = alt);
            this.bus.getSubscriber().on('vertical_speed').whenChangedBy(1).handle(vs => this.currentVS = vs);
            const gnss = this.bus.getSubscriber();
            gnss.on('gps-position').handle(lla => {
                this.planePos.set(lla.lat, lla.long);
                this.currentGpsAltitude = msfssdk.UnitType.METER.convertTo(lla.alt, msfssdk.UnitType.FOOT);
            });
            gnss.on('ground_speed').handle(gs => this.currentGroundSpeed = gs);
            this.bus.getSubscriber().on('gp_available').handle(available => this.gpAvailable = available);
            this.bus.getSubscriber().on('vnav_set_state').handle(d => {
                if (d) {
                    this.setState(msfssdk.VNavState.Enabled_Inactive);
                }
                else {
                    this.setState(msfssdk.VNavState.Disabled);
                }
            });
            this.apValues.verticalActive.sub(mode => {
                if (mode === msfssdk.APVerticalModes.ALT && this.awaitingAltCap !== -1) {
                    this.awaitingRearm = this.awaitingAltCap;
                    this.awaitingAltCap = -1;
                }
                if (this.awaitingRearm > -1 && mode !== msfssdk.APVerticalModes.ALT && mode !== msfssdk.APVerticalModes.CAP) {
                    this.awaitingRearm = -1;
                    this.awaitingAltCap = -1;
                }
                if (mode === msfssdk.APVerticalModes.GS || mode === msfssdk.APVerticalModes.GP) {
                    this.tryDeactivate(msfssdk.APVerticalModes.NONE);
                }
            });
            this.apValues.lateralActive.sub(mode => {
                if (mode === msfssdk.APLateralModes.LOC && this.pathMode === msfssdk.VNavPathMode.PathArmed) {
                    this.awaitingAltCap = -1;
                    this.awaitingRearm = -1;
                    this.tryDeactivate(msfssdk.APVerticalModes.NONE);
                }
            });
            this.vnavNextConstraintAltitude.sub((v) => {
                SimVar.SetSimVarValue(msfssdk.VNavVars.NextConstraintAltitude, msfssdk.SimVarValueType.Feet, v === undefined ? -1 : msfssdk.UnitType.METER.convertTo(v, msfssdk.UnitType.FOOT));
            });
            this.calculator.vnavCalculated.on((sender, data) => {
                if (data === this.primaryPlanIndex) {
                    this.bus.getPublisher().pub('vnav_path_calculated', data, true, false);
                }
            });
            const nav = this.bus.getSubscriber();
            nav.on('cdi_select').handle((src) => {
                this.cdiSource = src;
            });
            SimVar.SetSimVarValue(msfssdk.VNavVars.GPVerticalDeviation, msfssdk.SimVarValueType.Feet, Number.MAX_SAFE_INTEGER);
            SimVar.SetSimVarValue(msfssdk.VNavVars.PathMode, msfssdk.SimVarValueType.Number, msfssdk.VNavPathMode.None);
            this.todBodDetailsSub.sub(this.publishTODBODDetails.bind(this), true);
            this.vnavNextLegTargetAltitude.sub(v => {
                this.bus.getPublisher().pub('vnav_active_leg_alt', v !== null && v !== void 0 ? v : 0, true, false);
            });
            this.vnavUnavailable.sub(v => this.onVnavUnavailable(v));
            this.setState(msfssdk.VNavState.Enabled_Active);
        }
        /** @inheritdoc */
        setState(vnavState) {
            if (vnavState !== this.state) {
                this.state = vnavState;
                switch (this.state) {
                    case msfssdk.VNavState.Disabled:
                        this.pathMode = msfssdk.VNavPathMode.None;
                        this.awaitingAltCap = -1;
                        this.awaitingRearm = -1;
                        break;
                    case msfssdk.VNavState.Enabled_Active:
                        this.tryActivate();
                        break;
                    case msfssdk.VNavState.Enabled_Inactive:
                        this.tryDeactivate();
                        break;
                }
                SimVar.SetSimVarValue(msfssdk.VNavVars.VNAVState, msfssdk.SimVarValueType.Number, this.state);
            }
        }
        /** @inheritdoc */
        tryActivate() {
            if (this.state !== msfssdk.VNavState.Disabled && this.cdiSource.type === msfssdk.NavSourceType.Gps) {
                this.state = msfssdk.VNavState.Enabled_Active;
                SimVar.SetSimVarValue(msfssdk.VNavVars.VNAVState, msfssdk.SimVarValueType.Number, this.state);
                this.pathMode = msfssdk.VNavPathMode.None;
                this.awaitingAltCap = -1;
                this.awaitingRearm = -1;
            }
        }
        /** @inheritdoc */
        tryDeactivate(newMode) {
            if (this.state !== msfssdk.VNavState.Disabled) {
                if (this.state !== msfssdk.VNavState.Enabled_Inactive) {
                    this.state = msfssdk.VNavState.Enabled_Inactive;
                    SimVar.SetSimVarValue(msfssdk.VNavVars.VNAVState, msfssdk.SimVarValueType.Number, this.state);
                    if (this.pathMode !== msfssdk.VNavPathMode.None) {
                        this.disarmPath(newMode);
                    }
                    this.isAltCaptured = false;
                    if (this.awaitingAltCap === -1 && this.awaitingRearm === -1) {
                        SimVar.SetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool', false);
                    }
                }
            }
        }
        /** @inheritdoc */
        canVerticalModeActivate() {
            // Method not required for Garmin VNav Manager.
            return true;
        }
        /** @inheritdoc */
        onPathDirectorDeactivated() {
            // Method not required for Garmin VNav Manager.
        }
        /**
         * Method to call when VNAV Encounters a failed state.
         */
        failed() {
            if (this.pathMode === msfssdk.VNavPathMode.PathActive && !this.isAltCaptured) {
                this.apValues.capturedAltitude.set(this.currentAltitude);
            }
            this.tryDeactivate(msfssdk.APVerticalModes.CAP);
        }
        /**
         * Method called to delegate altitude capture to the Alt Cap Director.
         * @param newPathMode The new path mode to set on delegating.
         */
        onDelegateAltCap(newPathMode) {
            this.disarmPath(msfssdk.APVerticalModes.CAP);
            switch (newPathMode) {
                case msfssdk.VNavPathMode.PathArmed:
                    this.armPath();
                    break;
            }
        }
        /** Method called to arm Path Mode. */
        armPath() {
            if (this.awaitingAltCap < 0 && this.awaitingRearm < 0 && this.apValues.verticalActive.get() !== msfssdk.APVerticalModes.CAP) {
                if (this.pathMode !== msfssdk.VNavPathMode.PathArmed) {
                    this.pathMode = msfssdk.VNavPathMode.PathArmed;
                    SimVar.SetSimVarValue(msfssdk.VNavVars.PathMode, msfssdk.SimVarValueType.Number, this.pathMode);
                }
                if (this.pathMode === msfssdk.VNavPathMode.PathArmed) {
                    this.isAltCaptured = false;
                    this.armMode && this.armMode(msfssdk.APVerticalModes.PATH);
                }
                this.awaitingRearm = -1;
            }
        }
        /** Method called to activate Path Mode. */
        activatePath() {
            if (this.pathMode !== msfssdk.VNavPathMode.PathActive) {
                this.pathMode = msfssdk.VNavPathMode.PathActive;
                SimVar.SetSimVarValue(msfssdk.VNavVars.PathMode, msfssdk.SimVarValueType.Number, this.pathMode);
            }
            if (this.pathMode === msfssdk.VNavPathMode.PathActive) {
                this.activateMode && this.activateMode(msfssdk.APVerticalModes.PATH);
            }
        }
        /**
         * Method to call when VNAV needs to disarm the path, without deactivating VNAV entirely.
         * @param newMode is the vertical mode to set the Autopilot to if Path is currently active.
         */
        disarmPath(newMode = msfssdk.APVerticalModes.PITCH) {
            if (this.pathMode !== msfssdk.VNavPathMode.None) {
                if (this.pathMode === msfssdk.VNavPathMode.PathActive && newMode !== msfssdk.APVerticalModes.NONE) {
                    this.activateMode && this.activateMode(newMode);
                }
                if (this.pathMode === msfssdk.VNavPathMode.PathArmed) {
                    this.armMode && this.armMode(msfssdk.APVerticalModes.NONE);
                }
                this.pathMode = msfssdk.VNavPathMode.None;
                this.isAltCaptured = false;
                SimVar.SetSimVarValue(msfssdk.VNavVars.PathMode, msfssdk.SimVarValueType.Number, this.pathMode);
            }
        }
        /**
         * Updates the VNAV director.
         */
        update() {
            var _a;
            let alongLegDistance = -1;
            let gpManaged = false;
            let needResetTodBodVars = true;
            let activeLegAltitude = undefined;
            if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                const lateralPlan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                const verticalPlan = this.calculator.getVerticalFlightPlan(this.primaryPlanIndex);
                let desiredAltFeet = Number.POSITIVE_INFINITY;
                let targetAltitudeFeet;
                let verticalDeviation = Number.MAX_SAFE_INTEGER;
                let requiredVs = 0;
                alongLegDistance = msfssdk.UnitType.NMILE.convertTo(this.lnavLegDistanceAlong.get(), msfssdk.UnitType.METER);
                this.calculator.setCurrentAlongLegDistance(this.primaryPlanIndex, alongLegDistance);
                const currentLegIndex = this.lnavLegIndex.get();
                // const nextLegIndex = currentLegIndex + 1;
                // const nextLeg = nextLegIndex >= 0 && nextLegIndex < lateralPlan.length ? lateralPlan.getLeg(nextLegIndex) : undefined;
                if (currentLegIndex < lateralPlan.length && verticalPlan.constraints.length > 0 && currentLegIndex <= verticalPlan.constraints[0].index) {
                    const currentAltitudeMetric = msfssdk.UnitType.FOOT.convertTo(this.currentAltitude, msfssdk.UnitType.METER);
                    const currentVSMetric = msfssdk.UnitType.FPM.convertTo(this.currentVS, msfssdk.UnitType.MPM);
                    const todBodDetails = msfssdk.VNavUtils.getTodBodDetails(verticalPlan, lateralPlan.activeLateralLeg, alongLegDistance, currentAltitudeMetric, currentVSMetric, this.todBodDetails);
                    this.todBodDetailsSub.set('bodLegIndex', todBodDetails.bodLegIndex);
                    this.todBodDetailsSub.set('todLegIndex', todBodDetails.todLegIndex);
                    this.todBodDetailsSub.set('todLegDistance', todBodDetails.todLegDistance);
                    this.todBodDetailsSub.set('distanceFromBod', todBodDetails.distanceFromBod);
                    this.todBodDetailsSub.set('distanceFromTod', todBodDetails.distanceFromTod);
                    this.todBodDetailsSub.set('currentConstraintLegIndex', todBodDetails.currentConstraintLegIndex);
                    needResetTodBodVars = false;
                    this.vnavNextConstraintAltitude.set(this.calculator.getNextConstraintAltitude(this.primaryPlanIndex, lateralPlan.activeLateralLeg));
                    const constraintAltitude = this.calculator.getCurrentConstraintAltitude(this.primaryPlanIndex, lateralPlan.activeLateralLeg);
                    this.vnavUnavailable.set(this.vnavNextConstraintAltitude.get() !== constraintAltitude);
                    const simvarAltitudeSet = constraintAltitude !== undefined ? msfssdk.UnitType.METER.convertTo(constraintAltitude, msfssdk.UnitType.FOOT) : -1;
                    SimVar.SetSimVarValue(msfssdk.VNavVars.CurrentConstraintAltitude, msfssdk.SimVarValueType.Feet, simvarAltitudeSet);
                    const desiredAltitude = msfssdk.VNavUtils.getDesiredAltitude(verticalPlan, lateralPlan.activeLateralLeg, alongLegDistance);
                    desiredAltFeet = msfssdk.UnitType.METER.convertTo(desiredAltitude, msfssdk.UnitType.FOOT);
                    this.setConstraintDistance(lateralPlan, todBodDetails.currentConstraintLegIndex);
                    const currentLeg = currentLegIndex >= 0 && currentLegIndex < lateralPlan.length ? lateralPlan.getLeg(currentLegIndex) : undefined;
                    if (((_a = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) && constraintAltitude !== undefined) {
                        const distance = this.constraintDistance +
                            msfssdk.UnitType.METER.convertTo(currentLeg.calculated.distanceWithTransitions - alongLegDistance, msfssdk.UnitType.NMILE);
                        requiredVs = this.getRequiredVs(distance, constraintAltitude);
                    }
                }
                else {
                    this.failed();
                }
                if (lateralPlan.length > 0) {
                    const finalLeg = lateralPlan.getLeg(lateralPlan.length - 1);
                    const lpvDistance = this.manageGP(finalLeg, lateralPlan, alongLegDistance);
                    gpManaged = true;
                    verticalDeviation = desiredAltFeet - this.currentAltitude;
                    SimVar.SetSimVarValue(msfssdk.VNavVars.VerticalDeviation, msfssdk.SimVarValueType.Feet, verticalDeviation);
                    const targetAltitude = this.calculator.getTargetAltitude(this.primaryPlanIndex, lateralPlan.activeLateralLeg);
                    if (targetAltitude !== undefined) {
                        targetAltitudeFeet = msfssdk.UnitType.METER.convertTo(targetAltitude, msfssdk.UnitType.FOOT);
                        SimVar.SetSimVarValue(msfssdk.VNavVars.TargetAltitude, msfssdk.SimVarValueType.Feet, targetAltitudeFeet);
                    }
                    else {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.TargetAltitude, msfssdk.SimVarValueType.Feet, -1);
                    }
                    const fafLegIndex = verticalPlan.fafLegIndex;
                    if (this.apValues.verticalActive.get() === msfssdk.APVerticalModes.GP ||
                        (fafLegIndex !== undefined && this.apValues.approachHasGP.get() && this.state !== msfssdk.VNavState.Enabled_Active && lateralPlan.activeLateralLeg >= fafLegIndex)) {
                        requiredVs = this.getRequiredVs(msfssdk.UnitType.METER.convertTo(lpvDistance, msfssdk.UnitType.NMILE), this.glidepathCalculator.getRunwayAltitude(), this.currentGpsAltitude);
                    }
                    SimVar.SetSimVarValue(msfssdk.VNavVars.RequiredVS, msfssdk.SimVarValueType.FPM, requiredVs);
                    if (lateralPlan.activeLateralLeg === this.awaitingRearm && this.state === msfssdk.VNavState.Enabled_Active) {
                        this.awaitingRearm = -1;
                        this.armPath();
                    }
                    const verticalLeg = verticalPlan.constraints.length > 0 ? msfssdk.VNavUtils.getVerticalLegFromPlan(verticalPlan, lateralPlan.activeLateralLeg) : undefined;
                    if (this.state === msfssdk.VNavState.Enabled_Active && this.awaitingAltCap === -1 && this.awaitingRearm === -1) {
                        const flightPhase = this.calculator.getFlightPhase(this.primaryPlanIndex);
                        this.manageAltHold(targetAltitudeFeet, flightPhase);
                        this.trackVerticalPath(verticalPlan, lateralPlan, targetAltitudeFeet, verticalDeviation, flightPhase);
                    }
                    else if (lateralPlan.activeLateralLeg < lateralPlan.length && verticalLeg !== undefined) {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.FPA, msfssdk.SimVarValueType.Degree, verticalLeg.fpa);
                    }
                    else {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.FPA, msfssdk.SimVarValueType.Degree, 0);
                    }
                    activeLegAltitude = verticalLeg && verticalLeg.altitude ? Math.round(verticalLeg.altitude) : undefined;
                }
                else {
                    // TODO: remove this once we have a better way to get LPV state - does an LPV exist or not
                    SimVar.SetSimVarValue(msfssdk.VNavVars.GPDistance, msfssdk.SimVarValueType.Meters, Number.MAX_SAFE_INTEGER);
                    this.lpvDeviation.set(-1001);
                }
            }
            else {
                this.calculator.setCurrentAlongLegDistance(this.primaryPlanIndex, alongLegDistance);
                this.failed();
            }
            if (!gpManaged) {
                this.manageGP(undefined, undefined, alongLegDistance);
            }
            if (needResetTodBodVars) {
                this.todBodDetailsSub.set('bodLegIndex', -1);
                this.todBodDetailsSub.set('todLegIndex', -1);
                this.todBodDetailsSub.set('todLegDistance', 0);
                this.todBodDetailsSub.set('distanceFromBod', 0);
                this.todBodDetailsSub.set('distanceFromTod', 0);
                this.todBodDetailsSub.set('currentConstraintLegIndex', -1);
            }
            this.vnavNextLegTargetAltitude.set(activeLegAltitude);
        }
        /**
         * Tracks the vertical path.
         * @param verticalPlan The Vertical Flight Plan.
         * @param lateralPlan The Lateral Flight Plan.
         * @param targetAltitude The current VNAV target altitude, if any.
         * @param verticalDeviation The current vertical deviation.
         * @param flightPhase The current flight phase
         */
        trackVerticalPath(verticalPlan, lateralPlan, targetAltitude, verticalDeviation, flightPhase = msfssdk.VerticalFlightPhase.Descent) {
            if (targetAltitude === undefined) {
                targetAltitude = Number.NEGATIVE_INFINITY;
            }
            if (lateralPlan.activeLateralLeg >= lateralPlan.length) {
                this.isAltCaptured = false;
                this.failed();
                return;
            }
            if (this.vnavUnavailable.get()) {
                return;
            }
            const targetIsSelectedAltitude = this.preselectedAltitude > targetAltitude;
            targetAltitude = Math.max(targetAltitude, this.preselectedAltitude);
            const deviationFromTarget = targetAltitude - this.currentAltitude;
            const fpa = msfssdk.VNavUtils.getVerticalLegFromPlan(verticalPlan, lateralPlan.activeLateralLeg).fpa;
            SimVar.SetSimVarValue(msfssdk.VNavVars.FPA, msfssdk.SimVarValueType.Degree, fpa);
            if (this.pathMode === msfssdk.VNavPathMode.None && flightPhase === msfssdk.VerticalFlightPhase.Descent) {
                if (this.preselectedAltitude + 75 < this.currentAltitude) {
                    this.armPath();
                }
                else if (!this.hasNonPathVnav) {
                    this.tryDeactivate();
                }
            }
            if (!this.isAltCaptured && this.pathMode === msfssdk.VNavPathMode.PathActive && fpa === 0) {
                this.apValues.capturedAltitude.set(100 * Math.round(targetAltitude / 100));
                const fafAltitude = msfssdk.VNavUtils.getFafAltitude(verticalPlan);
                if (this.guidanceEndsAtFaf && fafAltitude !== undefined && msfssdk.UnitType.METER.convertTo(fafAltitude, msfssdk.UnitType.FOOT) === targetAltitude) {
                    this.onDelegateAltCap(msfssdk.VNavPathMode.None);
                    this.tryDeactivate();
                }
                else {
                    this.onDelegateAltCap(msfssdk.VNavPathMode.PathArmed);
                }
            }
            const destLegIndex = verticalPlan.destLegIndex;
            const fafLegIndex = verticalPlan.fafLegIndex;
            if ((destLegIndex !== undefined && lateralPlan.activeLateralLeg > destLegIndex) || fafLegIndex !== undefined && lateralPlan.activeLateralLeg > fafLegIndex) {
                this.tryDeactivate();
                return;
            }
            if (this.pathMode === msfssdk.VNavPathMode.PathArmed || this.pathMode == msfssdk.VNavPathMode.PathActive) {
                if (verticalDeviation <= 100 && verticalDeviation >= -50 && this.pathMode === msfssdk.VNavPathMode.PathArmed) {
                    if (Math.abs(deviationFromTarget) > 75 && (!this.isAltCaptured && fpa !== 0)) {
                        this.activatePath();
                    }
                }
                if (!this.isAltCaptured && Math.abs(deviationFromTarget) <= 250 && this.pathMode == msfssdk.VNavPathMode.PathActive) {
                    this.capturedAltitude = targetAltitude;
                    this.isAltCaptured = true;
                }
                if (this.isAltCaptured && this.pathMode === msfssdk.VNavPathMode.PathActive) {
                    const altCapDeviation = Math.abs(this.capturedAltitude - this.currentAltitude);
                    const captureActivationValue = Math.tan(msfssdk.UnitType.DEGREE.convertTo(fpa, msfssdk.UnitType.RADIAN)) * msfssdk.UnitType.NMILE.convertTo(this.currentGroundSpeed / 360, msfssdk.UnitType.FOOT);
                    if (altCapDeviation < Math.abs(captureActivationValue)) {
                        this.apValues.capturedAltitude.set(Math.round(this.capturedAltitude));
                        if (targetIsSelectedAltitude) {
                            this.onDelegateAltCap(msfssdk.VNavPathMode.None);
                        }
                        else if (msfssdk.VNavUtils.getIsPathEnd(verticalPlan, lateralPlan.activeLateralLeg)) {
                            this.tryDeactivate(msfssdk.APVerticalModes.CAP);
                        }
                        else {
                            this.awaitingAltCap = lateralPlan.activeLateralLeg + 1;
                            this.onDelegateAltCap(msfssdk.VNavPathMode.None);
                        }
                        return;
                    }
                }
                if (this.pathMode === msfssdk.VNavPathMode.PathActive) ;
                else if (this.hasNonPathVnav) {
                    const constraint = msfssdk.VNavUtils.getConstraintFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
                    if (constraint && !this.isAltCaptured) {
                        const constraintAltitudeFeet = msfssdk.UnitType.METER.convertTo(flightPhase === msfssdk.VerticalFlightPhase.Descent ? constraint.minAltitude : constraint.maxAltitude, msfssdk.UnitType.FOOT);
                        const nonPathTargetAlt = flightPhase === msfssdk.VerticalFlightPhase.Descent ? Math.max(constraintAltitudeFeet, this.apValues.selectedAltitude.get())
                            : Math.min(constraintAltitudeFeet, this.apValues.selectedAltitude.get());
                        const nonPathDeviation = nonPathTargetAlt - this.currentAltitude;
                        if (Math.abs(nonPathDeviation) <= 250) {
                            this.capturedAltitude = Math.round(nonPathTargetAlt);
                            this.apValues.capturedAltitude.set(this.capturedAltitude);
                            this.isAltCaptured = true;
                            this.onDelegateAltCap(msfssdk.VNavPathMode.PathArmed);
                        }
                    }
                }
            }
        }
        /**
         * Method to handle when VNAV becomes available or unavailable due to invalid vnav legs.
         * @param v Whether VNAV is currently unavailable.
         */
        onVnavUnavailable(v) {
            if (v) {
                this.bus.getPublisher().pub('vnav_availability', msfssdk.VNavAvailability.InvalidLegs, true, false);
                const lateralPlan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                const constraintAlt = this.calculator.getCurrentConstraintAltitude(this.primaryPlanIndex, lateralPlan.activeLateralLeg);
                const verticalPlan = this.calculator.getVerticalFlightPlan(this.primaryPlanIndex);
                if (!verticalPlan.fafLegIndex || lateralPlan.activeLateralLeg <= verticalPlan.fafLegIndex) {
                    this.bus.getPublisher().pub('vnav_availability', msfssdk.VNavAvailability.InvalidLegs, true, false);
                }
                if (this.pathMode === msfssdk.VNavPathMode.PathActive && constraintAlt !== undefined && Math.abs(this.currentAltitude - constraintAlt) < 300) {
                    this.apValues.capturedAltitude.set(100 * Math.round(constraintAlt / 100));
                    this.tryDeactivate(msfssdk.APVerticalModes.CAP);
                }
                else {
                    this.tryDeactivate();
                }
            }
            else {
                this.bus.getPublisher().pub('vnav_availability', msfssdk.VNavAvailability.Available, true, false);
            }
        }
        /**
         * Manages Altitude Hold Target.
         * @param targetAltitude The current VNAV target altitude, if any.
         * @param flightPhase The current vertical flight phase (defaults to descent).
         */
        manageAltHold(targetAltitude, flightPhase = msfssdk.VerticalFlightPhase.Descent) {
            if (targetAltitude !== undefined) {
                const targetAltFeet = targetAltitude;
                if (flightPhase === msfssdk.VerticalFlightPhase.Descent) {
                    if (this.preselectedAltitude >= targetAltFeet) {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.CaptureType, msfssdk.SimVarValueType.Number, msfssdk.VNavAltCaptureType.Selected);
                    }
                    else {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.CaptureType, msfssdk.SimVarValueType.Number, msfssdk.VNavAltCaptureType.VNAV);
                    }
                }
                else {
                    if (this.preselectedAltitude <= targetAltFeet) {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.CaptureType, msfssdk.SimVarValueType.Number, msfssdk.VNavAltCaptureType.Selected);
                    }
                    else {
                        SimVar.SetSimVarValue(msfssdk.VNavVars.CaptureType, msfssdk.SimVarValueType.Number, msfssdk.VNavAltCaptureType.VNAV);
                    }
                }
            }
            else {
                SimVar.SetSimVarValue(msfssdk.VNavVars.TargetAltitude, msfssdk.SimVarValueType.Feet, -1);
                SimVar.SetSimVarValue(msfssdk.VNavVars.CaptureType, msfssdk.SimVarValueType.Number, msfssdk.VNavAltCaptureType.None);
            }
        }
        /**
         * Manages the GP State and sets required data for GP guidance.
         * @param finalLeg The LegDefinition for the last flight lateralPlan leg.
         * @param lateralPlan The FlightPlan.
         * @param alongLegDistance The Along Leg Distance
         * @returns The LPV Distance
         */
        manageGP(finalLeg, lateralPlan, alongLegDistance) {
            let lpvDeviation = -1001;
            let lpvDistance = -1;
            let gpCalculated = false;
            if (lateralPlan && this.gpAvailable && (finalLeg === null || finalLeg === void 0 ? void 0 : finalLeg.calculated) !== undefined) {
                lpvDistance = this.glidepathCalculator.getGlidepathDistance(lateralPlan.activeLateralLeg, alongLegDistance);
                const desiredLPVAltitude = this.glidepathCalculator.getDesiredGlidepathAltitude(lpvDistance);
                const desiredLPVAltitudeFeet = msfssdk.UnitType.METER.convertTo(desiredLPVAltitude, msfssdk.UnitType.FOOT);
                lpvDeviation = msfssdk.MathUtils.clamp(desiredLPVAltitudeFeet - this.currentGpsAltitude, -1000, 1000);
                gpCalculated = true;
            }
            SimVar.SetSimVarValue(msfssdk.VNavVars.GPVerticalDeviation, msfssdk.SimVarValueType.Feet, lpvDeviation);
            SimVar.SetSimVarValue(msfssdk.VNavVars.GPDistance, msfssdk.SimVarValueType.Meters, lpvDistance);
            SimVar.SetSimVarValue(msfssdk.VNavVars.GPFpa, msfssdk.SimVarValueType.Degree, this.glidepathCalculator.glidepathFpa);
            this.apValues.approachHasGP.set(gpCalculated);
            return lpvDistance;
        }
        /**
         * Gets the current required vertical speed.
         * @param distance is the distance to the constraint.
         * @param targetAltitude is the target altitude for the constraint.
         * @param currentAltitude is the current altitude (defaults to baro alt)
         * @returns the required vs in fpm.
         */
        getRequiredVs(distance, targetAltitude, currentAltitude = this.currentAltitude) {
            if (targetAltitude > 0) {
                return msfssdk.VNavUtils.getRequiredVs(distance, targetAltitude, currentAltitude, this.currentGroundSpeed);
            }
            return 0;
        }
        /**
         * Sets the leg distance from the current leg to the constraint leg, not include the distance to the current active leg.
         * @param lateralPlan is the flight lateralPlan.
         * @param constraintLegIndex is the leg index of the current constraint.
         */
        setConstraintDistance(lateralPlan, constraintLegIndex) {
            var _a, _b;
            if (constraintLegIndex !== undefined && constraintLegIndex > -1) {
                const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
                const constraintLeg = lateralPlan.getLeg(constraintLegIndex);
                if (((_a = constraintLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions) && ((_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions)) {
                    const currentLegCumulativeNM = msfssdk.UnitType.METER.convertTo(currentLeg.calculated.cumulativeDistanceWithTransitions, msfssdk.UnitType.NMILE);
                    const bodCumulativeNM = msfssdk.UnitType.METER.convertTo(constraintLeg.calculated.cumulativeDistanceWithTransitions, msfssdk.UnitType.NMILE);
                    this.constraintDistance = (bodCumulativeNM - currentLegCumulativeNM);
                    return;
                }
            }
            this.constraintDistance = -1;
        }
        /**
         * Publishes TOD/BOD details to simvars.
         * @param details The TOD/BOD details object.
         * @param key The key to publish.
         * @param value The value to publish.
         */
        publishTODBODDetails(details, key, value) {
            switch (key) {
                case 'bodLegIndex':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.BODLegIndex, msfssdk.SimVarValueType.Number, value);
                    break;
                case 'todLegIndex':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.TODLegIndex, msfssdk.SimVarValueType.Number, value);
                    break;
                case 'todLegDistance':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.TODDistanceInLeg, msfssdk.SimVarValueType.Meters, value);
                    break;
                case 'distanceFromBod':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.BODDistance, msfssdk.SimVarValueType.Meters, value);
                    break;
                case 'distanceFromTod':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.TODDistance, msfssdk.SimVarValueType.Meters, value);
                    break;
                case 'currentConstraintLegIndex':
                    SimVar.SetSimVarValue(msfssdk.VNavVars.CurrentConstraintLegIndex, msfssdk.SimVarValueType.Number, value);
                    break;
            }
        }
    }

    /**
     * A Garmin Autopilot Configuration.
     */
    class GarminAPConfig {
        /**
         * Instantiates the AP Config for the Autopilot.
         * @param bus is an instance of the Event Bus.
         * @param flightPlanner is an instance of the flight planner.
         * @param verticalPathCalculator The instance of the vertical path calculator to use for the vnav director.
         */
        constructor(bus, flightPlanner, verticalPathCalculator) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.verticalPathCalculator = verticalPathCalculator;
            this.defaultLateralMode = msfssdk.APLateralModes.ROLL;
            this.defaultVerticalMode = msfssdk.APVerticalModes.PITCH;
            this.defaultMaxBankAngle = 25; // Note this is the max bank angle for most G1000/GFC700 installations, but not all. Some are 22, some are 27.
            this.obsDirector = new GarminObsDirector(this.bus);
        }
        /** @inheritdoc */
        createVariableBankManager() {
            return undefined;
        }
        /** @inheritdoc */
        createHeadingDirector(apValues) {
            return new msfssdk.APHdgDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createRollDirector(apValues) {
            // Note: This max bank angle is for the C172, while other aircraft have higher limits.
            return new msfssdk.APRollDirector(this.bus, apValues, { minimumBankAngle: 6, maximumBankAngle: 22 });
        }
        /** @inheritdoc */
        createWingLevelerDirector() {
            return new msfssdk.APLvlDirector(this.bus);
        }
        /** @inheritdoc */
        createGpssDirector(apValues) {
            return new msfssdk.LNavDirector(this.bus, apValues, this.flightPlanner, this.obsDirector, this.lnavInterceptCurve.bind(this), true);
        }
        /** @inheritdoc */
        createVorDirector(apValues) {
            return new msfssdk.APNavDirector(this.bus, apValues, msfssdk.APLateralModes.VOR, this.navInterceptCurve.bind(this));
        }
        /** @inheritdoc */
        createLocDirector(apValues) {
            return new msfssdk.APNavDirector(this.bus, apValues, msfssdk.APLateralModes.LOC, this.navInterceptCurve.bind(this));
        }
        /** @inheritdoc */
        createBcDirector(apValues) {
            return new msfssdk.APBackCourseDirector(this.bus, apValues, msfssdk.APLateralModes.BC, this.navInterceptCurve.bind(this));
        }
        /** @inheritdoc */
        createPitchDirector(apValues) {
            return new msfssdk.APPitchDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createVsDirector(apValues) {
            return new msfssdk.APVSDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createFlcDirector(apValues) {
            return new msfssdk.APFLCDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createAltHoldDirector(apValues) {
            return new msfssdk.APAltDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createAltCapDirector(apValues) {
            return new msfssdk.APAltCapDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createVNavManager(apValues) {
            var _a;
            return (_a = this.vnavManager) !== null && _a !== void 0 ? _a : (this.vnavManager = new GarminVNavManager(this.bus, this.flightPlanner, this.verticalPathCalculator, apValues, 0));
        }
        /** @inheritdoc */
        createVNavPathDirector(apValues) {
            return new msfssdk.APVNavPathDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createGpDirector(apValues) {
            return new msfssdk.APGPDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createGsDirector(apValues) {
            return new msfssdk.APGSDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createNavToNavManager(apValues) {
            return new GarminNavToNavManager(this.bus, this.flightPlanner, apValues);
        }
        /**
         * Calculates intercept angles for radio nav.
         * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
         * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
         * Negative values indicate that the desired track is to the left of the plane.
         * @param tas The true airspeed of the plane, in knots.
         * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
         * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
         */
        navInterceptCurve(distanceToSource, deflection, tas, isLoc) {
            if (isLoc) {
                return this.localizerInterceptCurve(distanceToSource, deflection, tas);
            }
            else {
                // max deflection is 2.5 degrees or 0.0436332 radians
                const fullScaleDeflectionInRadians = 0.0436332;
                return this.defaultInterceptCurve(Math.sin(fullScaleDeflectionInRadians * -deflection) * distanceToSource, tas);
            }
        }
        /**
         * Calculates intercept angles for LNAV.
         * @param dtk The desired track, in degrees true.
         * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
         * desired track.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
         */
        lnavInterceptCurve(dtk, xtk, tas) {
            return this.defaultInterceptCurve(xtk, tas);
        }
        /**
         * Calculates intercept angles for localizers.
         * @param distanceToSource The distance from the plane to the localizer, in nautical miles.
         * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
         * Negative values indicate that the desired track is to the left of the plane.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the localizer course.
         */
        localizerInterceptCurve(distanceToSource, deflection, tas) {
            // max deflection is 2.5 degrees or 0.0436332 radians
            const fullScaleDeflectionInRadians = 0.0436332;
            const xtkNM = Math.sin(fullScaleDeflectionInRadians * -deflection) * distanceToSource;
            const xtkMeters = msfssdk.UnitType.NMILE.convertTo(xtkNM, msfssdk.UnitType.METER);
            const xtkMetersAbs = Math.abs(xtkMeters);
            if (xtkMetersAbs < 4) {
                return 0;
            }
            else if (xtkMetersAbs < 250) {
                return msfssdk.NavMath.clamp(Math.abs(xtkNM * 75), 1, 5);
            }
            const turnRadiusMeters = msfssdk.NavMath.turnRadius(tas, 22.5);
            const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
            return msfssdk.NavMath.clamp(interceptAngle, 0, 20);
        }
        /**
         * Calculates non-localizer intercept angles.
         * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
         * desired track.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the desired track.
         */
        defaultInterceptCurve(xtk, tas) {
            const xtkMeters = msfssdk.UnitType.NMILE.convertTo(xtk, msfssdk.UnitType.METER);
            const xtkMetersAbs = Math.abs(xtkMeters);
            if (xtkMetersAbs < 250) {
                return msfssdk.NavMath.clamp(Math.abs(xtk * 75), 0, 5);
            }
            const turnRadiusMeters = msfssdk.NavMath.turnRadius(tas, 22.5);
            const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
            return msfssdk.NavMath.clamp(interceptAngle, 0, 45);
        }
        /**
         * Calculates an intercept angle to a track such that the intercept course, projected forward from the plane's
         * position, intercepts the desired track at the same point as a constant-radius turn overlapping the plane's
         * position configured to be tangent to the desired track. This has the effect of producing an intercept angle which
         * guarantees a no-overshoot intercept for all initial ground tracks for which a no-overshoot intercept is possible
         * given the specified turn radius and cross-track error.
         *
         * If the magnitude of the cross-track error is greater than twice the turn radius, no constant-radius turn
         * overlapping the plane's position will be tangent to the desired track; in this case the maximum possible intercept
         * angle of 90 degrees is returned.
         * @param turnRadius The turn radius, in the same units as `xtk`.
         * @param xtk The cross-track error, in the same units as `turnRadius`.
         * @returns The calculated intercept angle, in degrees.
         */
        calculateTurnBasedInterceptAngle(turnRadius, xtk) {
            return msfssdk.UnitType.RADIAN.convertTo(Math.acos(msfssdk.NavMath.clamp((turnRadius - Math.abs(xtk)) / turnRadius, -1, 1)), msfssdk.UnitType.DEGREE) / 2;
        }
    }

    /**
     * A G1000 NXi autopilot state manager.
     */
    class GarminAPStateManager extends msfssdk.APStateManager {
        constructor() {
            super(...arguments);
            this.vsLastPressed = 0;
        }
        /** @inheritdoc */
        onAPListenerRegistered() {
            super.onAPListenerRegistered();
            const hEvent = this.bus.getSubscriber();
            hEvent.on('hEvent').handle((e) => {
                if (e === 'AS1000_VNAV_TOGGLE') {
                    this.toggleVnav();
                }
            });
        }
        /** @inheritdoc */
        setupKeyIntercepts(manager) {
            //alt modes
            manager.interceptKey('AP_ALT_HOLD', false);
            manager.interceptKey('AP_ALT_HOLD', false);
            manager.interceptKey('AP_ALT_HOLD_ON', false);
            manager.interceptKey('AP_ALT_HOLD_OFF', false);
            manager.interceptKey('AP_PANEL_ALTITUDE_HOLD', false);
            manager.interceptKey('AP_PANEL_ALTITUDE_ON', false);
            manager.interceptKey('AP_PANEL_ALTITUDE_OFF', false);
            manager.interceptKey('AP_PANEL_ALTITUDE_SET', false);
            //vs modes
            manager.interceptKey('AP_PANEL_VS_HOLD', false);
            manager.interceptKey('AP_PANEL_VS_ON', false);
            manager.interceptKey('AP_PANEL_VS_OFF', false);
            manager.interceptKey('AP_PANEL_VS_SET', false);
            manager.interceptKey('AP_VS_HOLD', false);
            manager.interceptKey('AP_VS_ON', false);
            manager.interceptKey('AP_VS_OFF', false);
            manager.interceptKey('AP_VS_SET', false);
            //pitch modes
            manager.interceptKey('AP_ATT_HOLD', false);
            manager.interceptKey('AP_ATT_HOLD_ON', false);
            manager.interceptKey('AP_ATT_HOLD_OFF', false);
            manager.interceptKey('AP_PITCH_LEVELER', false);
            manager.interceptKey('AP_PITCH_LEVELER_ON', false);
            manager.interceptKey('AP_PITCH_LEVELER_OFF', false);
            //roll modes
            manager.interceptKey('AP_BANK_HOLD', false);
            manager.interceptKey('AP_BANK_HOLD_ON', false);
            manager.interceptKey('AP_BANK_HOLD_OFF', false);
            manager.interceptKey('AP_WING_LEVELER', false);
            manager.interceptKey('AP_WING_LEVELER_ON', false);
            manager.interceptKey('AP_WING_LEVELER_OFF', false);
            //flc modes
            manager.interceptKey('FLIGHT_LEVEL_CHANGE', false);
            manager.interceptKey('FLIGHT_LEVEL_CHANGE_ON', false);
            manager.interceptKey('FLIGHT_LEVEL_CHANGE_OFF', false);
            //nav modes
            manager.interceptKey('AP_NAV1_HOLD', false);
            manager.interceptKey('AP_NAV1_HOLD_ON', false);
            manager.interceptKey('AP_NAV1_HOLD_OFF', false);
            manager.interceptKey('AP_NAV_SELECT_SET', false);
            manager.interceptKey('TOGGLE_GPS_DRIVES_NAV1', false);
            //hdg modes
            manager.interceptKey('AP_HDG_HOLD', false);
            manager.interceptKey('AP_HDG_HOLD_ON', false);
            manager.interceptKey('AP_HDG_HOLD_OFF', false);
            manager.interceptKey('AP_PANEL_HEADING_HOLD', false);
            manager.interceptKey('AP_PANEL_HEADING_ON', false);
            manager.interceptKey('AP_PANEL_HEADING_OFF', false);
            manager.interceptKey('AP_PANEL_HEADING_SET', false);
            //bank modes
            manager.interceptKey('AP_BANK_HOLD', false);
            manager.interceptKey('AP_BANK_HOLD_ON', false);
            manager.interceptKey('AP_BANK_HOLD_OFF', false);
            //appr modes
            manager.interceptKey('AP_LOC_HOLD', false);
            manager.interceptKey('AP_LOC_HOLD_ON', false);
            manager.interceptKey('AP_LOC_HOLD_OFF', false);
            manager.interceptKey('AP_APR_HOLD', false);
            manager.interceptKey('AP_APR_HOLD_ON', false);
            manager.interceptKey('AP_APR_HOLD_OFF', false);
            manager.interceptKey('AP_BC_HOLD', false);
            manager.interceptKey('AP_BC_HOLD_ON', false);
            manager.interceptKey('AP_BC_HOLD_OFF', false);
            //baro set intercept
            manager.interceptKey('BAROMETRIC', true);
        }
        /** @inheritdoc */
        handleKeyIntercepted({ key, value }) {
            const controlEventPub = this.bus.getPublisher();
            switch (key) {
                case 'AP_NAV1_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.NAV);
                    break;
                case 'AP_NAV1_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.NAV, true);
                    break;
                case 'AP_NAV1_HOLD_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.NAV, false);
                    break;
                case 'AP_LOC_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LOC);
                    break;
                case 'AP_LOC_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LOC, true);
                    break;
                case 'AP_LOC_HOLD_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LOC, false);
                    break;
                case 'AP_APR_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.APPROACH);
                    break;
                case 'AP_APR_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.APPROACH, undefined, true);
                    break;
                case 'AP_APR_HOLD_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.APPROACH, undefined, false);
                    break;
                case 'AP_BC_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.BC);
                    break;
                case 'AP_BC_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.BC, true);
                    break;
                case 'AP_BC_HOLD_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.BC, false);
                    break;
                case 'AP_HDG_HOLD':
                case 'AP_PANEL_HEADING_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.HEADING);
                    break;
                case 'AP_PANEL_HEADING_ON':
                case 'AP_HDG_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.HEADING, true);
                    break;
                case 'AP_PANEL_HEADING_OFF':
                case 'AP_HDG_HOLD_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.HEADING, false);
                    break;
                case 'AP_PANEL_HEADING_SET':
                    if (value !== undefined) {
                        this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.HEADING, value === 1 ? true : false);
                    }
                    break;
                case 'AP_BANK_HOLD':
                case 'AP_BANK_HOLD_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.ROLL, true);
                    break;
                case 'AP_WING_LEVELER':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LEVEL);
                    break;
                case 'AP_WING_LEVELER_ON':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LEVEL, true);
                    break;
                case 'AP_WING_LEVELER_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.LATERAL, msfssdk.APLateralModes.LEVEL, false);
                    break;
                case 'AP_PANEL_VS_HOLD':
                case 'AP_VS_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.VS);
                    break;
                case 'AP_PANEL_VS_ON':
                case 'AP_VS_ON':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.VS, true);
                    break;
                case 'AP_PANEL_VS_OFF':
                case 'AP_VS_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.VS, false);
                    break;
                case 'AP_PANEL_VS_SET':
                case 'AP_VS_SET':
                    // TODO Remove this when the Bravo default mapping is fixed.
                    if (value !== undefined && this.vsLastPressed < Date.now() - 100) {
                        this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.VS, value === 1 ? true : false);
                    }
                    this.vsLastPressed = Date.now();
                    break;
                case 'AP_ALT_HOLD':
                case 'AP_PANEL_ALTITUDE_HOLD':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.ALT);
                    break;
                case 'AP_ALT_HOLD_ON':
                case 'AP_PANEL_ALTITUDE_ON':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.ALT, true);
                    break;
                case 'AP_ALT_HOLD_OFF':
                case 'AP_PANEL_ALTITUDE_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.ALT, false);
                    break;
                case 'AP_PANEL_ALTITUDE_SET':
                    if (value !== undefined) {
                        this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.ALT, value === 1 ? true : false);
                    }
                    break;
                case 'FLIGHT_LEVEL_CHANGE':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.FLC);
                    break;
                case 'FLIGHT_LEVEL_CHANGE_ON':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.FLC, true);
                    break;
                case 'FLIGHT_LEVEL_CHANGE_OFF':
                    this.sendApModeEvent(msfssdk.APModeType.VERTICAL, msfssdk.APVerticalModes.FLC, false);
                    break;
                case 'AP_NAV_SELECT_SET':
                    if (value !== undefined && value >= 1 && value <= 2) {
                        controlEventPub.pub('cdi_src_set', { type: msfssdk.NavSourceType.Nav, index: value }, true);
                    }
                    break;
                case 'TOGGLE_GPS_DRIVES_NAV1':
                    controlEventPub.pub('cdi_src_gps_toggle', true, true);
                    break;
                case 'BAROMETRIC':
                    controlEventPub.pub('baro_set', true, true);
                    break;
            }
        }
        /** @inheritdoc */
        onBeforeInitialize() {
            SimVar.SetSimVarValue('L:WT1000_AP_G1000_INSTALLED', msfssdk.SimVarValueType.Bool, true);
        }
    }

    /**
     * Displays a bearing value.
     */
    class BearingDisplay extends msfssdk.AbstractNumberUnitDisplay {
        /** @inheritdoc */
        constructor(props) {
            var _a;
            var _b;
            super(props);
            this.unitTextSmallRef = msfssdk.FSComponent.createRef();
            this.numberTextSub = msfssdk.Subject.create('');
            this.unitTextSmallSub = msfssdk.Subject.create('');
            (_a = (_b = this.props).use360) !== null && _a !== void 0 ? _a : (_b.use360 = true);
        }
        /** @inheritdoc */
        onAfterRender() {
            super.onAfterRender();
            // We have to hide the "small" unit text when empty because an empty string will get rendered as a space.
            this.unitTextSmallSub.sub((text) => { this.unitTextSmallRef.instance.style.display = text === '' ? 'none' : ''; }, true);
        }
        /** @inheritdoc */
        onValueChanged(value) {
            this.setDisplay(value, this.displayUnit.get());
        }
        /** @inheritdoc */
        onDisplayUnitChanged(displayUnit) {
            this.setDisplay(this.value.get(), displayUnit);
        }
        /**
         * Displays this component's current value.
         * @param value The current value.
         * @param displayUnit The current display unit.
         */
        setDisplay(value, displayUnit) {
            if (!displayUnit || !value.unit.canConvert(displayUnit)) {
                displayUnit = value.unit;
            }
            const number = value.asUnit(displayUnit);
            let numberText = this.props.formatter(number);
            if (this.props.use360 && parseFloat(numberText) === 0) {
                numberText = this.props.formatter(360);
            }
            this.numberTextSub.set(numberText);
            this.unitTextSmallSub.set(displayUnit.isMagnetic() ? '' : 'T');
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
                msfssdk.FSComponent.buildComponent("span", { class: 'bearing-num' }, this.numberTextSub),
                msfssdk.FSComponent.buildComponent("span", { class: 'bearing-unit' }, "\u00B0"),
                msfssdk.FSComponent.buildComponent("span", { ref: this.unitTextSmallRef, class: 'bearing-unit-small' }, this.unitTextSmallSub)));
        }
    }

    /**
     * Text display of a magnetic variation as degrees east or west.
     */
    class MagVarDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.text = typeof this.props.magvar === 'object'
                ? (this.magvarSub = this.props.magvar.map(MagVarDisplay.FORMATTER))
                : MagVarDisplay.FORMATTER(this.props.magvar);
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.magvarSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    MagVarDisplay.FORMATTER = (magvar) => {
        // Force any finite magnetic variation value into the domain of [-180, 180].
        const magVarCorrected = ((magvar + 540) % 360 - 180);
        // Rendering this way means we may variously show 0W or 0E depending on the fractional
        // part of the value, but this is accurate to testing with the trainer.  Start at a
        // place where the plane's magvar on the setup page is shown as 0W, then fly west, and
        // eventually it switches to 0E before proceeding on to 1E.  A value of precisely 0
        // will be shown as east, which also seems to match how the trainer displays VORs with
        // a 0 station magvar: they, empirically, all seem to show 0E.
        return `${Math.abs(magVarCorrected).toFixed(0)}${magVarCorrected < 0 ? 'W' : 'E'}`;
    };

    /**
     * A utility class for creating Garmin unit formatters.
     *
     * Each unit formatter is a function which generates output strings from input measurement units.
     */
    class UnitFormatter {
        /**
         * Creates a function which formats measurement units to strings representing their abbreviated names.
         * @param defaultString The string to output when the input unit cannot be formatted. Defaults to the empty string.
         * @param charCase The case to enforce on the output string. Defaults to `'normal'`.
         * @returns A function which formats measurement units to strings representing their abbreviated names.
         */
        static create(defaultString = '', charCase = 'normal') {
            switch (charCase) {
                case 'upper':
                    return (unit) => { var _a, _b, _c; return (_c = (_b = (_a = UnitFormatter.UNIT_TEXT[unit.family]) === null || _a === void 0 ? void 0 : _a[unit.name]) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== null && _c !== void 0 ? _c : defaultString; };
                case 'lower':
                    return (unit) => { var _a, _b, _c; return (_c = (_b = (_a = UnitFormatter.UNIT_TEXT[unit.family]) === null || _a === void 0 ? void 0 : _a[unit.name]) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : defaultString; };
                default:
                    return (unit) => { var _a, _b; return (_b = (_a = UnitFormatter.UNIT_TEXT[unit.family]) === null || _a === void 0 ? void 0 : _a[unit.name]) !== null && _b !== void 0 ? _b : defaultString; };
            }
        }
    }
    UnitFormatter.UNIT_TEXT = {
        [msfssdk.UnitFamily.Distance]: {
            [msfssdk.UnitType.METER.name]: 'M',
            [msfssdk.UnitType.FOOT.name]: 'FT',
            [msfssdk.UnitType.KILOMETER.name]: 'KM',
            [msfssdk.UnitType.NMILE.name]: 'NM'
        },
        [msfssdk.UnitFamily.Angle]: {
            [msfssdk.UnitType.DEGREE.name]: '',
            [msfssdk.UnitType.RADIAN.name]: 'rad'
        },
        [msfssdk.UnitFamily.Duration]: {
            [msfssdk.UnitType.SECOND.name]: 'S',
            [msfssdk.UnitType.MINUTE.name]: 'M',
            [msfssdk.UnitType.HOUR.name]: 'H'
        },
        [msfssdk.UnitFamily.Weight]: {
            [msfssdk.UnitType.KILOGRAM.name]: 'KG',
            [msfssdk.UnitType.POUND.name]: 'LB',
            [msfssdk.UnitType.LITER_FUEL.name]: 'L',
            [msfssdk.UnitType.GALLON_FUEL.name]: 'GAL'
        },
        [msfssdk.UnitFamily.Volume]: {
            [msfssdk.UnitType.LITER.name]: 'L',
            [msfssdk.UnitType.GALLON.name]: 'GAL'
        },
        [msfssdk.UnitFamily.Pressure]: {
            [msfssdk.UnitType.HPA.name]: 'HPA',
            [msfssdk.UnitType.IN_HG.name]: 'IN'
        },
        [msfssdk.UnitFamily.Temperature]: {
            [msfssdk.UnitType.CELSIUS.name]: 'C',
            [msfssdk.UnitType.FAHRENHEIT.name]: 'F'
        },
        [msfssdk.UnitType.KNOT.family]: {
            [msfssdk.UnitType.KNOT.name]: 'KT',
            [msfssdk.UnitType.KPH.name]: 'KH',
            [msfssdk.UnitType.MPM.name]: 'MPM',
            [msfssdk.UnitType.FPM.name]: 'FPM'
        },
        [msfssdk.UnitType.LPH_FUEL.family]: {
            [msfssdk.UnitType.KGH.name]: 'KGH',
            [msfssdk.UnitType.PPH.name]: 'PPH',
            [msfssdk.UnitType.LPH_FUEL.name]: 'LPH',
            [msfssdk.UnitType.GPH_FUEL.name]: 'GPH'
        }
    };

    /**
     * A component which displays a number with units.
     */
    class NumberUnitDisplay extends msfssdk.AbstractNumberUnitDisplay {
        constructor() {
            super(...arguments);
            this.unitTextBigRef = msfssdk.FSComponent.createRef();
            this.numberText = msfssdk.Subject.create('');
            this.unitTextBig = msfssdk.Subject.create('');
            this.unitTextSmall = msfssdk.Subject.create('');
        }
        /** @inheritdoc */
        onAfterRender() {
            super.onAfterRender();
            // We have to hide the "big" unit text when empty because an empty string will get rendered as a space.
            this.unitTextBig.sub((text) => { this.unitTextBigRef.instance.style.display = text === '' ? 'none' : ''; }, true);
        }
        /** @inheritdoc */
        onValueChanged(value) {
            this.setDisplay(value, this.displayUnit.get());
        }
        /** @inheritdoc */
        onDisplayUnitChanged(displayUnit) {
            this.setDisplay(this.value.get(), displayUnit);
        }
        /**
         * Displays this component's current value.
         * @param value The current value.
         * @param displayUnit The current display unit.
         */
        setDisplay(value, displayUnit) {
            if (!displayUnit || !value.unit.canConvert(displayUnit)) {
                displayUnit = value.unit;
            }
            const numberText = this.props.formatter(value.asUnit(displayUnit));
            this.numberText.set(numberText);
            const unitText = NumberUnitDisplay.UNIT_FORMATTER(displayUnit);
            if (unitText[0] === '') {
                this.unitTextBig.set('');
                this.unitTextSmall.set(unitText.substring(1));
            }
            else {
                this.unitTextBig.set('');
                this.unitTextSmall.set(unitText);
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
                msfssdk.FSComponent.buildComponent("span", { class: 'numberunit-num' }, this.numberText),
                msfssdk.FSComponent.buildComponent("span", { ref: this.unitTextBigRef, class: 'numberunit-unit-big' }, this.unitTextBig),
                msfssdk.FSComponent.buildComponent("span", { class: 'numberunit-unit-small' }, this.unitTextSmall)));
        }
    }
    NumberUnitDisplay.UNIT_FORMATTER = UnitFormatter.create();

    /**
     * Time display formats.
     */
    exports.TimeDisplayFormat = void 0;
    (function (TimeDisplayFormat) {
        /** UTC time. */
        TimeDisplayFormat[TimeDisplayFormat["UTC"] = 0] = "UTC";
        /** Local time in 24-hour format. */
        TimeDisplayFormat[TimeDisplayFormat["Local24"] = 1] = "Local24";
        /** Local time in 12-hour format. */
        TimeDisplayFormat[TimeDisplayFormat["Local12"] = 2] = "Local12";
    })(exports.TimeDisplayFormat || (exports.TimeDisplayFormat = {}));
    /**
     * Displays time in HH:MM:SS format.
     */
    class TimeDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.timeSeconds = typeof this.props.time === 'object'
                ? (this.timeSub = this.props.time.map(TimeDisplay.SECOND_PRECISION_MAP))
                : msfssdk.Subject.create(TimeDisplay.SECOND_PRECISION_MAP(this.props.time));
            this.format = typeof this.props.format === 'object'
                ? this.props.format
                : msfssdk.Subject.create(this.props.format);
            this.localOffset = typeof this.props.localOffset === 'object'
                ? this.props.localOffset
                : msfssdk.Subject.create(this.props.localOffset);
            this.date = new Date();
            this.hourText = msfssdk.Subject.create('');
            this.minText = msfssdk.Subject.create('');
            this.secText = msfssdk.Subject.create('');
            this.suffixText = msfssdk.Subject.create('');
            this.updateHandler = this.updateDisplayedTime.bind(this);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.formatSub = this.format.sub(this.updateHandler);
            this.localOffsetSub = this.localOffset.sub(this.updateHandler);
            this.timeSeconds.sub(this.updateHandler, true);
        }
        /**
         * Updates the displayed time.
         */
        updateDisplayedTime() {
            const utcTime = this.timeSeconds.get();
            const format = this.format.get();
            let isAm = true;
            if (isNaN(utcTime)) {
                this.hourText.set('__');
                this.minText.set('__');
                this.secText.set('__');
            }
            else {
                const offset = format === exports.TimeDisplayFormat.UTC ? 0 : this.localOffset.get();
                const displayTime = utcTime + offset;
                this.date.setTime(displayTime);
                const hour = this.date.getUTCHours();
                isAm = hour < 12;
                const mod = format === exports.TimeDisplayFormat.Local12 ? 12 : 24;
                const displayHour = mod - (mod - (hour % mod)) % mod;
                this.hourText.set(displayHour.toString().padStart(2, '0'));
                this.minText.set(this.date.getUTCMinutes().toString().padStart(2, '0'));
                this.secText.set(this.date.getUTCSeconds().toString().padStart(2, '0'));
            }
            if (format === exports.TimeDisplayFormat.UTC) {
                this.suffixText.set('UTC');
            }
            else if (format === exports.TimeDisplayFormat.Local24) {
                this.suffixText.set('LCL');
            }
            else {
                this.suffixText.set(isAm ? 'AM' : 'PM');
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
                msfssdk.FSComponent.buildComponent("span", { class: 'time-hour' }, this.hourText),
                msfssdk.FSComponent.buildComponent("span", { class: 'time-min' },
                    ":",
                    this.minText),
                msfssdk.FSComponent.buildComponent("span", { class: 'time-sec' },
                    ":",
                    this.secText),
                msfssdk.FSComponent.buildComponent("span", { class: 'time-suffix' }, this.suffixText)));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            (_a = this.timeSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.formatSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.localOffsetSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    TimeDisplay.SECOND_PRECISION_MAP = msfssdk.SubscribableMapFunctions.withPrecision(1000);

    /**
     * A status bar which depicts an on/off state.
     *
     * The root element of the status bar contains the `toggle-status-bar` CSS class by default. The root element also
     * conditionally contains the `toggle-status-bar-on` class when the status bar's bound state is on.
     */
    class ToggleStatusBar extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.cssClassSet = msfssdk.SetSubject.create(['toggle-status-bar']);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.stateSub = this.props.state.sub(state => {
                if (state) {
                    this.cssClassSet.add('toggle-status-bar-on');
                }
                else {
                    this.cssClassSet.delete('toggle-status-bar-on');
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            var _a;
            const reservedClasses = ['toggle-status-bar', 'toggle-status-bar-on'];
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, reservedClasses);
            }
            else {
                for (const cssClassToAdd of msfssdk.FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(cssClass => !reservedClasses.includes(cssClass))) {
                    this.cssClassSet.add(cssClassToAdd);
                }
            }
            return (msfssdk.FSComponent.buildComponent("div", { class: this.cssClassSet }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.stateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * Setting modes for nav angle units.
     */
    exports.UnitsNavAngleSettingMode = void 0;
    (function (UnitsNavAngleSettingMode) {
        UnitsNavAngleSettingMode["Magnetic"] = "magnetic";
        UnitsNavAngleSettingMode["True"] = "true";
    })(exports.UnitsNavAngleSettingMode || (exports.UnitsNavAngleSettingMode = {}));
    /**
     * Setting modes for distance/speed units.
     */
    exports.UnitsDistanceSettingMode = void 0;
    (function (UnitsDistanceSettingMode) {
        UnitsDistanceSettingMode["Metric"] = "metric";
        UnitsDistanceSettingMode["Nautical"] = "nautical";
    })(exports.UnitsDistanceSettingMode || (exports.UnitsDistanceSettingMode = {}));
    /**
     * Setting modes for altitude/vertical speed units.
     */
    exports.UnitsAltitudeSettingMode = void 0;
    (function (UnitsAltitudeSettingMode) {
        UnitsAltitudeSettingMode["Feet"] = "feet";
        UnitsAltitudeSettingMode["Meters"] = "meters";
    })(exports.UnitsAltitudeSettingMode || (exports.UnitsAltitudeSettingMode = {}));
    /**
     * Setting modes for temperature units.
     */
    exports.UnitsTemperatureSettingMode = void 0;
    (function (UnitsTemperatureSettingMode) {
        UnitsTemperatureSettingMode["Celsius"] = "celsius";
        UnitsTemperatureSettingMode["Fahrenheit"] = "fahrenheit";
    })(exports.UnitsTemperatureSettingMode || (exports.UnitsTemperatureSettingMode = {}));
    /**
     * Setting modes for weight units.
     */
    exports.UnitsWeightSettingMode = void 0;
    (function (UnitsWeightSettingMode) {
        UnitsWeightSettingMode["Kilograms"] = "kilograms";
        UnitsWeightSettingMode["Pounds"] = "pounds";
    })(exports.UnitsWeightSettingMode || (exports.UnitsWeightSettingMode = {}));
    /**
     * A user setting manager for display units. In addition to syncing settings across instruments and managing event
     * bus events related to the settings, this manager also provides subscribables for the unit types controlled by its
     * settings.
     */
    class UnitsUserSettingManager extends msfssdk.DefaultUserSettingManager {
        /** @inheritdoc */
        constructor(bus, settingDefs) {
            super(bus, settingDefs);
            this.navAngleUnitsSub = msfssdk.Subject.create(UnitsUserSettingManager.MAGNETIC_BEARING);
            this.navAngleUnits = this.navAngleUnitsSub;
            this.distanceUnitsLargeSub = msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            this.distanceUnitsLarge = this.distanceUnitsLargeSub;
            this.distanceUnitsSmallSub = msfssdk.Subject.create(msfssdk.UnitType.FOOT);
            this.distanceUnitsSmall = this.distanceUnitsSmallSub;
            this.speedUnitsSub = msfssdk.Subject.create(msfssdk.UnitType.KNOT);
            this.speedUnits = this.speedUnitsSub;
            this.altitudeUnitsSub = msfssdk.Subject.create(msfssdk.UnitType.FOOT);
            this.altitudeUnits = this.altitudeUnitsSub;
            this.verticalSpeedUnitsSub = msfssdk.Subject.create(msfssdk.UnitType.FPM);
            this.verticalSpeedUnits = this.verticalSpeedUnitsSub;
            this.temperatureUnitsSub = msfssdk.Subject.create(msfssdk.UnitType.CELSIUS);
            this.temperatureUnits = this.temperatureUnitsSub;
            this.weightUnitsSub = msfssdk.Subject.create(msfssdk.UnitType.POUND);
            this.weightUnits = this.weightUnitsSub;
            for (const entry of this.settings.values()) {
                this.updateUnitsSubjects(entry.setting.definition.name, entry.setting.value);
            }
        }
        /** @inheritdoc */
        onSettingValueChanged(entry, value) {
            this.updateUnitsSubjects(entry.setting.definition.name, value);
            super.onSettingValueChanged(entry, value);
        }
        /** @inheritdoc */
        onSettingValueSynced(entry, data) {
            // protect against race conditions by not responding to sync events older than the last time this manager synced
            // the setting
            if (data.syncTime < entry.syncTime) {
                return;
            }
            this.updateUnitsSubjects(entry.setting.definition.name, data.value);
            super.onSettingValueSynced(entry, data);
        }
        /**
         * Updates this manager's units subjects in response to a setting value change.
         * @param settingName The name of the setting that was changed.
         * @param value The new value of the changed setting.
         */
        updateUnitsSubjects(settingName, value) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            switch (settingName) {
                case 'unitsNavAngle':
                    (_a = this.navAngleUnitsSub) === null || _a === void 0 ? void 0 : _a.set(value === exports.UnitsNavAngleSettingMode.Magnetic ? UnitsUserSettingManager.MAGNETIC_BEARING : UnitsUserSettingManager.TRUE_BEARING);
                    break;
                case 'unitsDistance':
                    if (value === exports.UnitsDistanceSettingMode.Nautical) {
                        (_b = this.distanceUnitsLargeSub) === null || _b === void 0 ? void 0 : _b.set(msfssdk.UnitType.NMILE);
                        (_c = this.distanceUnitsSmallSub) === null || _c === void 0 ? void 0 : _c.set(msfssdk.UnitType.FOOT);
                        (_d = this.speedUnitsSub) === null || _d === void 0 ? void 0 : _d.set(msfssdk.UnitType.KNOT);
                    }
                    else {
                        (_e = this.distanceUnitsLargeSub) === null || _e === void 0 ? void 0 : _e.set(msfssdk.UnitType.KILOMETER);
                        (_f = this.distanceUnitsSmallSub) === null || _f === void 0 ? void 0 : _f.set(msfssdk.UnitType.METER);
                        (_g = this.speedUnitsSub) === null || _g === void 0 ? void 0 : _g.set(msfssdk.UnitType.KPH);
                    }
                    break;
                case 'unitsAltitude':
                    if (value === exports.UnitsAltitudeSettingMode.Feet) {
                        (_h = this.altitudeUnitsSub) === null || _h === void 0 ? void 0 : _h.set(msfssdk.UnitType.FOOT);
                        (_j = this.verticalSpeedUnitsSub) === null || _j === void 0 ? void 0 : _j.set(msfssdk.UnitType.FPM);
                    }
                    else {
                        (_k = this.altitudeUnitsSub) === null || _k === void 0 ? void 0 : _k.set(msfssdk.UnitType.METER);
                        (_l = this.verticalSpeedUnitsSub) === null || _l === void 0 ? void 0 : _l.set(msfssdk.UnitType.MPM);
                    }
                    break;
                case 'unitsTemperature':
                    (_m = this.temperatureUnitsSub) === null || _m === void 0 ? void 0 : _m.set(value === exports.UnitsTemperatureSettingMode.Celsius ? msfssdk.UnitType.CELSIUS : msfssdk.UnitType.FAHRENHEIT);
                    break;
                case 'unitsWeight':
                    (_o = this.weightUnitsSub) === null || _o === void 0 ? void 0 : _o.set(value === exports.UnitsWeightSettingMode.Pounds ? msfssdk.UnitType.POUND : msfssdk.UnitType.KILOGRAM);
                    break;
            }
        }
    }
    UnitsUserSettingManager.TRUE_BEARING = msfssdk.NavAngleUnit.create(false);
    UnitsUserSettingManager.MAGNETIC_BEARING = msfssdk.NavAngleUnit.create(true);
    /**
     * Utility class for retrieving display units user setting managers.
     */
    class UnitsUserSettings {
        /**
         * Retrieves a manager for display units user settings.
         * @param bus The event bus.
         * @returns a manager for display units user settings.
         */
        static getManager(bus) {
            var _a;
            return (_a = UnitsUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (UnitsUserSettings.INSTANCE = new UnitsUserSettingManager(bus, [
                {
                    name: 'unitsNavAngle',
                    defaultValue: exports.UnitsNavAngleSettingMode.Magnetic
                },
                {
                    name: 'unitsDistance',
                    defaultValue: exports.UnitsDistanceSettingMode.Nautical
                },
                {
                    name: 'unitsAltitude',
                    defaultValue: exports.UnitsAltitudeSettingMode.Feet
                },
                {
                    name: 'unitsTemperature',
                    defaultValue: exports.UnitsTemperatureSettingMode.Celsius
                },
                {
                    name: 'unitsWeight',
                    defaultValue: exports.UnitsWeightSettingMode.Pounds
                }
            ]));
        }
    }

    /**
     * A map flight plan layer data provider which provides a displayed flight plan from a flight planner.
     */
    class MapFlightPlannerPlanDataProvider {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param planner The flight planner.
         */
        constructor(bus, planner) {
            this.bus = bus;
            this.planner = planner;
            this.planSub = msfssdk.Subject.create(null);
            this.plan = this.planSub;
            this.planModified = new msfssdk.SubEvent();
            this.planCalculated = new msfssdk.SubEvent();
            this.activeLegIndexSub = msfssdk.Subject.create(0);
            this.activeLateralLegIndex = this.activeLegIndexSub;
            this.lnavDataSub = msfssdk.Subject.create(undefined, (a, b) => {
                if (!a && !b) {
                    return true;
                }
                if (a && b) {
                    return a.currentLegIndex === b.currentLegIndex
                        && a.vectorIndex === b.vectorIndex
                        && a.transitionMode === b.transitionMode
                        && a.isSuspended === b.isSuspended;
                }
                return false;
            });
            this.lnavData = this.lnavDataSub;
            this.vnavTodLegIndexSub = msfssdk.Subject.create(-1);
            this.vnavTodLegIndex = this.vnavTodLegIndexSub;
            this.vnavBodLegIndexSub = msfssdk.Subject.create(-1);
            this.vnavBodLegIndex = this.vnavBodLegIndexSub;
            this.vnavTodLegDistanceSub = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.METER.createNumber(0));
            this.vnavTodLegDistance = this.vnavTodLegDistanceSub;
            this.vnavDistanceToTodSub = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.METER.createNumber(0));
            this.vnavDistanceToTod = this.vnavDistanceToTodSub;
            this.obsCourseSub = msfssdk.Subject.create(undefined);
            this.obsCourse = this.obsCourseSub;
            this.planIndex = -1;
            this.lnavDataCache = [
                { currentLegIndex: 0, vectorIndex: 0, transitionMode: msfssdk.LNavTransitionMode.None, isSuspended: false },
                { currentLegIndex: 0, vectorIndex: 0, transitionMode: msfssdk.LNavTransitionMode.None, isSuspended: false }
            ];
            this.activeLNavDataValue = this.lnavDataCache[0];
            this.vnavTodLegIndexValue = -1;
            this.vnavBodLegIndexValue = -1;
            this.vnavTodLegDistanceMeters = 0;
            this.isObsActive = false;
            this.obsCourseValue = 0;
            const plannerEvents = bus.getSubscriber();
            plannerEvents.on('fplCreated').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
            plannerEvents.on('fplDeleted').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
            plannerEvents.on('fplLoaded').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
            plannerEvents.on('fplIndexChanged').handle(() => { this.updateActivePlanRelatedSubs(); });
            plannerEvents.on('fplLegChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
            plannerEvents.on('fplSegmentChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
            plannerEvents.on('fplOriginDestChanged').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
            plannerEvents.on('fplActiveLegChange').handle(data => { data.planIndex === this.planIndex && data.type === msfssdk.ActiveLegType.Lateral && this.updateActiveLegIndex(); });
            plannerEvents.on('fplCalculated').handle(data => { data.planIndex === this.planIndex && this.planCalculated.notify(this); });
            this.lnavData.sub(data => {
                const oldActiveData = this.activeLNavDataValue;
                this.activeLNavDataValue = this.lnavDataCache[data === this.lnavDataCache[0] ? 1 : 0];
                if (oldActiveData !== this.activeLNavDataValue) {
                    Object.assign(this.activeLNavDataValue, oldActiveData);
                }
            });
            const lnavEvents = bus.getSubscriber();
            lnavEvents.on('lnav_tracked_leg_index').whenChanged().handle(index => {
                this.activeLNavDataValue.currentLegIndex = index;
                this.updateLNavData();
            });
            lnavEvents.on('lnav_tracked_vector_index').whenChanged().handle(index => {
                this.activeLNavDataValue.vectorIndex = index;
                this.updateLNavData();
            });
            lnavEvents.on('lnav_transition_mode').whenChanged().handle(mode => {
                this.activeLNavDataValue.transitionMode = mode;
                this.updateLNavData();
            });
            lnavEvents.on('lnav_is_suspended').whenChanged().handle(isSuspended => {
                this.activeLNavDataValue.isSuspended = isSuspended;
                this.updateLNavData();
            });
            const vnavEvents = bus.getSubscriber();
            this.vnavState = msfssdk.ConsumerSubject.create(vnavEvents.on('vnav_state').whenChanged(), msfssdk.VNavState.Disabled);
            this.vnavPathMode = msfssdk.ConsumerSubject.create(vnavEvents.on('vnav_path_mode').whenChanged(), msfssdk.VNavPathMode.None);
            vnavEvents.on('vnav_tod_global_leg_index').whenChanged().handle(legIndex => {
                this.vnavTodLegIndexValue = legIndex;
                this.updateVNavTodLegIndex();
            });
            vnavEvents.on('vnav_bod_global_leg_index').whenChanged().handle(legIndex => {
                this.vnavBodLegIndexValue = legIndex;
                this.updateVNavBodLegIndex();
            });
            vnavEvents.on('vnav_tod_leg_distance').withPrecision(0).handle(distance => {
                this.vnavTodLegDistanceMeters = distance;
                this.updateVNavTodLegDistance();
            });
            vnavEvents.on('vnav_tod_distance').withPrecision(0).handle(distance => {
                this.vnavDistanceToTodSub.set(distance, msfssdk.UnitType.METER);
            });
            const navEvents = this.bus.getSubscriber();
            navEvents.on('gps_obs_active').whenChanged().handle(isActive => {
                this.isObsActive = isActive;
                this.updateObsCourse();
            });
            navEvents.on('gps_obs_value').whenChanged().handle(course => {
                this.obsCourseValue = course;
                this.updateObsCourse();
            });
        }
        /**
         * Sets the index of the displayed plan.
         * @param index The index of the displayed plan.
         */
        setPlanIndex(index) {
            if (index === this.planIndex) {
                return;
            }
            this.planIndex = index;
            this.updatePlan();
            this.updateActivePlanRelatedSubs();
        }
        /**
         * Updates the displayed plan.
         */
        updatePlan() {
            if (this.planner.hasFlightPlan(this.planIndex)) {
                this.planSub.set(this.planner.getFlightPlan(this.planIndex));
            }
            else {
                this.planSub.set(null);
            }
        }
        /**
         * Updates subjects related to the active plan.
         */
        updateActivePlanRelatedSubs() {
            this.updateActiveLegIndex();
            this.updateLNavData();
            this.updateVNavTodLegIndex();
            this.updateVNavBodLegIndex();
            this.updateVNavTodLegDistance();
            this.updateObsCourse();
        }
        /**
         * Updates the active leg index.
         */
        updateActiveLegIndex() {
            const plan = this.plan.get();
            this.activeLegIndexSub.set(plan && this.planIndex === this.planner.activePlanIndex ? plan.activeLateralLeg : -1);
        }
        /**
         * Updates the LNAV data.
         */
        updateLNavData() {
            this.lnavDataSub.set(this.planIndex === this.planner.activePlanIndex ? this.activeLNavDataValue : undefined);
        }
        /**
         * Updates the index of the VNAV top-of-descent leg.
         */
        updateVNavTodLegIndex() {
            this.vnavTodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegIndexValue : -1);
        }
        /**
         * Updates the index of the VNAV bottom-of-descent leg.
         */
        updateVNavBodLegIndex() {
            this.vnavBodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavBodLegIndexValue : -1);
        }
        /**
         * Updates the distance from the VNAV top-of-descent point to the end of the top-of-descent leg.
         */
        updateVNavTodLegDistance() {
            this.vnavTodLegDistanceSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegDistanceMeters : 0, msfssdk.UnitType.METER);
        }
        /**
         * Updates the OBS course.
         */
        updateObsCourse() {
            this.obsCourseSub.set(this.planIndex === this.planner.activePlanIndex && this.isObsActive ? this.obsCourseValue : undefined);
        }
    }

    /**
     * A map flight plan layer data provider which provides the active flight plan to be displayed.
     */
    class MapActiveFlightPlanDataProvider {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param planner The flight planner.
         */
        constructor(bus, planner) {
            this.bus = bus;
            this.planner = planner;
            this.provider = new MapFlightPlannerPlanDataProvider(this.bus, this.planner);
            this.plan = this.provider.plan;
            this.planModified = this.provider.planModified;
            this.planCalculated = this.provider.planCalculated;
            this.activeLateralLegIndex = this.provider.activeLateralLegIndex;
            this.lnavData = this.provider.lnavData;
            this.vnavState = this.provider.vnavState;
            this.vnavPathMode = this.provider.vnavPathMode;
            this.vnavTodLegIndex = this.provider.vnavTodLegIndex;
            this.vnavBodLegIndex = this.provider.vnavBodLegIndex;
            this.vnavTodLegDistance = this.provider.vnavTodLegDistance;
            this.vnavDistanceToTod = this.provider.vnavDistanceToTod;
            this.obsCourse = this.provider.obsCourse;
            const plannerEvents = bus.getSubscriber();
            plannerEvents.on('fplIndexChanged').handle(data => { this.provider.setPlanIndex(data.planIndex); });
            this.provider.setPlanIndex(planner.activePlanIndex);
        }
    }

    /**
     * Utility Methods for the FMS.
     */
    class FmsUtils {
        /**
         * Utility method to return a one-way runway leg
         * @param airport The runway's parent airport.
         * @param oneWayRunway is the one wway runway object
         * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
         * @returns a leg object for the runway
         */
        static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
            const leg = msfssdk.FlightPlan.createLeg({
                lat: oneWayRunway.latitude,
                lon: oneWayRunway.longitude,
                type: isOriginRunway ? msfssdk.LegType.IF : msfssdk.LegType.TF,
                fixIcao: msfssdk.RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
                altitude1: oneWayRunway.elevation
            });
            return leg;
        }
        /**
         * Utility method to return a one-way runway leg from an approach runway leg definition
         * @param airport is the facility associated with the arrival
         * @param runwayIcao is the icao string for the runway waypoint in the final legs
         * @returns a leg object for the runway
         */
        static buildRunwayLegForApproach(airport, runwayIcao) {
            for (let i = 0; i < airport.runways.length; i++) {
                const match = msfssdk.RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                    return (r.designation == msfssdk.ICAO.getIdent(runwayIcao));
                });
                if (match) {
                    const leg = msfssdk.FlightPlan.createLeg({
                        lat: match.latitude,
                        lon: match.longitude,
                        type: msfssdk.LegType.TF,
                        fixIcao: runwayIcao
                    });
                    return leg;
                }
            }
            return undefined;
        }
        /**
         * Utility method to return a visual approach for a runway.
         * @param airport is the airport facility for the visual approach.
         * @param runway is the runway to build the visual approach for.
         * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
         * @param initialLegDistance is the distance from the final leg to place the iaf leg in NM.
         * @param name is the optional name for the approach.
         * @param finalLegIdent is the optional name for the faf leg.
         * @param initialLegIdent is the optional name for the iaf leg.
         * @returns an approach procedure.
         */
        static buildVisualApproach(airport, runway, finalLegDistance, initialLegDistance, name, finalLegIdent, initialLegIdent) {
            const runwayVec = msfssdk.GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, FmsUtils.vec3Cache[0]);
            const approachPath = FmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
            const iafLatLon = approachPath.offsetDistanceAlong(runwayVec, msfssdk.UnitType.NMILE.convertTo(-(initialLegDistance + finalLegDistance), msfssdk.UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
            const runwayCode = msfssdk.RunwayUtils.getRunwayCode(runway.direction);
            const runwayLetter = msfssdk.RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
            initialLegIdent !== null && initialLegIdent !== void 0 ? initialLegIdent : (initialLegIdent = 'STRGHT');
            const iafLeg = msfssdk.FlightPlan.createLeg({
                type: msfssdk.LegType.IF,
                fixIcao: `S${msfssdk.ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${initialLegIdent}`,
                lat: iafLatLon.lat,
                lon: iafLatLon.lon,
            });
            const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, msfssdk.UnitType.NMILE.convertTo(-finalLegDistance, msfssdk.UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
            finalLegIdent !== null && finalLegIdent !== void 0 ? finalLegIdent : (finalLegIdent = ' FINAL');
            const fafLeg = msfssdk.FlightPlan.createLeg({
                type: msfssdk.LegType.CF,
                fixIcao: `S${msfssdk.ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`,
                course: msfssdk.MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
                fixTypeFlags: msfssdk.FixTypeFlags.FAF,
                lat: fafLatLon.lat,
                lon: fafLatLon.lon,
                altDesc: msfssdk.AltitudeRestrictionType.AtOrAbove,
                altitude1: runway.elevation + 110,
            });
            const runwayLeg = FmsUtils.buildRunwayLeg(airport, runway, false);
            runwayLeg.altitude1 += 15; //Runway leg altitude should be 50 feet above threshold
            runwayLeg.fixTypeFlags = msfssdk.FixTypeFlags.MAP;
            const finalLegs = [];
            finalLegs.push(iafLeg);
            finalLegs.push(fafLeg);
            finalLegs.push(runwayLeg);
            const missedLegLatLon = approachPath.offsetDistanceAlong(runwayVec, msfssdk.UnitType.NMILE.convertTo(5, msfssdk.UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
            const missedLeg = msfssdk.FlightPlan.createLeg({
                type: msfssdk.LegType.TF,
                fixIcao: `S${msfssdk.ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}MANSEQ`,
                lat: missedLegLatLon.lat,
                lon: missedLegLatLon.lon,
            });
            const missedLegs = [];
            missedLegs.push(missedLeg);
            const proc = {
                name: name !== null && name !== void 0 ? name : `Visual RW${runway.designation}`,
                runway: runway.designation,
                icaos: [],
                transitions: [{ name: 'STRAIGHT', legs: [] }],
                finalLegs: finalLegs,
                missedLegs: missedLegs,
                approachType: msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL,
                approachSuffix: '',
                runwayDesignator: runway.runwayDesignator,
                runwayNumber: runway.direction,
                rnavTypeFlags: msfssdk.RnavTypeFlags.None
            };
            return proc;
        }
        /**
         * Utility method to return a single RnavTypeFlag from multiple possible flags.
         * @param rnavTypeFlags The input RnavTypeFlags.
         * @returns A single RnavTypeFlag
         */
        static getBestRnavType(rnavTypeFlags) {
            if (rnavTypeFlags & msfssdk.RnavTypeFlags.LPV) {
                return msfssdk.RnavTypeFlags.LPV;
            }
            if (rnavTypeFlags & msfssdk.RnavTypeFlags.LNAVVNAV) {
                return msfssdk.RnavTypeFlags.LNAVVNAV;
            }
            if (rnavTypeFlags & msfssdk.RnavTypeFlags.LP) {
                return msfssdk.RnavTypeFlags.LP;
            }
            if (rnavTypeFlags & msfssdk.RnavTypeFlags.LNAV) {
                return msfssdk.RnavTypeFlags.LNAV;
            }
            return msfssdk.RnavTypeFlags.None;
        }
        /**
         * Utility method to check whether an approach is authorized for GPS guidance.
         * @param approach The approach procedure
         * @returns True if GPS guidance is authorized, false otherwise.
         */
        static isGpsApproach(approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                    return true;
            }
            return false;
        }
        /**
         * Utility method to check for an approach with a a tunable localizer.
         * @param approach The approach procedure
         * @returns True if a localizer needs to be tuned, otherwise false.
         */
        static isLocalizerApproach(approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                case ApproachType.APPROACH_TYPE_SDF:
                    return true;
            }
            return false;
        }
        /**
         * Gets an approach procedure from a flight plan.
         * @param plan A flight plan.
         * @param destination The detsination airport of the flight plan.
         * @returns The approach procedure from the flight plan, or undefined if the plan has no approach.
         */
        static getApproachFromPlan(plan, destination) {
            let approach = destination.approaches[plan.procedureDetails.approachIndex];
            if (!approach) {
                const visualRwyDesignation = plan.getUserData('visual_approach');
                if (visualRwyDesignation && plan.destinationAirport) {
                    const runway = msfssdk.RunwayUtils.matchOneWayRunwayFromDesignation(destination, visualRwyDesignation);
                    if (runway) {
                        approach = {
                            name: `VISUAL ${visualRwyDesignation}`,
                            runway: runway.designation,
                            icaos: [],
                            transitions: [],
                            finalLegs: [],
                            missedLegs: [],
                            approachType: msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL,
                            approachSuffix: '',
                            runwayDesignator: runway.runwayDesignator,
                            runwayNumber: runway.direction,
                            rnavTypeFlags: msfssdk.RnavTypeFlags.None
                        };
                    }
                }
            }
            return approach;
        }
        /**
         * Checks whether a flight plan has an approach loaded.
         * @param plan A flight plan.
         * @returns Whether the flight plan has an approach loaded.
         */
        static isApproachLoaded(plan) {
            return plan.procedureDetails.approachIndex >= 0 || (plan.getUserData('visual_approach') !== undefined && plan.destinationAirport !== undefined);
        }
        /**
         * Checks whether a plan has a vectors-to-final approach loaded.
         * @param plan A flight plan.
         * @returns Whether the flight plan has a vectors-to-final approach loaded.
         */
        static isVtfApproachLoaded(plan) {
            return !!FmsUtils.getApproachVtfLeg(plan);
        }
        /**
         * Gets the vectors-to-final leg of a flight plan.
         * @param plan A flight plan.
         * @returns The vectors-to-final leg of the flight plan, or undefined if one could not be found.
         */
        static getApproachVtfLeg(plan) {
            if (!FmsUtils.isApproachLoaded(plan) || plan.procedureDetails.approachTransitionIndex >= 0) {
                return undefined;
            }
            // There should only be one approach segment
            for (const approachSegment of plan.segmentsOfType(msfssdk.FlightPlanSegmentType.Approach)) {
                return approachSegment.legs.find(leg => msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.VectorsToFinal) && msfssdk.BitFlags.isAll(leg.leg.fixTypeFlags, msfssdk.FixTypeFlags.FAF));
            }
            return undefined;
        }
        /**
         * Gets the name of a departure procedure as a string.
         * @param airport The airport to which the departure belongs.
         * @param departure A departure procedure definition.
         * @param transitionIndex The index of the departure enroute transition.
         * @param runway The runway of the departure, if any.
         * @returns The name of the departure procedure.
         */
        static getDepartureNameAsString(airport, departure, transitionIndex, runway) {
            let name = `${msfssdk.ICAO.getIdent(airport.icao)}`;
            if (runway) {
                name += `RW${runway.designation}.`;
            }
            const transition = departure.enRouteTransitions[transitionIndex];
            if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
                name += `${departure.name}.${msfssdk.ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
            }
            else if (departure.commonLegs.length > 0) {
                name += `${departure.name}.${msfssdk.ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
            }
            else {
                name += `${departure.name}`;
            }
            return name;
        }
        /**
         * Gets the name of a arrival procedure as a string.
         * @param airport The airport to which the departure belongs.
         * @param arrival An arrival procedure definition.
         * @param transitionIndex The index of the arrival enroute transition.
         * @param runway The runway of the arrival, if any.
         * @returns The name of the arrival procedure.
         */
        static getArrivalNameAsString(airport, arrival, transitionIndex, runway) {
            let name = `${msfssdk.ICAO.getIdent(airport.icao)}`;
            const transition = arrival.enRouteTransitions[transitionIndex];
            if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
                name += `${msfssdk.ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            else if (arrival.commonLegs.length > 0) {
                name += `${msfssdk.ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            else {
                name += `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            if (runway) {
                name += `.RW${runway.designation}`;
            }
            return name;
        }
        /**
         * Utility method to analyze an approach for its name components and
         * pack them into a custom type.
         * @param proc The approach procedure.
         * @returns The name as an ApproachNameParts
         */
        static getApproachNameAsParts(proc) {
            let type;
            let subtype;
            let rnavType;
            switch (proc.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                    type = 'GPS';
                    break;
                case ApproachType.APPROACH_TYPE_VOR:
                    type = 'VOR';
                    break;
                case ApproachType.APPROACH_TYPE_NDB:
                    type = 'NDB';
                    break;
                case ApproachType.APPROACH_TYPE_ILS:
                    type = 'ILS';
                    break;
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                    type = 'LOC';
                    break;
                case ApproachType.APPROACH_TYPE_SDF:
                    type = 'SDF';
                    break;
                case ApproachType.APPROACH_TYPE_LDA:
                    type = 'LDA';
                    break;
                case ApproachType.APPROACH_TYPE_VORDME:
                    type = 'VOR/DME';
                    break;
                case ApproachType.APPROACH_TYPE_NDBDME:
                    type = 'NDB/DME';
                    break;
                case ApproachType.APPROACH_TYPE_RNAV:
                    type = 'RNAV';
                    subtype = 'GPS';
                    break;
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    type = 'LOC BC';
                    break;
                case msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    type = 'VISUAL';
                    break;
                default:
                    type = '???';
                    break;
            }
            const approachIsCircling = !proc.runway ? true : false;
            if (proc.approachType === ApproachType.APPROACH_TYPE_RNAV) {
                switch (FmsUtils.getBestRnavType(proc.rnavTypeFlags)) {
                    case msfssdk.RnavTypeFlags.LNAV:
                        rnavType = approachIsCircling ? 'LNAV' : 'LNAV+V';
                        break;
                    case msfssdk.RnavTypeFlags.LP:
                        rnavType = approachIsCircling ? 'LP' : 'LP+V';
                        break;
                    case msfssdk.RnavTypeFlags.LNAVVNAV:
                        rnavType = 'LNAV/VNAV';
                        break;
                    case msfssdk.RnavTypeFlags.LPV:
                        rnavType = 'LPV';
                        break;
                }
            }
            return {
                type: type,
                subtype: subtype,
                suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
                runway: proc.runwayNumber === 0 ? undefined : msfssdk.RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
                flags: rnavType
            };
        }
        /**
         * Utility method that takes an approach and returns its name as a flat
         * string suitable for use in embedded text content.
         * @param approach The approach as an ApproaceProcedure
         * @returns The formatted name as a string.
         */
        static getApproachNameAsString(approach) {
            const parts = FmsUtils.getApproachNameAsParts(approach);
            let name = parts.type;
            parts.subtype && (name += `${parts.subtype}`);
            parts.suffix && (name += `${parts.runway ? ' ' : ''}${parts.suffix}`);
            parts.runway && (name += ` ${parts.runway}`);
            parts.flags && (name += ` ${parts.flags}`);
            return name;
        }
        /**
         * Gets an approach frequency from the facility record.
         * @param facility The airport facility.
         * @param approachIndex The approach Index.
         * @returns The FacilityFrequency or undefined
         */
        static getApproachFrequency(facility, approachIndex) {
            const approach = facility === null || facility === void 0 ? void 0 : facility.approaches[approachIndex !== null && approachIndex !== void 0 ? approachIndex : -1];
            let freq = undefined;
            if (approach) {
                switch (approach.approachType) {
                    case ApproachType.APPROACH_TYPE_ILS:
                    case ApproachType.APPROACH_TYPE_LOCALIZER:
                    case ApproachType.APPROACH_TYPE_LDA:
                    case ApproachType.APPROACH_TYPE_SDF:
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        freq = msfssdk.RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                        break;
                    case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        freq = msfssdk.RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                        break;
                }
                return freq;
            }
            else {
                return undefined;
            }
        }
        /**
         * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
         * @param lateralPlan The Lateral Flight Plan.
         * @param segmentIndex The Segment Index.
         * @param segmentLegIndex The Segment Leg Index.
         * @returns The global leg index.
         */
        static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
            if (segmentIndex < lateralPlan.segmentCount) {
                const segment = lateralPlan.getSegment(segmentIndex);
                return segment.offset + segmentLegIndex;
            }
            return -1;
        }
        /**
         * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
         * which are part of a direct to or vectors-to-final sequence.
         * @param plan A flight plan.
         * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
         * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
         * @returns The nominal leg from which the specified flight plan leg originates.
         */
        static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
            let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
            if (!leg) {
                return undefined;
            }
            for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
                if (!msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.DirectTo | msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                    return leg;
                }
            }
            return undefined;
        }
        /**
         * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
         * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
         * @param plan A flight plan.
         * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
         * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
         * @returns The nominal leg from which the specified flight plan leg originates.
         */
        static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
            let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
            if (!leg) {
                return -1;
            }
            let index = plan.getLegIndexFromLeg(leg);
            for (leg of plan.legs(true, index)) {
                if (!msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.DirectTo | msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                    return index;
                }
                index--;
            }
            return -1;
        }
        /**
         * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
         * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
         * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
         * @param plan A flight plan.
         */
        static reconcileDirectToData(plan) {
            // Scan flight plan for DTO legs
            for (let i = 0; i < plan.segmentCount; i++) {
                const segment = plan.getSegment(i);
                for (let j = 0; j < segment.legs.length; j++) {
                    const leg = segment.legs[j];
                    if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo)) {
                        plan.directToData.segmentIndex = i;
                        plan.directToData.segmentLegIndex = j - 1;
                        return;
                    }
                }
            }
            plan.directToData.segmentIndex = -1;
            plan.directToData.segmentLegIndex = -1;
        }
    }
    FmsUtils.vec3Cache = [new Float64Array(3)];
    FmsUtils.geoPointCache = [new msfssdk.GeoPoint(0, 0)];
    FmsUtils.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];
    FmsUtils.DTO_LEG_OFFSET = 3;

    /**
     * A repeating pattern of triangular arrows pointing in the direction of the input path.
     */
    class FlightPathArrowPattern {
        constructor() {
            /** @inheritdoc */
            this.length = 12;
            /** @inheritdoc */
            this.anchor = 0.5;
            /** The canvas 2D rendering context to which to render. */
            this.context = null;
            /** The color of the arrows to render. */
            this.color = 'white';
        }
        /** @inheritdoc */
        draw(stream) {
            if (!this.context) {
                return;
            }
            stream.moveTo(5, 0);
            stream.lineTo(-5, -3);
            stream.lineTo(-5, 3);
            stream.closePath();
            this.context.fillStyle = this.color;
            this.context.fill();
        }
    }

    /**
     * Bitflags for flight path rendering styles.
     */
    exports.MapFlightPathStyleFlags = void 0;
    (function (MapFlightPathStyleFlags) {
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["Prior"] = 1] = "Prior";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["Upcoming"] = 2] = "Upcoming";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["Active"] = 4] = "Active";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["Next"] = 8] = "Next";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["MissedApproach"] = 16] = "MissedApproach";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["ActiveSegment"] = 32] = "ActiveSegment";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["RollHeading"] = 64] = "RollHeading";
        MapFlightPathStyleFlags[MapFlightPathStyleFlags["Heading"] = 128] = "Heading";
    })(exports.MapFlightPathStyleFlags || (exports.MapFlightPathStyleFlags = {}));
    /**
     * A utility class defining common Garmin styles for rendering flight paths.
     */
    class MapFlightPathStyles {
    }
    /** The stroke width, in pixels, for flight plan legs positioned after the active leg in the same segment as the active leg. */
    MapFlightPathStyles.STROKE_WIDTH = 4;
    /** The stroke color for flight plan legs positioned after the active leg in the same segment as the active leg. */
    MapFlightPathStyles.STROKE_COLOR = 'white';
    /** The stroke width, in pixels, for the active flight plan leg. */
    MapFlightPathStyles.ACTIVE_STROKE_WIDTH = 4;
    /** The stroke color for the active flight plan leg. */
    MapFlightPathStyles.ACTIVE_STROKE_COLOR = 'magenta';
    /** The stroke width, in pixels, for flight plan legs positioned before the active leg. */
    MapFlightPathStyles.PRIOR_STROKE_WIDTH = 2;
    /** The stroke color for flight plan legs positioned before the active leg. */
    MapFlightPathStyles.PRIOR_STROKE_COLOR = '#cccccc';
    /** The stroke width, in pixels, for flight plan legs in the missed approach segment while the missed approach is not active. */
    MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH = 1;
    /** The stroke color for flight plan legs in the missed approach segment while the missed approach is not active. */
    MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR = 'white';
    /** The base stroke width, in pixels, for flight plan legs. */
    MapFlightPathStyles.BASE_STROKE_WIDTH = 2;
    /** The base stroke color for flight plan legs. */
    MapFlightPathStyles.BASE_STROKE_COLOR = 'rgba(204, 204, 204, 0.5)';
    /** The stroke width, in pixels, for procedure transition preview legs. */
    MapFlightPathStyles.TRANSITION_STROKE_WIDTH = 2;
    /** The stroke color for procedure transition preview legs. */
    MapFlightPathStyles.TRANSITION_STROKE_COLOR = '#666666';
    /** The stroke width, in pixels, for roll-heading vectors rendered as dashes. */
    MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH = 2;
    /** The dash array for roll-heading vectors rendered as dashes. */
    MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY = [4, 4];
    /** The width of the background for magenta arrows. */
    MapFlightPathStyles.MAGENTA_ARROW_BG_WIDTH = 6;
    /** The background color for magenta arrows. */
    MapFlightPathStyles.MAGENTA_ARROW_BG_COLOR = 'rgba(40, 40, 40, 0.5)';

    /**
     * Renders flight plan legs as a continuous line.
     */
    class FlightPathLegContinuousLineRenderer extends msfssdk.FlightPathLegLineRenderer {
        /**
         * Constructor.
         */
        constructor() {
            super((vector, isIngress, isEgress, leg, projection, out, width, style, dash) => {
                out.strokeWidth = width;
                out.strokeStyle = style;
                out.strokeDash = dash !== null && dash !== void 0 ? dash : null;
                out.outlineWidth = 0;
                out.isContinuous = true;
                return out;
            });
        }
    }
    /**
     * Renders flight plan legs using default styles. Normally, all vectors in the leg are rendered as solid lines of
     * varying width and color based on the leg's parent flight plan segment and relation to the active leg. When the leg's
     * ingress or egress transition is joined to a vector styled as a roll-heading vector, the transition will also be
     * styled as a roll-heading vector.
     */
    class FlightPathDefaultLegRenderer {
        constructor() {
            this.arrowPattern = new FlightPathArrowPattern();
            this.legLineRenderer = new msfssdk.FlightPathLegLineRenderer(this.selectLineStyle.bind(this));
            this.legPatternRenderer = new msfssdk.FlightPathLegPatternRenderer(this.selectPatternStyle.bind(this));
        }
        /**
         * Renders a default leg to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param legIndex The global index of the leg to render.
         * @param activeLegIndex The global index of the active flight plan leg.
         * @param prevLeg The leg prior to the leg to render.
         * @param nextLeg The leg after to the leg to render.
         * @param isMissedApproachActive Whether the missed approach is active.
         */
        render(leg, context, streamStack, legIndex, activeLegIndex, prevLeg, nextLeg, isMissedApproachActive) {
            var _a;
            const isMissedApproachLeg = msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach);
            const useMissedApproachStyle = !isMissedApproachActive && isMissedApproachLeg;
            const isFirstMissedApproachLeg = isMissedApproachLeg
                && !msfssdk.BitFlags.isAny((_a = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags) !== null && _a !== void 0 ? _a : 0, msfssdk.LegDefinitionFlags.MissedApproach);
            let styleFlags = 0;
            if (legIndex < activeLegIndex) {
                styleFlags |= exports.MapFlightPathStyleFlags.Prior;
            }
            else if (useMissedApproachStyle) {
                styleFlags |= exports.MapFlightPathStyleFlags.MissedApproach;
            }
            else if (legIndex > activeLegIndex) {
                styleFlags |= exports.MapFlightPathStyleFlags.Upcoming;
                if (legIndex === activeLegIndex + 1) {
                    styleFlags |= exports.MapFlightPathStyleFlags.Next;
                }
            }
            else { // legIndex === activeLegIndex
                styleFlags |= exports.MapFlightPathStyleFlags.Active;
            }
            const isIngressRollHeading = (!useMissedApproachStyle || isFirstMissedApproachLeg) && this.isIngressRollHeading(leg, prevLeg);
            const isEgressRollHeading = !useMissedApproachStyle && this.isEgressRollHeading(leg, nextLeg);
            this.arrowPattern.context = context;
            this.legLineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All, styleFlags, isIngressRollHeading, isEgressRollHeading, useMissedApproachStyle);
            this.legPatternRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All, styleFlags, isIngressRollHeading, isEgressRollHeading, useMissedApproachStyle);
        }
        /**
         * Checks if an ingress transition following a specified leg should be rendered as roll-heading vectors.
         * @param leg The leg to which the ingress transition belongs.
         * @param prevLeg The leg prior to the leg to which the ingress transition belongs, or `undefined` if there is no
         * such leg.
         * @returns If the ingress transition following the specified leg should be rendered as roll-heading vectors.
         */
        isIngressRollHeading(leg, prevLeg) {
            var _a, _b;
            const firstIngressVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.ingress[0];
            if (firstIngressVector === undefined) {
                return false;
            }
            if (this.isRollHeadingVector(firstIngressVector, leg)) {
                return true;
            }
            if (msfssdk.BitFlags.isAny(firstIngressVector.flags, msfssdk.FlightPathVectorFlags.LegToLegTurn)) {
                const ingressJoinVector = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath[leg.calculated.ingressJoinIndex];
                if (ingressJoinVector !== undefined && this.isRollHeadingVector(ingressJoinVector, leg)) {
                    return true;
                }
                return prevLeg !== undefined && this.isEgressRollHeading(prevLeg, undefined);
            }
            return false;
        }
        /**
         * Checks if an egress transition prior to a specified leg should be rendered as roll-heading vectors.
         * @param leg The leg to which the egress transition belongs.
         * @param nextLeg The leg after the leg to which the egress transition belongs, or `undefined` if there is no such
         * leg.
         * @returns If the egress transition prior to the specified leg should be rendered as roll-heading vectors.
         */
        isEgressRollHeading(leg, nextLeg) {
            var _a, _b;
            const firstEgressVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.egress[0];
            if (firstEgressVector === undefined) {
                return false;
            }
            if (this.isRollHeadingVector(firstEgressVector, leg)) {
                return true;
            }
            if (msfssdk.BitFlags.isAny(firstEgressVector.flags, msfssdk.FlightPathVectorFlags.LegToLegTurn)) {
                const egressJoinVector = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath[leg.calculated.egressJoinIndex];
                if (egressJoinVector !== undefined && this.isRollHeadingVector(egressJoinVector, leg)) {
                    return true;
                }
                return nextLeg !== undefined && this.isIngressRollHeading(nextLeg, undefined);
            }
            return false;
        }
        /**
         * Selects a line style to render for a vector.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @param styleFlags Bit flags describing the style with which to render the line.
         * @param isIngressRollHeading Whether the ingress transition should be rendered as roll-heading vectors.
         * @param isEgressRollHeading Whether the egress transition should be rendered as roll-heading vectors.
         * @param useMissedApproachStyle Whether the missed approach style should be applied to the vector.
         * @returns The selected line style for the vector.
         */
        selectLineStyle(vector, isIngress, isEgress, leg, projection, out, styleFlags, isIngressRollHeading, isEgressRollHeading, useMissedApproachStyle) {
            if ((isIngress && isIngressRollHeading)
                || (isEgress && isEgressRollHeading)
                || (!isIngress && !isEgress && !useMissedApproachStyle && this.isRollHeadingVector(vector, leg))) {
                return this.selectRollHeadingLineStyle(styleFlags, out);
            }
            else {
                return this.selectNormalLineStyle(styleFlags, out);
            }
        }
        /**
         * Selects a line style to render for a normal vector.
         * @param styleFlags Bit flags describing the style with which to render the line.
         * @param out The line style object to which to write the selected style.
         * @returns The selected line style for the vector.
         */
        selectNormalLineStyle(styleFlags, out) {
            let width, style;
            if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Active)) {
                width = MapFlightPathStyles.ACTIVE_STROKE_WIDTH;
                style = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
            }
            else if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Prior)) {
                width = MapFlightPathStyles.PRIOR_STROKE_WIDTH;
                style = MapFlightPathStyles.PRIOR_STROKE_COLOR;
            }
            else if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.MissedApproach)) {
                width = MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH;
                style = MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR;
            }
            else {
                width = MapFlightPathStyles.STROKE_WIDTH;
                style = MapFlightPathStyles.STROKE_COLOR;
            }
            out.strokeWidth = width;
            out.strokeStyle = style;
            out.strokeDash = null;
            out.outlineWidth = 0;
            out.isContinuous = true;
            return out;
        }
        /**
         * Selects a line style to render for a roll-heading vector.
         * @param styleFlags Bit flags describing the style with which to render the line.
         * @param out The line style object to which to write the selected style.
         * @returns The selected line style for the vector.
         */
        selectRollHeadingLineStyle(styleFlags, out) {
            let width, style, dash;
            if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Active)) {
                width = MapFlightPathStyles.MAGENTA_ARROW_BG_WIDTH;
                style = MapFlightPathStyles.MAGENTA_ARROW_BG_COLOR;
                dash = null;
            }
            else if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Next)) {
                width = 0;
                style = '';
                dash = null;
            }
            else {
                width = MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH;
                style = MapFlightPathStyles.STROKE_COLOR;
                dash = MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY;
            }
            out.strokeWidth = width;
            out.strokeStyle = style;
            out.strokeDash = dash;
            out.outlineWidth = 0;
            out.isContinuous = true;
            return out;
        }
        /**
         * Selects a pattern style to render a vector.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @param styleFlags Bit flags describing the style with which to render the pattern.
         * @param isIngressRollHeading Whether the ingress transition should be rendered as roll-heading vectors.
         * @param isEgressRollHeading Whether the egress transition should be rendered as roll-heading vectors.
         * @param useMissedApproachStyle Whether the missed approach style should be applied to the vector.
         * @returns The selected pattern style for the vector.
         */
        selectPatternStyle(vector, isIngress, isEgress, leg, projection, out, styleFlags, isIngressRollHeading, isEgressRollHeading, useMissedApproachStyle) {
            if ((isIngress && isIngressRollHeading)
                || (isEgress && isEgressRollHeading)
                || (!isIngress && !isEgress && !useMissedApproachStyle && this.isRollHeadingVector(vector, leg))) {
                if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Active)) {
                    this.arrowPattern.color = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
                    out.pattern = this.arrowPattern;
                }
                else if (msfssdk.BitFlags.isAny(styleFlags, exports.MapFlightPathStyleFlags.Next)) {
                    this.arrowPattern.color = MapFlightPathStyles.STROKE_COLOR;
                    out.pattern = this.arrowPattern;
                }
                else {
                    out.pattern = null;
                }
            }
            else {
                out.pattern = null;
            }
            out.isContinuous = true;
            return out;
        }
        /**
         * Checks whether a vector should be rendered as a roll-heading vector.
         * @param vector A flight path vector.
         * @param leg The flight plan leg containing the vector.
         * @returns Whether the vector should be rendered as a roll-heading vector.
         */
        isRollHeadingVector(vector, leg) {
            if (msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.Fallback
                | msfssdk.FlightPathVectorFlags.HoldDirectEntry
                | msfssdk.FlightPathVectorFlags.HoldTeardropEntry
                | msfssdk.FlightPathVectorFlags.HoldParallelEntry)) {
                return true;
            }
            switch (leg.leg.type) {
                case msfssdk.LegType.CF:
                    return msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.InterceptCourse | msfssdk.FlightPathVectorFlags.Direct);
                default:
                    return false;
            }
        }
    }
    /**
     * Renders hold legs.
     */
    class FlightPathHoldLegRenderer {
        constructor() {
            this.arrowPattern = new FlightPathArrowPattern();
            this.legContinuousLineRenderer = new FlightPathLegContinuousLineRenderer();
            this.legLineRenderer = new msfssdk.FlightPathLegLineRenderer(this.selectLineStyle.bind(this));
            this.legPatternRenderer = new msfssdk.FlightPathLegPatternRenderer(this.selectPatternStyle.bind(this));
        }
        /**
         * Renders a hold leg to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param plan The flight plan containing the leg to render.
         * @param activeLeg The active flight plan leg.
         * @param legIndex The global index of the leg to render.
         * @param activeLegIndex The global index of the active flight plan leg.
         * @param lnavData LNAV tracking data for the flight plan containing the leg to render, or undefined if LNAV is not
         * tracking the flight plan.
         */
        render(leg, context, streamStack, plan, activeLeg, legIndex, activeLegIndex, lnavData) {
            const isMissedApproachActive = !!activeLeg && msfssdk.BitFlags.isAny(activeLeg.flags, msfssdk.LegDefinitionFlags.MissedApproach);
            if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach) && !isMissedApproachActive) {
                this.legContinuousLineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.Base, MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH, MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR);
            }
            else if (legIndex < activeLegIndex || legIndex > activeLegIndex + 1) {
                const partsToRender = leg.leg.type === msfssdk.LegType.HF ? msfssdk.FlightPathLegRenderPart.All : msfssdk.FlightPathLegRenderPart.Base | msfssdk.FlightPathLegRenderPart.Egress;
                this.legLineRenderer.render(leg, context, streamStack, partsToRender, legIndex, activeLegIndex);
            }
            else if (legIndex === activeLegIndex + 1) {
                this.arrowPattern.color = MapFlightPathStyles.STROKE_COLOR;
                this.arrowPattern.context = context;
                if (leg.leg.type === msfssdk.LegType.HF) {
                    // Draw the entire hold as arrows
                    this.legPatternRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All, legIndex, activeLegIndex);
                }
                else {
                    // Draw the entire hold circuit as lines + ingress as arrows on top.
                    this.legLineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.Base, legIndex, activeLegIndex);
                    this.legPatternRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.Ingress, legIndex, activeLegIndex);
                }
            }
            else { // legIndex === activeLegIndex
                let partsToRender = 0;
                if (!lnavData || lnavData.currentLegIndex !== legIndex) {
                    partsToRender = leg.leg.type === msfssdk.LegType.HF ? msfssdk.FlightPathLegRenderPart.All : msfssdk.FlightPathLegRenderPart.Ingress | msfssdk.FlightPathLegRenderPart.Base;
                }
                else {
                    partsToRender = msfssdk.FlightPathLegRenderPart.Base;
                    if (lnavData.transitionMode === msfssdk.LNavTransitionMode.Ingress) {
                        partsToRender |= msfssdk.FlightPathLegRenderPart.Ingress;
                    }
                    if (!lnavData.isSuspended) {
                        partsToRender |= msfssdk.FlightPathLegRenderPart.Egress;
                    }
                }
                // Draw the entire hold as arrows, except the inbound leg and egress.
                this.legLineRenderer.render(leg, context, streamStack, partsToRender, legIndex, activeLegIndex);
                this.arrowPattern.color = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
                this.arrowPattern.context = context;
                this.legPatternRenderer.render(leg, context, streamStack, (msfssdk.FlightPathLegRenderPart.Ingress | msfssdk.FlightPathLegRenderPart.Base) & partsToRender, legIndex, activeLegIndex);
            }
        }
        /**
         * Selects a line style to render for a hold vector.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @param legIndex The global index of the flight plan leg to which the vector belongs.
         * @param activeLegIndex The global index of the active flight plan leg.
         * @returns The selected line style for the vector.
         */
        selectLineStyle(vector, isIngress, isEgress, leg, projection, out, legIndex, activeLegIndex) {
            let color, width, dash;
            const isInboundOrEgress = isEgress || msfssdk.BitFlags.isAll(vector.flags, msfssdk.FlightPathVectorFlags.HoldInboundLeg);
            if (legIndex < activeLegIndex || legIndex > activeLegIndex + 1) {
                // Draw all vectors as a line with the inbound leg and egress solid and rest dashed.
                width = MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH;
                color = legIndex < activeLegIndex ? MapFlightPathStyles.PRIOR_STROKE_COLOR : MapFlightPathStyles.STROKE_COLOR;
                dash = isInboundOrEgress ? null : MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY;
            }
            else if (legIndex === activeLegIndex + 1) {
                // Draw the ingress with arrows, and the hold circuit as a line with the inbound leg solid and rest dashed.
                width = MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH;
                color = MapFlightPathStyles.STROKE_COLOR;
                dash = isInboundOrEgress ? null : MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY;
            }
            else { // legIndex === activeLegIndex
                // Draw the inbound leg and egress as solid lines, and the rest as magenta arrow background.
                if (isInboundOrEgress) {
                    width = MapFlightPathStyles.ACTIVE_STROKE_WIDTH;
                    color = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
                }
                else {
                    width = MapFlightPathStyles.MAGENTA_ARROW_BG_WIDTH;
                    color = MapFlightPathStyles.MAGENTA_ARROW_BG_COLOR;
                }
                dash = null;
            }
            out.strokeWidth = width;
            out.strokeStyle = color;
            out.strokeDash = dash;
            out.outlineWidth = 0;
            out.isContinuous = true;
            return out;
        }
        /**
         * Selects a pattern style to render for a hold vector.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @param legIndex The global index of the flight plan leg to which the vector belongs.
         * @param activeLegIndex The global index of the active flight plan leg.
         * @returns The selected pattern style for the vector.
         */
        selectPatternStyle(vector, isIngress, isEgress, leg, projection, out, legIndex, activeLegIndex) {
            if (legIndex !== activeLegIndex || !(isEgress || msfssdk.BitFlags.isAll(vector.flags, msfssdk.FlightPathVectorFlags.HoldInboundLeg))) {
                out.pattern = this.arrowPattern;
            }
            else {
                out.pattern = null;
            }
            out.isContinuous = true;
            return out;
        }
    }
    /**
     * Renders procedure turn legs.
     */
    class FlightPathProcTurnLegRenderer {
        /**
         * Constructor.
         */
        constructor() {
            this.arrowPattern = new FlightPathArrowPattern();
            this.arrowPattern.color = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
            this.legLineRenderer = new FlightPathLegContinuousLineRenderer();
            this.legPatternRenderer = new msfssdk.FlightPathLegPatternRenderer((vector, isIngress, isEgress, leg, projection, out) => {
                out.pattern = this.arrowPattern;
                out.isContinuous = true;
                return out;
            });
        }
        /**
         * Renders a procedure turn leg to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param plan The flight plan containing the leg to render.
         * @param activeLeg The active flight plan leg.
         * @param legIndex The global index of the leg to render.
         * @param activeLegIndex The global index of the active flight plan leg.
         */
        render(leg, context, streamStack, plan, activeLeg, legIndex, activeLegIndex) {
            const isMissedApproachActive = !!activeLeg && msfssdk.BitFlags.isAny(activeLeg.flags, msfssdk.LegDefinitionFlags.MissedApproach);
            if (legIndex === activeLegIndex) {
                this.legLineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All, MapFlightPathStyles.MAGENTA_ARROW_BG_WIDTH, MapFlightPathStyles.MAGENTA_ARROW_BG_COLOR);
                this.arrowPattern.context = context;
                this.legPatternRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All);
            }
            else {
                let width, style;
                if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach) && !isMissedApproachActive) {
                    width = MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH;
                    style = MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR;
                }
                else if (legIndex < activeLegIndex) {
                    width = MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH;
                    style = MapFlightPathStyles.PRIOR_STROKE_COLOR;
                }
                else {
                    width = MapFlightPathStyles.ROLL_HEADING_DASH_STROKE_WIDTH;
                    style = MapFlightPathStyles.STROKE_COLOR;
                }
                this.legLineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All, width, style, MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY);
            }
        }
    }
    /**
     * Renders Direct-To legs with user-defined courses. Each leg is rendered as a single line following a 500-nautical
     * mile great-circle path along the Direct-To course terminating at the end of the leg.
     */
    class FlightPathDirectToCourseLegRenderer {
        constructor() {
            this.lineRenderer = new msfssdk.GeoCircleLineRenderer();
        }
        /**
         * Renders a Direct-To leg with user-defined course to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param width The width of the rendered line.
         * @param style The style of the rendered line.
         * @param dash The dash array of the rendered line. Defaults to no dash.
         */
        render(leg, context, streamStack, width, style, dash) {
            var _a, _b;
            if (((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) === undefined || ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) === undefined) {
                return;
            }
            const dtoFix = FlightPathDirectToCourseLegRenderer.geoPointCache[0].set(leg.calculated.endLat, leg.calculated.endLon);
            const dtoCourseTrue = msfssdk.MagVar.magneticToTrue(leg.leg.course, dtoFix.lat, dtoFix.lon);
            const dtoPath = FlightPathDirectToCourseLegRenderer.geoCircleCache[0].setAsGreatCircle(dtoFix, dtoCourseTrue);
            const start = dtoPath.offsetDistanceAlong(dtoFix, msfssdk.UnitType.NMILE.convertTo(-500, msfssdk.UnitType.GA_RADIAN), FlightPathDirectToCourseLegRenderer.geoPointCache[1]);
            this.lineRenderer.render(dtoPath, start.lat, start.lon, dtoFix.lat, dtoFix.lon, context, streamStack, width, style, dash);
        }
    }
    FlightPathDirectToCourseLegRenderer.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
    FlightPathDirectToCourseLegRenderer.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];
    /**
     * Renders OBS legs. Each leg is rendered as two lines: a magenta 500-nautical mile great-circle path along the OBS
     * course terminating at the end of the leg, and a white 500-nautical mile great-circle path along the OBS course
     * starting at the end of the leg.
     */
    class FlightPathObsLegRenderer {
        constructor() {
            this.lineRenderer = new msfssdk.GeoCircleLineRenderer();
        }
        /**
         * Renders an OBS leg to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param course The OBS course, in degrees magnetic.
         */
        render(leg, context, streamStack, course) {
            var _a, _b;
            if (((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) === undefined || ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) === undefined) {
                return;
            }
            const obsFix = FlightPathObsLegRenderer.geoPointCache[0].set(leg.calculated.endLat, leg.calculated.endLon);
            const obsLat = obsFix.lat;
            const obsLon = obsFix.lon;
            const obsCourseTrue = msfssdk.MagVar.magneticToTrue(course, obsLat, obsLon);
            const obsPath = FlightPathObsLegRenderer.geoCircleCache[0].setAsGreatCircle(obsFix, obsCourseTrue);
            const start = obsPath.offsetDistanceAlong(obsFix, msfssdk.UnitType.NMILE.convertTo(-500, msfssdk.UnitType.GA_RADIAN), FlightPathObsLegRenderer.geoPointCache[1]);
            const startLat = start.lat;
            const startLon = start.lon;
            const end = obsPath.offsetDistanceAlong(obsFix, msfssdk.UnitType.NMILE.convertTo(500, msfssdk.UnitType.GA_RADIAN), FlightPathObsLegRenderer.geoPointCache[1]);
            const endLat = end.lat;
            const endLon = end.lon;
            this.lineRenderer.render(obsPath, startLat, startLon, obsLat, obsLon, context, streamStack, 4, 'magenta');
            this.lineRenderer.render(obsPath, obsLat, obsLon, endLat, endLon, context, streamStack, 4, 'white');
        }
    }
    FlightPathObsLegRenderer.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
    FlightPathObsLegRenderer.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];
    /**
     * Renders vectors-to-final legs. Each leg is rendered as a line representing a 30-nautical mile great-circle path
     * along the VTF course terminating at the end of the leg.
     */
    class FlightPathVtfLegRenderer {
        constructor() {
            this.lineRenderer = new msfssdk.GeoCircleLineRenderer();
        }
        /**
         * Renders a vectors-to-final leg to a canvas.
         * @param leg The leg to render.
         * @param context The canvas 2D rendering context to which to render.
         * @param streamStack The path stream stack to which to render.
         * @param width The width of the rendered line.
         * @param style The style of the rendered line.
         * @param dash The dash array of the rendered line. Defaults to no dash.
         */
        render(leg, context, streamStack, width, style, dash) {
            var _a;
            const vector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[0];
            if (!vector) {
                return;
            }
            const vectorCircle = msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVtfLegRenderer.geoCircleCache[0]);
            const end = FlightPathVtfLegRenderer.geoPointCache[0].set(vector.endLat, vector.endLon);
            const start = vectorCircle.offsetDistanceAlong(end, msfssdk.UnitType.NMILE.convertTo(-30, msfssdk.UnitType.GA_RADIAN), FlightPathVtfLegRenderer.geoPointCache[1]);
            this.lineRenderer.render(vectorCircle, start.lat, start.lon, end.lat, end.lon, context, streamStack, width, style, dash);
        }
    }
    FlightPathVtfLegRenderer.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
    FlightPathVtfLegRenderer.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];

    /**
     * The default base-route flight plan renderer for Garmin maps. Only renders non-transition flight path vectors within
     * flight plan legs.
     */
    class DefaultBaseFlightPathPlanRenderer extends msfssdk.AbstractFlightPathPlanRenderer {
        constructor() {
            super(...arguments);
            this.lineRenderer = new msfssdk.FlightPathLegLineRenderer(this.selectLineStyle.bind(this));
            this.dtoCourseRenderer = new FlightPathDirectToCourseLegRenderer();
            this.vtfRenderer = new FlightPathVtfLegRenderer();
        }
        /** @inheritdoc */
        renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
            if (!msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo) || legIndex === activeLegIndex) {
                switch (leg.leg.type) {
                    case msfssdk.LegType.HF:
                    case msfssdk.LegType.HM:
                    case msfssdk.LegType.HA:
                    case msfssdk.LegType.PI:
                        break;
                    case msfssdk.LegType.CF:
                        if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo)) {
                            this.dtoCourseRenderer.render(leg, context, streamStack, MapFlightPathStyles.BASE_STROKE_WIDTH, MapFlightPathStyles.BASE_STROKE_COLOR);
                            break;
                        }
                        else if (msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                            this.vtfRenderer.render(leg, context, streamStack, MapFlightPathStyles.BASE_STROKE_WIDTH, MapFlightPathStyles.BASE_STROKE_COLOR);
                            break;
                        }
                    // TODO: draw correct base for fallback CF legs.
                    // eslint-disable-next-line no-fallthrough
                    default:
                        this.lineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.Base);
                }
            }
        }
        /**
         * Selects a line style to render for a vector.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @returns The selected line style for the vector.
         */
        selectLineStyle(vector, isIngress, isEgress, leg, projection, out) {
            if (this.isRollHeadingVector(vector, leg)) {
                out.strokeWidth = 0;
            }
            else {
                out.strokeWidth = MapFlightPathStyles.BASE_STROKE_WIDTH;
                out.strokeStyle = MapFlightPathStyles.BASE_STROKE_COLOR;
            }
            out.outlineWidth = 0;
            out.isContinuous = true;
            return out;
        }
        /**
         * Checks if a flight path vector should be styled as a roll-heading vector.
         * @param vector A flight path vector.
         * @param leg The flight plan leg to which the vector belongs.
         * @returns Whether the flight path vector should be styled as a roll-heading vector.
         */
        isRollHeadingVector(vector, leg) {
            if (msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.Fallback)) {
                return true;
            }
            switch (leg.leg.type) {
                case msfssdk.LegType.CF:
                    return msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.InterceptCourse | msfssdk.FlightPathVectorFlags.Direct);
                default:
                    return false;
            }
        }
    }
    /**
     * The default full-route flight plan renderer for Garmin maps. Renders all flight path vectors within flight plan legs,
     * including transition vectors.
     */
    class DefaultFullFlightPathPlanRenderer extends msfssdk.AbstractFlightPathPlanRenderer {
        constructor() {
            super(...arguments);
            this.defaultRenderer = new FlightPathDefaultLegRenderer();
            this.holdRenderer = new FlightPathHoldLegRenderer();
            this.procTurnRenderer = new FlightPathProcTurnLegRenderer();
            this.dtoCourseRenderer = new FlightPathDirectToCourseLegRenderer();
            this.vtfRenderer = new FlightPathVtfLegRenderer();
        }
        /** @inheritdoc */
        renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack, lnavData, isMissedApproachActive) {
            var _a, _b;
            switch (leg.leg.type) {
                case msfssdk.LegType.HF:
                case msfssdk.LegType.HM:
                case msfssdk.LegType.HA:
                    this.holdRenderer.render(leg, context, streamStack, plan, activeLeg, legIndex, activeLegIndex, lnavData);
                    break;
                case msfssdk.LegType.PI:
                    this.procTurnRenderer.render(leg, context, streamStack, plan, activeLeg, legIndex, activeLegIndex);
                    break;
                case msfssdk.LegType.CF: {
                    let width, style;
                    if (legIndex === activeLegIndex) {
                        width = MapFlightPathStyles.ACTIVE_STROKE_WIDTH;
                        style = MapFlightPathStyles.ACTIVE_STROKE_COLOR;
                    }
                    else if (legIndex < activeLegIndex) {
                        width = MapFlightPathStyles.PRIOR_STROKE_WIDTH;
                        style = MapFlightPathStyles.PRIOR_STROKE_COLOR;
                    }
                    else if (!isMissedApproachActive && msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                        width = MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH;
                        style = MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR;
                    }
                    else {
                        width = MapFlightPathStyles.STROKE_WIDTH;
                        style = MapFlightPathStyles.STROKE_COLOR;
                    }
                    if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo)) {
                        this.dtoCourseRenderer.render(leg, context, streamStack, width, style);
                        break;
                    }
                    else if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                        this.vtfRenderer.render(leg, context, streamStack, width, style);
                        break;
                    }
                }
                // eslint-disable-next-line no-fallthrough
                default:
                    this.defaultRenderer.render(leg, context, streamStack, legIndex, activeLegIndex, (_a = plan.tryGetLeg(legIndex - 1)) !== null && _a !== void 0 ? _a : undefined, (_b = plan.tryGetLeg(legIndex + 1)) !== null && _b !== void 0 ? _b : undefined, isMissedApproachActive);
            }
        }
    }
    /**
     * The default flight plan renderer for Garmin maps.
     */
    class DefaultFlightPathPlanRenderer {
        constructor() {
            this.baseRouteRenderer = new DefaultBaseFlightPathPlanRenderer();
            this.fullRouteRenderer = new DefaultFullFlightPathPlanRenderer();
            this.obsRenderer = new FlightPathObsLegRenderer();
        }
        /** @inheritdoc */
        render(plan, context, streamStack, renderEntirePlan, activeLegIndex, lnavData, obsCourse) {
            const isObsActive = obsCourse !== undefined;
            const baseRouteStartIndex = this.getBaseRouteStartIndex(plan, renderEntirePlan, activeLegIndex, isObsActive);
            this.baseRouteRenderer.render(plan, baseRouteStartIndex, undefined, context, streamStack);
            if (isObsActive) {
                this.obsRenderer.render(plan.getLeg(activeLegIndex), context, streamStack, obsCourse);
            }
            else {
                const fullRouteStartIndex = this.getFullRouteStartIndex(plan, renderEntirePlan, activeLegIndex);
                const isMissedApproachActive = activeLegIndex >= 0
                    && activeLegIndex < plan.length
                    && msfssdk.BitFlags.isAny(plan.getLeg(activeLegIndex).flags, msfssdk.LegDefinitionFlags.MissedApproach);
                this.fullRouteRenderer.render(plan, fullRouteStartIndex, undefined, context, streamStack, lnavData, isMissedApproachActive);
            }
        }
        /**
         * Gets the global index of the first leg for which to render the base route.
         * @param plan The flight plan to render.
         * @param renderEntirePlan Whether to render the entire plan.
         * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
         * @param isObsActive Whether OBS is active.
         * @returns The global index of the first leg for which to render the base route.
         */
        getBaseRouteStartIndex(plan, renderEntirePlan, activeLegIndex, isObsActive) {
            if (renderEntirePlan) {
                return 0;
            }
            if (activeLegIndex < 0) {
                return plan.length;
            }
            if (isObsActive) {
                return activeLegIndex;
            }
            return Math.max(0, this.getActiveFromLegIndex(plan, activeLegIndex));
        }
        /**
         * Gets the global index of the first leg for which to render the full route.
         * @param plan The flight plan to render.
         * @param renderEntirePlan Whether to render the entire plan.
         * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
         * @returns The global index of the first leg for which to render the full route.
         */
        getFullRouteStartIndex(plan, renderEntirePlan, activeLegIndex) {
            if (renderEntirePlan) {
                return 0;
            }
            if (activeLegIndex < 0) {
                return plan.length;
            }
            return Math.max(0, this.getActiveFromLegIndex(plan, activeLegIndex));
        }
        /**
         * Gets the global index of the leg from which the active leg of a flight plan originates.
         * @param plan A flight plan.
         * @param activeLegIndex The global index of the active flight plan leg.
         * @returns The global index of the leg from which the active leg originates, or -1 if one could not be found.
         */
        getActiveFromLegIndex(plan, activeLegIndex) {
            const activeLeg = plan.tryGetLeg(activeLegIndex);
            if (!activeLeg) {
                return -1;
            }
            const segmentIndex = plan.getSegmentIndex(activeLegIndex);
            const segmentLegIndex = activeLegIndex - plan.getSegment(segmentIndex).offset;
            return FmsUtils.getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex);
        }
    }

    /**
     * Calculates map projection parameters to fit flight plan foci.
     */
    class MapFlightPlanFocusCalculator {
        /**
         * Constructor.
         * @param mapProjection This calculator's map projection.
         */
        constructor(mapProjection) {
            this.mapProjection = mapProjection;
            this.tempProjection = new msfssdk.MapProjection(100, 100);
        }
        /**
         * Calculates a maximum range and target center for a given flight plan focus such that the terminators of all legs
         * in the focus are visible in this calculator's map projection. If there is only one leg terminator in the specified
         * focus, the calculated range will be equal to 0. If a range and target could not be calculated, NaN will be written
         * to the results.
         * @param focus The array of legs on which to focus.
         * @param margins The margins around the projected map boundaries to respect. Expressed as [left, top, right, bottom].
         * @param ppos The current position of the airplane.
         * @param out The object to which to write the results.
         * @returns The calculated range and target for the specified focus.
         */
        calculateRangeTarget(focus, margins, ppos, out) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            out.range = NaN;
            out.target.set(NaN, NaN);
            if (!focus) {
                return out;
            }
            if (!(focus instanceof Array)) {
                out.range = 0;
                out.target.set(focus);
                return out;
            }
            focus = focus;
            const targetWidth = this.mapProjection.getProjectedSize()[0] - margins[0] - margins[2];
            const targetHeight = this.mapProjection.getProjectedSize()[1] - margins[1] - margins[3];
            if (targetWidth * targetHeight <= 0) {
                return out;
            }
            let minX;
            let minY;
            let maxX;
            let maxY;
            let currentLat = NaN;
            let currentLon = NaN;
            const len = focus.length;
            for (let i = 0; i < len; i++) {
                const leg = focus[i];
                let projected = MapFlightPlanFocusCalculator.vec2Cache[0];
                if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo) && leg.leg.type === msfssdk.LegType.CF) {
                    // Special case for Direct-To legs with user-defined course: PPOS needs to be in focus instead of the start
                    // of the leg (which is arbitrary)
                    if (isNaN(ppos.lat) || isNaN(ppos.lon)) {
                        projected = undefined;
                    }
                    else {
                        currentLat = ppos.lat;
                        currentLon = ppos.lon;
                        this.mapProjection.project(ppos, projected);
                    }
                }
                else {
                    if (((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) !== undefined && ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.startLon) !== undefined
                        && ((_c = leg.calculated) === null || _c === void 0 ? void 0 : _c.startLat) !== currentLat && ((_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.startLon) !== currentLon) {
                        currentLat = leg.calculated.startLat;
                        currentLon = leg.calculated.startLon;
                        this.mapProjection.project(MapFlightPlanFocusCalculator.geoPointCache[0].set(currentLat, currentLon), projected);
                    }
                    else {
                        projected = undefined;
                    }
                }
                if (projected) {
                    minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
                    minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
                    maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
                    maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
                }
                projected = MapFlightPlanFocusCalculator.vec2Cache[0];
                if (((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.endLat) !== undefined && ((_f = leg.calculated) === null || _f === void 0 ? void 0 : _f.endLon) !== undefined
                    && ((_g = leg.calculated) === null || _g === void 0 ? void 0 : _g.endLat) !== currentLat && ((_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.endLon) !== currentLon) {
                    currentLat = leg.calculated.endLat;
                    currentLon = leg.calculated.endLon;
                    this.mapProjection.project(MapFlightPlanFocusCalculator.geoPointCache[0].set(currentLat, currentLon), projected);
                    minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
                    minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
                    maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
                    maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
                }
            }
            if (minX === undefined || minY === undefined || maxX === undefined || maxY === undefined) {
                return out;
            }
            let focusWidth = maxX - minX;
            let focusHeight = maxY - minY;
            this.mapProjection.invert(msfssdk.Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFlightPlanFocusCalculator.vec2Cache[0]), out.target);
            if (focusWidth === 0 && focusHeight === 0) {
                out.range = 0;
                return out;
            }
            let widthRatio = focusWidth / targetWidth;
            let heightRatio = focusHeight / targetHeight;
            let constrainedRatio = Math.max(widthRatio, heightRatio);
            const range = out.range = this.mapProjection.getRange();
            const topLeft = this.mapProjection.invert(msfssdk.Vec2Math.set(minX, minY, MapFlightPlanFocusCalculator.vec2Cache[0]), MapFlightPlanFocusCalculator.geoPointCache[0]);
            const bottomRight = this.mapProjection.invert(msfssdk.Vec2Math.set(maxX, maxY, MapFlightPlanFocusCalculator.vec2Cache[0]), MapFlightPlanFocusCalculator.geoPointCache[1]);
            this.tempProjection.set({
                projectedSize: this.mapProjection.getProjectedSize(),
                rotation: this.mapProjection.getRotation(),
                target: out.target,
                range,
                rangeEndpoints: this.mapProjection.getRangeEndpoints()
            });
            // Iteratively solve for exact range
            let iterCount = 0;
            const rangeParam = { range };
            let ratioError = Math.abs(constrainedRatio - 1);
            let deltaRatioError = MapFlightPlanFocusCalculator.RANGE_TOLERANCE + 1;
            while (iterCount++ < MapFlightPlanFocusCalculator.MAX_ITER
                && ratioError > MapFlightPlanFocusCalculator.RANGE_TOLERANCE
                && deltaRatioError > MapFlightPlanFocusCalculator.RANGE_TOLERANCE) {
                rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
                if (out.range <= msfssdk.GeoPoint.EQUALITY_TOLERANCE) {
                    // if the estimated range is too small, iteratively solving for the range will be unreliable due to floating
                    // point errors
                    out.range = msfssdk.GeoPoint.EQUALITY_TOLERANCE;
                    return out;
                }
                this.tempProjection.set(rangeParam);
                const topLeftProjected = this.tempProjection.project(topLeft, MapFlightPlanFocusCalculator.vec2Cache[0]);
                const bottomRightProjected = this.tempProjection.project(bottomRight, MapFlightPlanFocusCalculator.vec2Cache[1]);
                focusWidth = bottomRightProjected[0] - topLeftProjected[0];
                focusHeight = bottomRightProjected[1] - topLeftProjected[1];
                widthRatio = focusWidth / targetWidth;
                heightRatio = focusHeight / targetHeight;
                constrainedRatio = Math.max(widthRatio, heightRatio);
                const newRatioError = Math.abs(constrainedRatio - 1);
                deltaRatioError = Math.abs(newRatioError - ratioError);
                ratioError = newRatioError;
            }
            return out;
        }
    }
    MapFlightPlanFocusCalculator.MAX_ITER = 20;
    MapFlightPlanFocusCalculator.RANGE_TOLERANCE = 0.01;
    MapFlightPlanFocusCalculator.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
    MapFlightPlanFocusCalculator.vec2Cache = [new Float64Array(2), new Float64Array(2)];

    /**
     * An abstract implementation of FlightPlanLegWaypointsRecord.
     */
    class AbstractFlightPlanLegWaypointsRecord {
        /**
         * Constructor.
         * @param leg The flight plan leg associated with this record.
         * @param waypointRenderer The renderer used to render this record's waypoints.
         * @param facLoader The facility loader used by this waypoint.
         * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
         * leg.
         * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
         * leg.
         */
        constructor(leg, waypointRenderer, facLoader, inactiveRenderRole, activeRenderRole) {
            this.leg = leg;
            this.waypointRenderer = waypointRenderer;
            this.facLoader = facLoader;
            this.inactiveRenderRole = inactiveRenderRole;
            this.activeRenderRole = activeRenderRole;
            this.uid = `flightplan-wptrecord-${AbstractFlightPlanLegWaypointsRecord.uidSource++}`;
            this.isActive = false;
        }
        /**
         * Registers a waypoint with this record's waypoint renderer.
         * @param waypoint A waypoint.
         * @param role The role(s) under which the waypoint should be registered.
         */
        registerWaypoint(waypoint, role) {
            this.waypointRenderer.register(waypoint, role, this.uid);
        }
        /**
         * Removes a registration for a waypoint from this record's waypoint renderer.
         * @param waypoint A waypoint.
         * @param role The role(s) from which the waypoint should be deregistered.
         */
        deregisterWaypoint(waypoint, role) {
            this.waypointRenderer.deregister(waypoint, role, this.uid);
        }
    }
    AbstractFlightPlanLegWaypointsRecord.uidSource = 0;
    /**
     * A record with a single waypoint based on its flight plan leg's fixIcao property.
     */
    class FixIcaoWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
        /**
         * Constructor.
         * @param leg The flight plan leg associated with this record.
         * @param waypointRenderer The renderer used to render this record's waypoints.
         * @param facLoader The facility loader used by this waypoint.
         * @param facWaypointCache The facility waypoint cache used by this record.
         * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
         * leg.
         * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
         * leg.
         */
        constructor(leg, waypointRenderer, facLoader, facWaypointCache, inactiveRenderRole, activeRenderRole) {
            super(leg, waypointRenderer, facLoader, inactiveRenderRole, activeRenderRole);
            this.facWaypointCache = facWaypointCache;
            this._waypoint = null;
        }
        // eslint-disable-next-line jsdoc/require-returns
        /**
         * This record's waypoint.
         */
        get waypoint() {
            return this._waypoint;
        }
        /** @inheritdoc */
        async refresh(isActive) {
            const icao = this.leg.leg.fixIcao;
            if (!this._waypoint && icao !== '' && icao !== msfssdk.ICAO.emptyIcao) {
                this._waypoint = await this.getFacilityWaypoint(icao);
                if (this._waypoint) {
                    this.registerWaypoint(this._waypoint, this.inactiveRenderRole);
                    if (this.isActive) {
                        this.registerWaypoint(this._waypoint, this.activeRenderRole);
                    }
                }
            }
            if (isActive !== this.isActive) {
                if (this._waypoint) {
                    isActive
                        ? this.registerWaypoint(this._waypoint, this.activeRenderRole)
                        : this.deregisterWaypoint(this._waypoint, this.activeRenderRole);
                }
                this.isActive = isActive;
            }
        }
        /**
         * Gets a facility waypoint from an ICAO string.
         * @param icao A facility ICAO string.
         * @returns a facility waypoint, or null if one could not be created.
         */
        async getFacilityWaypoint(icao) {
            try {
                const facility = await this.facLoader.getFacility(msfssdk.ICAO.getFacilityType(icao), icao);
                return this.facWaypointCache.get(facility);
            }
            catch (e) {
                // noop
            }
            return null;
        }
        /** @inheritdoc */
        destroy() {
            if (!this._waypoint) {
                return;
            }
            this.deregisterWaypoint(this._waypoint, this.inactiveRenderRole);
            this.isActive && this.deregisterWaypoint(this._waypoint, this.activeRenderRole);
        }
    }
    /**
     * A record with a single flight path waypoint representing its flight plan leg's terminator fix.
     */
    class FlightPathTerminatorWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
        constructor() {
            super(...arguments);
            this.id = FlightPathTerminatorWaypointsRecord.id++;
            this._waypoint = null;
        }
        // eslint-disable-next-line jsdoc/require-returns
        /**
         * This record's flight path waypoint.
         */
        get waypoint() {
            return this._waypoint;
        }
        /** @inheritdoc */
        async refresh(isActive) {
            var _a, _b, _c;
            const lastVector = (_a = this.leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[this.leg.calculated.flightPath.length - 1];
            if (lastVector) {
                (_b = this._waypointLocation) !== null && _b !== void 0 ? _b : (this._waypointLocation = msfssdk.GeoPointSubject.createFromGeoPoint(new msfssdk.GeoPoint(0, 0)));
                this._waypointLocation.set(lastVector.endLat, lastVector.endLon);
                if (!this._waypoint) {
                    const ident = (_c = this.leg.name) !== null && _c !== void 0 ? _c : '';
                    this._waypoint = new msfssdk.FlightPathWaypoint(this._waypointLocation, `${msfssdk.FlightPathWaypoint.UID_PREFIX}_${ident}_${this.id}`, ident);
                    this.registerWaypoint(this._waypoint, this.inactiveRenderRole);
                    if (this.isActive) {
                        this.registerWaypoint(this._waypoint, this.activeRenderRole);
                    }
                }
            }
            else {
                this.cleanUpWaypoint();
            }
            if (isActive !== this.isActive) {
                if (this._waypoint) {
                    isActive
                        ? this.registerWaypoint(this._waypoint, this.activeRenderRole)
                        : this.deregisterWaypoint(this._waypoint, this.activeRenderRole);
                }
                this.isActive = isActive;
            }
        }
        /** @inheritdoc */
        destroy() {
            this.cleanUpWaypoint();
        }
        /**
         * Deregisters this record's waypoint, if it exists, from the waypoint renderer.
         */
        cleanUpWaypoint() {
            if (!this._waypoint) {
                return;
            }
            this.deregisterWaypoint(this._waypoint, this.inactiveRenderRole);
            this.isActive && this.deregisterWaypoint(this._waypoint, this.activeRenderRole);
        }
    }
    FlightPathTerminatorWaypointsRecord.id = 0;
    /**
     * A record for procedure turn (PI) legs. Maintains two waypoints, both located at the PI leg's origin fix. The first
     * waypoint is a standard FacilityWaypoint which is never rendered in an active flight plan waypoint role. The second
     * is a ProcedureTurnWaypoint with an ident string equal to the PI leg's given name and which can be rendered in an
     * active flight plan waypoint role.
     */
    class ProcedureTurnLegWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
        /**
         * Constructor.
         * @param leg The flight plan leg associated with this record.
         * @param waypointRenderer The renderer used to render this record's waypoints.
         * @param facLoader The facility loader used by this waypoint.
         * @param facWaypointCache The facility waypoint cache used by this record.
         * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
         * leg.
         * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
         * leg.
         */
        constructor(leg, waypointRenderer, facLoader, facWaypointCache, inactiveRenderRole, activeRenderRole) {
            super(leg, waypointRenderer, facLoader, inactiveRenderRole, activeRenderRole);
            this.ptWaypoint = null;
            this.fixIcaoRecord = new FixIcaoWaypointsRecord(leg, waypointRenderer, facLoader, facWaypointCache, inactiveRenderRole, activeRenderRole);
        }
        /** @inheritdoc */
        async refresh(isActive) {
            var _a;
            await this.fixIcaoRecord.refresh(false);
            if (!this.ptWaypoint && this.fixIcaoRecord.waypoint) {
                this.ptWaypoint = new ProcedureTurnLegWaypoint(this.fixIcaoRecord.waypoint, (_a = this.leg.name) !== null && _a !== void 0 ? _a : '');
                this.registerWaypoint(this.ptWaypoint, this.inactiveRenderRole);
                if (this.isActive) {
                    this.deregisterWaypoint(this.ptWaypoint, this.activeRenderRole);
                }
            }
            if (isActive !== this.isActive) {
                if (this.ptWaypoint) {
                    isActive
                        ? this.registerWaypoint(this.ptWaypoint, this.activeRenderRole)
                        : this.deregisterWaypoint(this.ptWaypoint, this.activeRenderRole);
                }
                this.isActive = isActive;
            }
        }
        /** @inheritdoc */
        destroy() {
            this.fixIcaoRecord.destroy();
            if (!this.ptWaypoint) {
                return;
            }
            this.deregisterWaypoint(this.ptWaypoint, this.inactiveRenderRole);
            this.isActive && this.deregisterWaypoint(this.ptWaypoint, this.activeRenderRole);
        }
    }
    /**
     * A waypoint marking a procedure turn leg.
     */
    class ProcedureTurnLegWaypoint extends msfssdk.CustomWaypoint {
        /**
         * Constructor.
         * @param waypoint The facility waypoint marking this waypoint's location.
         * @param ident The ident string of this waypoint.
         */
        constructor(waypoint, ident) {
            super(waypoint.location, `${ProcedureTurnLegWaypoint.UID_PREFIX}_${ident}_${waypoint.facility.get().icao}`);
            this.ident = ident;
        }
    }
    ProcedureTurnLegWaypoint.UID_PREFIX = 'PI';

    /**
     * Manages flight plan waypoint records.
     */
    class MapFlightPlanWaypointRecordManager {
        /**
         * Constructor.
         * @param facLoader This manager's facility loader.
         * @param facWaypointCache This manager's facility waypoint cache.
         * @param waypointRenderer This manager's waypoint renderer.
         * @param inactiveRenderRole The role(s) under which waypoints should be registered when they are part of an inactive
         * leg.
         * @param activeRenderRole The role(s) under which waypoints should be registered when they are part of an active
         * leg.
         */
        constructor(facLoader, facWaypointCache, waypointRenderer, inactiveRenderRole, activeRenderRole) {
            this.facLoader = facLoader;
            this.facWaypointCache = facWaypointCache;
            this.waypointRenderer = waypointRenderer;
            this.inactiveRenderRole = inactiveRenderRole;
            this.activeRenderRole = activeRenderRole;
            this.legWaypointRecords = new Map();
            this._isBusy = false;
        }
        /**
         * Checks whether this manager is busy with a waypoint refresh.
         * @returns Whether this manager is busy with a waypoint refresh.
         */
        isBusy() {
            return this._isBusy;
        }
        // eslint-disable-next-line jsdoc/require-throws
        /**
         * Refreshes this manager's waypoint records, keeping them up to date with a specified flight plan.
         * @param flightPlan A flight plan.
         * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
         * @param repick Whether to repick waypoints.
         * @param startIndex The global index of the first flight plan leg from which to pick waypoints, inclusive. Defaults
         * to 0. Ignored if `repick` is false.
         * @param endIndex The global index of the last flight plan leg from which to pick waypoints, inclusive. Defaults to
         * `flightPlan.length - 1`. Ignored if `repick` is false.
         */
        async refreshWaypoints(flightPlan, activeLegIndex, repick, startIndex, endIndex) {
            if (this._isBusy) {
                throw new Error('MapFlightPlanWaypointRecordManager: cannot refresh waypoints while busy');
            }
            this._isBusy = true;
            if (!flightPlan) {
                // Remove all waypoint records.
                for (const record of this.legWaypointRecords.values()) {
                    record.destroy();
                }
                this.legWaypointRecords.clear();
                this._isBusy = false;
                return;
            }
            const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
            if (repick) {
                startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
                endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = flightPlan.length - 1);
                const legsToDisplay = new Set();
                // Gather all legs to display.
                let legIndex = startIndex;
                for (const leg of flightPlan.legs(false, startIndex)) {
                    if (legIndex > endIndex) {
                        break;
                    }
                    if (!msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.DirectTo | msfssdk.LegDefinitionFlags.VectorsToFinal) || legIndex === flightPlan.activeLateralLeg) {
                        legsToDisplay.add(leg);
                    }
                    legIndex++;
                }
                // Remove records of legs that are no longer in the set of legs to display.
                for (const record of this.legWaypointRecords.values()) {
                    if (legsToDisplay.has(record.leg)) {
                        legsToDisplay.delete(record.leg);
                    }
                    else {
                        record.destroy();
                        this.legWaypointRecords.delete(record.leg);
                    }
                }
                // Create new records for legs to display that don't already have records.
                for (const leg of legsToDisplay) {
                    const record = this.createLegWaypointsRecord(leg);
                    this.legWaypointRecords.set(leg, record);
                }
            }
            const waypointRefreshes = [];
            for (const record of this.legWaypointRecords.values()) {
                waypointRefreshes.push(record.refresh(record.leg === activeLeg));
            }
            await Promise.all(waypointRefreshes);
            this._isBusy = false;
        }
        /**
         * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
         * @param leg A flight plan leg.
         * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
         */
        createLegWaypointsRecord(leg) {
            switch (leg.leg.type) {
                case msfssdk.LegType.CD:
                case msfssdk.LegType.VD:
                case msfssdk.LegType.CR:
                case msfssdk.LegType.VR:
                case msfssdk.LegType.FC:
                case msfssdk.LegType.FD:
                case msfssdk.LegType.FA:
                case msfssdk.LegType.CA:
                case msfssdk.LegType.VA:
                case msfssdk.LegType.FM:
                case msfssdk.LegType.VM:
                case msfssdk.LegType.CI:
                case msfssdk.LegType.VI:
                    return new FlightPathTerminatorWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.inactiveRenderRole, this.activeRenderRole);
                case msfssdk.LegType.PI:
                    return new ProcedureTurnLegWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.facWaypointCache, this.inactiveRenderRole, this.activeRenderRole);
                default:
                    return new FixIcaoWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.facWaypointCache, this.inactiveRenderRole, this.activeRenderRole);
            }
        }
    }

    /**
     * A {@link MapFlightPlanDataProvider} which provides data for a standalone flight plan not owned by a flight planner.
     */
    class MapStandaloneFlightPlanPlanDataProvider {
        /**
         * Constructor.
         * @param plan A subscribable which provides the flight plan for this data provider.
         */
        constructor(plan) {
            this.plan = plan;
            this.planModified = new msfssdk.SubEvent();
            this.planCalculated = new msfssdk.SubEvent();
            this._activeLateralLegIndex = msfssdk.Subject.create(0);
            this.activeLateralLegIndex = this._activeLateralLegIndex;
            this.lnavData = msfssdk.Subject.create(undefined);
            this.vnavState = msfssdk.Subject.create(msfssdk.VNavState.Disabled);
            this.vnavPathMode = msfssdk.Subject.create(msfssdk.VNavPathMode.None);
            this.vnavTodLegIndex = msfssdk.Subject.create(-1);
            this.vnavBodLegIndex = msfssdk.Subject.create(-1);
            this.vnavTodLegDistance = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.METER.createNumber(0));
            this.vnavDistanceToTod = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.METER.createNumber(0));
            this.obsCourse = msfssdk.Subject.create(undefined);
            this.oldPlan = null;
            plan.sub(flightPlan => {
                if (this.oldPlan !== null) {
                    this.oldPlan.events.onActiveLegChanged = undefined;
                    this.oldPlan.events.onCalculated = undefined;
                }
                if (flightPlan !== null) {
                    this._activeLateralLegIndex.set(flightPlan.activeLateralLeg);
                    flightPlan.events.onActiveLegChanged = (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => {
                        if (type === msfssdk.ActiveLegType.Lateral) {
                            this._activeLateralLegIndex.set(index);
                        }
                    };
                    flightPlan.events.onCalculated = () => {
                        this.planCalculated.notify(this);
                    };
                }
                else {
                    this._activeLateralLegIndex.set(0);
                }
            }, true);
        }
    }

    /**
     * The full-route renderer for procedure preview flight plan paths. Renders all flight path vectors within flight plan
     * legs, including transition vectors, with support for different styles for procedure and transition previews.
     */
    class ProcMapFullFlightPathPlanRenderer extends msfssdk.AbstractFlightPathPlanRenderer {
        constructor() {
            super(...arguments);
            this.lineRenderer = new FlightPathLegContinuousLineRenderer();
            this.defaultRenderer = new FlightPathDefaultLegRenderer();
            this.defaultTransitionRenderer = new msfssdk.FlightPathLegLineRenderer(this.selectTransitionLineStyle.bind(this));
            this.holdRenderer = new FlightPathHoldLegRenderer();
            this.procTurnRenderer = new FlightPathProcTurnLegRenderer();
            this.vtfRenderer = new FlightPathVtfLegRenderer();
        }
        /** @inheritdoc */
        renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack, isTransition) {
            var _a, _b;
            let width, style;
            if (msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                width = MapFlightPathStyles.MISSED_APPROACH_STROKE_WIDTH;
                style = MapFlightPathStyles.MISSED_APPROACH_STROKE_COLOR;
            }
            else if (isTransition) {
                width = MapFlightPathStyles.TRANSITION_STROKE_WIDTH;
                style = MapFlightPathStyles.TRANSITION_STROKE_COLOR;
            }
            else {
                width = MapFlightPathStyles.STROKE_WIDTH;
                style = MapFlightPathStyles.STROKE_COLOR;
            }
            switch (leg.leg.type) {
                case msfssdk.LegType.HF:
                case msfssdk.LegType.HM:
                case msfssdk.LegType.HA:
                    if (isTransition) {
                        this.lineRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.Base, width, style);
                    }
                    else {
                        this.holdRenderer.render(leg, context, streamStack, plan, activeLeg, legIndex, -1, undefined);
                    }
                    break;
                case msfssdk.LegType.PI:
                    this.procTurnRenderer.render(leg, context, streamStack, plan, activeLeg, legIndex, -1);
                    break;
                case msfssdk.LegType.CF:
                    if (msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                        this.vtfRenderer.render(leg, context, streamStack, width, style);
                        break;
                    }
                // eslint-disable-next-line no-fallthrough
                default:
                    if (isTransition) {
                        this.defaultTransitionRenderer.render(leg, context, streamStack, msfssdk.FlightPathLegRenderPart.All);
                    }
                    else {
                        this.defaultRenderer.render(leg, context, streamStack, legIndex, activeLegIndex, (_a = plan.tryGetLeg(legIndex - 1)) !== null && _a !== void 0 ? _a : undefined, (_b = plan.tryGetLeg(legIndex + 1)) !== null && _b !== void 0 ? _b : undefined, false);
                    }
            }
        }
        /**
         * Selects a line style for a vector in a transition preview leg.
         * @param vector The vector for which to select a style.
         * @param isIngress Whether the vector is part of the ingress transition.
         * @param isEgress Whether the vector is part of the egress transition.
         * @param leg The flight plan leg containing the vector to render.
         * @param projection The map projection to use when rendering.
         * @param out The line style object to which to write the selected style.
         * @returns The selected line style for the vector.
         */
        selectTransitionLineStyle(vector, isIngress, isEgress, leg, projection, out) {
            if (msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.Fallback)) {
                out.strokeWidth = 0;
            }
            else {
                out.strokeWidth = MapFlightPathStyles.TRANSITION_STROKE_WIDTH;
                out.strokeStyle = MapFlightPathStyles.TRANSITION_STROKE_COLOR;
                if (this.isRollHeadingVector(vector, leg)) {
                    out.strokeDash = MapFlightPathStyles.ROLL_HEADING_DASH_ARRAY;
                }
                else {
                    out.strokeDash = null;
                }
            }
            out.outlineWidth = 0;
            out.isContinuous = true;
            return out;
        }
        /**
         * Checks if a flight path vector in a transition preview leg should be styled as a roll-heading vector.
         * @param vector A flight path vector in a transition preview leg.
         * @param leg The flight plan leg to which the vector belongs.
         * @returns Whether the flight path vector should be styled as a roll-heading vector.
         */
        isRollHeadingVector(vector, leg) {
            switch (leg.leg.type) {
                case msfssdk.LegType.CF:
                    return msfssdk.BitFlags.isAny(vector.flags, msfssdk.FlightPathVectorFlags.InterceptCourse | msfssdk.FlightPathVectorFlags.Direct);
                default:
                    return false;
            }
        }
    }
    /**
     * The default procedure preview renderer for Garmin maps.
     */
    class ProcMapFlightPathPlanRenderer {
        constructor() {
            this.baseRouteRenderer = new DefaultBaseFlightPathPlanRenderer();
            this.fullRouteRenderer = new ProcMapFullFlightPathPlanRenderer();
        }
        /** @inheritdoc */
        render(plan, context, streamStack, isTransition = false) {
            this.baseRouteRenderer.render(plan, undefined, undefined, context, streamStack);
            this.fullRouteRenderer.render(plan, undefined, undefined, context, streamStack, isTransition);
        }
    }

    /**
     * Manages transition preview waypoint records.
     */
    class ProcMapTransitionWaypointRecordManager {
        /**
         * Constructor.
         * @param facLoader This manager's facility loader.
         * @param facWaypointCache This manager's facility waypoint cache.
         * @param waypointRenderer This manager's waypoint renderer.
         * @param renderRole The role(s) under which waypoints should be registered.
         */
        constructor(facLoader, facWaypointCache, waypointRenderer, renderRole) {
            this.facLoader = facLoader;
            this.facWaypointCache = facWaypointCache;
            this.waypointRenderer = waypointRenderer;
            this.renderRole = renderRole;
            this.legWaypointRecords = new Map();
            this._isBusy = false;
        }
        /**
         * Checks whether this manager is busy with a waypoint refresh.
         * @returns Whether this manager is busy with a waypoint refresh.
         */
        isBusy() {
            return this._isBusy;
        }
        // eslint-disable-next-line jsdoc/require-throws
        /**
         * Refreshes this manager's waypoint records, keeping them up to date with a specified flight plan.
         * @param flightPlan A flight plan.
         * @param repick Whether to repick waypoints.
         * @param pickPosition The position within each transition from which to pick waypoints. Ignored if `repick` is
         * false. Defaults to `first`.
         */
        async refreshWaypoints(flightPlan, repick, pickPosition) {
            if (this._isBusy) {
                throw new Error('ProcMapTransitionWaypointRecordManager: cannot refresh waypoints while busy');
            }
            this._isBusy = true;
            if (!flightPlan) {
                // Remove all waypoint records.
                for (const record of this.legWaypointRecords.values()) {
                    record.destroy();
                }
                this.legWaypointRecords.clear();
                this._isBusy = false;
                return;
            }
            if (repick) {
                const legsToDisplay = new Set();
                if ((pickPosition !== null && pickPosition !== void 0 ? pickPosition : 'first') === 'first') {
                    this.pickFirst(flightPlan, legsToDisplay);
                }
                else {
                    this.pickLast(flightPlan, legsToDisplay);
                }
                // Remove records of legs that are no longer in the set of legs to display.
                for (const record of this.legWaypointRecords.values()) {
                    if (legsToDisplay.has(record.leg)) {
                        legsToDisplay.delete(record.leg);
                    }
                    else {
                        record.destroy();
                        this.legWaypointRecords.delete(record.leg);
                    }
                }
                // Create new records for legs to display that don't already have records.
                for (const leg of legsToDisplay) {
                    const record = this.createLegWaypointsRecord(leg);
                    this.legWaypointRecords.set(leg, record);
                }
            }
            const waypointRefreshes = [];
            for (const record of this.legWaypointRecords.values()) {
                waypointRefreshes.push(record.refresh(false));
            }
            await Promise.all(waypointRefreshes);
            this._isBusy = false;
        }
        /**
         * Picks the first waypoint in each transition to display.
         * @param flightPlan The transition preview flight plan.
         * @param legsToDisplay A set of legs from which to display waypoints.
         */
        pickFirst(flightPlan, legsToDisplay) {
            let isFirst = true;
            for (const leg of flightPlan.legs()) {
                if (isFirst && !msfssdk.BitFlags.isAny(leg.flags, msfssdk.LegDefinitionFlags.DirectTo | msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                    legsToDisplay.add(leg);
                }
                isFirst = leg.leg.type === msfssdk.LegType.Discontinuity;
            }
        }
        /**
         * Picks the last waypoint in each transition to display.
         * @param flightPlan The transition preview flight plan.
         * @param legsToDisplay A set of legs from which to display waypoints.
         */
        pickLast(flightPlan, legsToDisplay) {
            let lastLeg;
            for (const leg of flightPlan.legs()) {
                if (lastLeg && leg.leg.type === msfssdk.LegType.Discontinuity && !msfssdk.BitFlags.isAny(lastLeg.flags, msfssdk.LegDefinitionFlags.DirectTo | msfssdk.LegDefinitionFlags.VectorsToFinal)) {
                    legsToDisplay.add(lastLeg);
                }
                lastLeg = leg;
            }
            if (lastLeg) {
                legsToDisplay.add(lastLeg);
            }
        }
        /**
         * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
         * @param leg A flight plan leg.
         * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
         */
        createLegWaypointsRecord(leg) {
            switch (leg.leg.type) {
                case msfssdk.LegType.CD:
                case msfssdk.LegType.VD:
                case msfssdk.LegType.CR:
                case msfssdk.LegType.VR:
                case msfssdk.LegType.FC:
                case msfssdk.LegType.FD:
                case msfssdk.LegType.FA:
                case msfssdk.LegType.CA:
                case msfssdk.LegType.VA:
                case msfssdk.LegType.FM:
                case msfssdk.LegType.VM:
                case msfssdk.LegType.CI:
                case msfssdk.LegType.VI:
                    return new FlightPathTerminatorWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.renderRole, this.renderRole);
                case msfssdk.LegType.PI:
                    return new ProcedureTurnLegWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.facWaypointCache, this.renderRole, this.renderRole);
                default:
                    return new FixIcaoWaypointsRecord(leg, this.waypointRenderer, this.facLoader, this.facWaypointCache, this.renderRole, this.renderRole);
            }
        }
    }

    exports.DirectToState = void 0;
    (function (DirectToState) {
        DirectToState[DirectToState["NONE"] = 0] = "NONE";
        DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
        DirectToState[DirectToState["TORANDOM"] = 2] = "TORANDOM";
    })(exports.DirectToState || (exports.DirectToState = {}));
    exports.ProcedureType = void 0;
    (function (ProcedureType) {
        ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
        ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
        ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
        ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
    })(exports.ProcedureType || (exports.ProcedureType = {}));
    exports.AirwayLegType = void 0;
    (function (AirwayLegType) {
        AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
        AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
        AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
        AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
        AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
    })(exports.AirwayLegType || (exports.AirwayLegType = {}));
    /**
     * A fms menu system tracker.
     */
    class Fms {
        /**
         * Initialize an instance of the FMS.
         * @param bus is the event bus
         * @param flightPlanner is the flight planner
         * @param verticalPathCalculator is the optional Vertical Path Calculator.
         */
        constructor(bus, flightPlanner, verticalPathCalculator) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.verticalPathCalculator = verticalPathCalculator;
            this.ppos = new msfssdk.GeoPoint(0, 0);
            this.facRepo = msfssdk.FacilityRepository.getRepository(this.bus);
            this.facLoader = new msfssdk.FacilityLoader(this.facRepo);
            this.approachDetails = {
                approachLoaded: false,
                approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
                approachRnavType: msfssdk.RnavTypeFlags.None,
                approachIsActive: false,
                approachIsCircling: false
            };
            this.approachFrequency = msfssdk.Subject.create(undefined);
            this._lastApproachFrequencyEventValue = undefined;
            this.cdiSource = { type: msfssdk.NavSourceType.Gps, index: 1 };
            this.missedApproachActive = false;
            this.insertApproachOpId = 0;
            /**
             * Sets the approach details when an approach_details_set event is received from the bus.
             * @param approachDetails The approachDetails received from the bus.
             */
            this.onApproachDetailsSet = (approachDetails) => {
                if (approachDetails !== this.approachDetails) {
                    this.approachDetails = approachDetails;
                }
            };
            const sub = this.bus.getSubscriber();
            sub.on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
            sub.on('cdi_select').handle(source => this.cdiSource = source);
            sub.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
            sub.on('fplLoaded').handle(() => this.checkApproachState());
            const obsCourse = msfssdk.ConsumerSubject.create(sub.on('gps_obs_value'), 0);
            let obsWasActive = false;
            sub.on('gps_obs_active').whenChanged().handle(isActive => {
                if (isActive) {
                    obsWasActive = true;
                }
                else {
                    if (obsWasActive) {
                        this.convertObsToDirectTo(obsCourse.get());
                    }
                    obsWasActive = false;
                }
            });
            this.navActiveFreqs = {
                1: msfssdk.ConsumerSubject.create(sub.on('nav_active_frequency_1'), 0),
                2: msfssdk.ConsumerSubject.create(sub.on('nav_active_frequency_2'), 0)
            };
            this.approachFrequency.sub((v) => {
                if (v !== this._lastApproachFrequencyEventValue) {
                    this.bus.getPublisher().pub('approach_freq_set', v, true);
                }
            });
            sub.on('approach_freq_set').handle((v) => {
                this._lastApproachFrequencyEventValue = v;
                this.approachFrequency.set(v);
            });
            sub.on('activate_missed_approach').handle(v => {
                this.missedApproachActive = v;
                if (this.missedApproachActive) {
                    this.bus.getPublisher().pub('suspend_sequencing', false, true);
                    this.setApproachDetails(undefined, undefined, undefined, false);
                }
            });
            sub.on('approach_details_set').handle(this.onApproachDetailsSet);
        }
        /**
         * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
         */
        async initPrimaryFlightPlan() {
            if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
                return;
            }
            this.flightPlanner.createFlightPlan(Fms.PRIMARY_PLAN_INDEX);
            await this.emptyPrimaryFlightPlan();
        }
        /**
         * Checks whether an indexed flight plan exists.
         * @param index A flight plan index.
         * @returns Whether a flight plan at the specified index exists.
         */
        hasFlightPlan(index) {
            return this.flightPlanner.hasFlightPlan(index);
        }
        /**
         * Gets a specified flightplan, or by default the primary flight plan.
         * @param index The index of the flight plan.
         * @returns the requested flight plan
         * @throws Error if no flight plan exists at the specified index.
         */
        getFlightPlan(index = Fms.PRIMARY_PLAN_INDEX) {
            return this.flightPlanner.getFlightPlan(index);
        }
        /**
         * Checks whether the primary flight plan exists.
         * @returns Whether the primary flight plan exists.
         */
        hasPrimaryFlightPlan() {
            return this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        }
        /**
         * Gets the primary flight plan.
         * @returns The primary flight plan.
         * @throws Error if the primary flight plan does not exist.
         */
        getPrimaryFlightPlan() {
            return this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        }
        /**
         * Checks whether the Direct To Random flight plan exists.
         * @returns Whether the Direct To Random flight plan exists.
         */
        hasDirectToFlightPlan() {
            return this.flightPlanner.hasFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
        }
        /**
         * Gets the Direct To Random flight plan.
         * @returns The Direct To Random flight plan.
         * @throws Error if the Direct To Random flight plan does not exist.
         */
        getDirectToFlightPlan() {
            return this.flightPlanner.getFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
        }
        /**
         * Handles when a flight plan active leg changes.
         * @param legType The type of flight plan active leg change.
         * @param planIndex The index of the plan whose active leg changed.
         */
        onActiveLegChanged(legType, planIndex) {
            if (legType === msfssdk.ActiveLegType.Lateral && planIndex === 0) {
                const activePlan = this.flightPlanner.getActiveFlightPlan();
                if (activePlan.length > 0 && !this.missedApproachActive) {
                    const activeSegment = activePlan.getSegment(activePlan.getSegmentIndex(Math.max(0, activePlan.activeLateralLeg)));
                    if (activeSegment.segmentType === msfssdk.FlightPlanSegmentType.Approach && activePlan.activeLateralLeg - activeSegment.offset > 0) {
                        this.setApproachDetails(undefined, undefined, undefined, true);
                    }
                    else {
                        this.setApproachDetails(undefined, undefined, undefined, false);
                    }
                }
                else {
                    this.setApproachDetails(undefined, undefined, undefined, false);
                }
                if (!this.missedApproachActive
                    && activePlan.activeLateralLeg < activePlan.length - 1
                    && msfssdk.BitFlags.isAll(activePlan.getLeg(activePlan.activeLateralLeg).flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                    this.bus.getPublisher().pub('activate_missed_approach', true, true);
                }
            }
        }
        /**
         * A method to check the current approach state.
         */
        async checkApproachState() {
            const plan = this.getFlightPlan();
            let approachLoaded = false;
            let approachIsActive = false;
            let approachType;
            let approachRnavType;
            let approachIsCircling = false;
            if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach') !== undefined)) {
                approachLoaded = true;
                if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                    const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                    approachIsActive = segment.segmentType === msfssdk.FlightPlanSegmentType.Approach;
                }
                if (plan.procedureDetails.approachIndex > -1) {
                    const facility = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.destinationAirport);
                    const approach = facility.approaches[plan.procedureDetails.approachIndex];
                    if (approach) {
                        approachType = approach.approachType;
                        approachRnavType = FmsUtils.getBestRnavType(approach.rnavTypeFlags);
                        approachIsCircling = !approach.runway;
                    }
                }
                else {
                    approachType = msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL;
                    approachRnavType = msfssdk.RnavTypeFlags.None;
                }
            }
            this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling);
        }
        /**
         * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
         * this will effectively cancel it.
         * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
         * to the index of the current active primary flight plan leg.
         */
        removeDirectToExisting(lateralLegIndex) {
            const plan = this.getFlightPlan();
            const directToData = plan.directToData;
            if (directToData && directToData.segmentIndex > -1) {
                plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
                plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
                plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
                const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
                const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
                plan.setDirectToData(-1, true);
                plan.setCalculatingLeg(adjustedActivateIndex);
                plan.setLateralLeg(adjustedActivateIndex);
                plan.calculate(0);
            }
        }
        /**
         * Checks whether a leg in the primary flight plan can be manually activated.
         * @param segmentIndex The index of the segment in which the leg resides.
         * @param segmentLegIndex The index of the leg in its segment.
         * @returns Whether the leg can be manually activated.
         */
        canActivateLeg(segmentIndex, segmentLegIndex) {
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return false;
            }
            const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if (!leg || msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.DirectTo) || leg === plan.getLeg(0)) {
                return false;
            }
            switch (leg.leg.type) {
                case msfssdk.LegType.CF:
                case msfssdk.LegType.FC:
                case msfssdk.LegType.FD:
                    return true;
                case msfssdk.LegType.CI:
                case msfssdk.LegType.VI:
                case msfssdk.LegType.FA:
                case msfssdk.LegType.CA:
                case msfssdk.LegType.VA:
                case msfssdk.LegType.VM:
                    return false;
            }
            const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
            switch (prevLeg.leg.type) {
                case msfssdk.LegType.VA:
                case msfssdk.LegType.CA:
                case msfssdk.LegType.VM:
                case msfssdk.LegType.Discontinuity:
                    return false;
            }
            return true;
        }
        /**
         * Checks whether a leg in the primary flight plan is a valid direct to target.
         * @param segmentIndex The index of the segment in which the leg resides.
         * @param segmentLegIndex The index of the leg in its segment.
         * @returns Whether the leg is a valid direct to target.
         * @throws Error if a leg could not be found at the specified location.
         */
        canDirectTo(segmentIndex, segmentLegIndex) {
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return false;
            }
            const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if (!leg || leg.leg.fixIcao === '' || leg.leg.fixIcao === msfssdk.ICAO.emptyIcao) {
                return false;
            }
            switch (leg.leg.type) {
                case msfssdk.LegType.IF:
                case msfssdk.LegType.TF:
                case msfssdk.LegType.DF:
                case msfssdk.LegType.CF:
                case msfssdk.LegType.AF:
                case msfssdk.LegType.RF:
                    return true;
            }
            return false;
        }
        /**
         * Gets the current Direct To State.
         * @returns the DirectToState.
         */
        getDirectToState() {
            if (this.flightPlanner.activePlanIndex == 1) {
                const plan = this.getDirectToFlightPlan();
                if (plan.segmentCount > 0 && plan.getSegment(0).segmentType === msfssdk.FlightPlanSegmentType.RandomDirectTo) {
                    return exports.DirectToState.TORANDOM;
                }
            }
            else {
                const plan = this.getPrimaryFlightPlan();
                const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
                if (directDataExists && plan.segmentCount >= plan.directToData.segmentIndex
                    && plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]) === plan.activeLateralLeg - 3) {
                    return exports.DirectToState.TOEXISTING;
                }
            }
            return exports.DirectToState.NONE;
        }
        /**
         * Gets the ICAO string of the current Direct To target.
         * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
         */
        getDirectToTargetIcao() {
            var _a;
            return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
        }
        /**
         * Gets the current DTO Target Flight Plan Leg.
         * @returns the FlightPlanLeg.
         */
        getDirectToLeg() {
            switch (this.getDirectToState()) {
                case exports.DirectToState.TORANDOM: {
                    const plan = this.getDirectToFlightPlan();
                    return plan.getSegment(0).legs[2].leg;
                }
                case exports.DirectToState.TOEXISTING: {
                    const plan = this.getFlightPlan();
                    return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg;
                }
            }
            return undefined;
        }
        /**
         * Checks if a segment is the first enroute segment that is not an airway.
         * @param segmentIndex is the segment index of the segment to check
         * @returns whether or not the segment is the first enroute segment that is not an airway.
         */
        isFirstEnrouteSegment(segmentIndex) {
            const plan = this.getFlightPlan();
            for (let i = 0; i < plan.segmentCount; i++) {
                const segment = plan.getSegment(i);
                if (segment.segmentType === msfssdk.FlightPlanSegmentType.Enroute && !segment.airway) {
                    return i === segmentIndex;
                }
            }
            return false;
        }
        /**
         * Adds a user facility.
         * @param userFacility the facility to add.
         */
        addUserFacility(userFacility) {
            this.facRepo.add(userFacility);
        }
        /**
         * Removes a user facility.
         * @param userFacility the facility to remove.
         */
        removeUserFacility(userFacility) {
            this.facRepo.remove(userFacility);
        }
        /**
         * Adds a visual or runway facility from the FlightPlanLeg.
         * @param leg the leg to build the facility from.
         * @param visualRunwayDesignation is the visual runway this facility belongs to.
         */
        addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
            const fac = {
                icao: leg.fixIcao,
                lat: leg.lat !== undefined ? leg.lat : 0,
                lon: leg.lon !== undefined ? leg.lon : 0,
                approach: `VISUAL ${visualRunwayDesignation}`,
                city: '',
                name: `${visualRunwayDesignation} - ${msfssdk.ICAO.getIdent(leg.fixIcao)}`,
                region: '',
                magvar: 0
            };
            this.facRepo.add(fac);
        }
        /**
         * Method to insert a waypoint to the flightplan.
         * @param segmentIndex is index of the segment to add the waypoint to
         * @param facility is the new facility to add a leg to.
         * @param legIndex is the index to insert the waypoint (if none, append)
         * @returns whether the waypoint was successfully inserted.
         */
        insertWaypoint(segmentIndex, facility, legIndex) {
            var _a, _b;
            const leg = msfssdk.FlightPlan.createLeg({
                type: msfssdk.LegType.TF,
                fixIcao: facility.icao
            });
            const plan = this.getFlightPlan();
            const segment = plan.getSegment(segmentIndex);
            const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
            const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
            // Make sure we are not inserting a duplicate leg
            if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
                return false;
            }
            // Deal with whether this insert is in an airway segment
            if (segment.airway) {
                legIndex !== null && legIndex !== void 0 ? legIndex : (legIndex = segment.legs.length - 1);
                // Get the displaced legs from the airway segment
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                // Save the airway name
                const airway = (_b = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0]) !== null && _b !== void 0 ? _b : '';
                const nextSegment = plan.getSegment(segmentIndex + 1);
                const needFirstAirwaySegment = legIndex > 0; // We don't need to keep the original airway segment around if we've displaced all of its enroute waypoints.
                const needSecondAirwaySegment = legsToMove.length > 2; // Only create a second airway segment if we've displaced at least three waypoints in the original airway
                const needNewEnrouteSegment = needFirstAirwaySegment && (needSecondAirwaySegment || nextSegment.airway || nextSegment.segmentType !== msfssdk.FlightPlanSegmentType.Enroute);
                const firstAirwaySegmentIndex = needFirstAirwaySegment ? segmentIndex : -1;
                const enrouteSegmentIndex = needFirstAirwaySegment ? segmentIndex + 1 : segmentIndex - 1;
                const secondAirwaySegmentIndex = needSecondAirwaySegment ? enrouteSegmentIndex + 1 : -1;
                if (needNewEnrouteSegment) {
                    this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                if (needSecondAirwaySegment) {
                    this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                // Add the inserted leg to its enroute segment
                this.planAddLeg(enrouteSegmentIndex, leg);
                if (!needFirstAirwaySegment) {
                    this.planRemoveSegment(segmentIndex);
                }
                else {
                    for (let i = legsLength - 1; i >= legIndex; i--) {
                        this.planRemoveLeg(segmentIndex, i, true, true);
                    }
                }
                if (legsToMove.length > 0) {
                    this.planAddLeg(enrouteSegmentIndex, legsToMove[0]); // Always add first displaced waypoint to the enroute segment in case it is an airway entry
                    const toAddSegmentIndex = secondAirwaySegmentIndex < 0 ? enrouteSegmentIndex : secondAirwaySegmentIndex;
                    for (let i = 1; i < legsToMove.length; i++) {
                        this.planAddLeg(toAddSegmentIndex, legsToMove[i]);
                    }
                }
                // Update names of the airway segments as appropriate.
                if (firstAirwaySegmentIndex >= 0) {
                    segment.airway = airway + '.' + segment.legs[legIndex - 1].name;
                    plan.setAirway(firstAirwaySegmentIndex, segment.airway);
                }
                if (secondAirwaySegmentIndex >= 0) {
                    const newAirwaySegment = plan.getSegment(secondAirwaySegmentIndex);
                    newAirwaySegment.airway = airway + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name;
                    plan.setAirway(secondAirwaySegmentIndex, newAirwaySegment.airway);
                }
                return true;
            }
            this.planAddLeg(segmentIndex, leg, legIndex);
            return true;
        }
        /**
         * Removes a leg to a waypoint from the primary flight plan.
         * @param segmentIndex The index of the segment containing the leg to remove.
         * @param segmentLegIndex The index of the leg to remove in its segment.
         * @returns Whether the waypoint was successfully removed.
         */
        removeWaypoint(segmentIndex, segmentLegIndex) {
            var _a, _b;
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return false;
            }
            let mustActivateVtf = false;
            // If there's a VTF approach loaded, we may need to activate it on leg removal.  This will happen
            // when the active leg was removed and it was the leg immediately before the approach.
            if (this.isApproachVtf()) {
                const activeLegIndex = plan.activeLateralLeg;
                // Check to see if the leg we're removing is the active one.
                if (activeLegIndex === plan.getSegment(segmentIndex).offset + segmentLegIndex) {
                    // Check to see if the active leg is the last one before the approach.
                    if (activeLegIndex === ((_b = (_a = plan.segmentsOfType(msfssdk.FlightPlanSegmentType.Approach).next().value) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) - 1) {
                        mustActivateVtf = true;
                    }
                }
            }
            const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if (!leg || msfssdk.BitFlags.isAny(leg.leg.fixTypeFlags, msfssdk.FixTypeFlags.FAF | msfssdk.FixTypeFlags.MAP)) {
                return false;
            }
            const legDeleted = this.planRemoveLeg(segmentIndex, segmentLegIndex);
            const nextLeg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if (legDeleted && nextLeg && (nextLeg.leg.type === msfssdk.LegType.HA || nextLeg.leg.type === msfssdk.LegType.HM || nextLeg.leg.type === msfssdk.LegType.HF)) {
                if (plan.tryGetLeg(segmentIndex, segmentLegIndex)) {
                    this.planRemoveLeg(segmentIndex, segmentLegIndex, true, true, true);
                }
            }
            if (mustActivateVtf) {
                this.activateVtf();
            }
            return legDeleted;
        }
        /**
         * Gets the airway leg type of a flight plan leg.
         * @param plan The flight plan containing the query leg.
         * @param segmentIndex The index of the flight plan segment containing the query leg.
         * @param segmentLegIndex The index of the query leg in its segment.
         * @returns The airway leg type of the query leg.
         */
        getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
            const segment = plan.getSegment(segmentIndex);
            const segmentIsAirway = segment.airway !== undefined;
            const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
            const legIsLast = segmentLegIndex == segment.legs.length - 1;
            if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
                return exports.AirwayLegType.EXIT_ENTRY;
            }
            if ((legIsLast && nextSegmentIsAirway)) {
                return exports.AirwayLegType.ENTRY;
            }
            if (segmentIsAirway) {
                if (legIsLast) {
                    return exports.AirwayLegType.EXIT;
                }
                return exports.AirwayLegType.ONROUTE;
            }
            return exports.AirwayLegType.NONE;
        }
        /**
         * Method to get the distance of an airway segment.
         * @param segmentIndex is the index of the segment of the airway.
         * @returns the cumulative distance for the airway segment.
         */
        getAirwayDistance(segmentIndex) {
            var _a, _b, _c, _d;
            const plan = this.getFlightPlan();
            const segment = plan.getSegment(segmentIndex);
            const entrySegment = plan.getSegment(segmentIndex - 1);
            const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
            const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
            return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
        }
        /**
         * Method to add a new origin airport and runway to the flight plan.
         * @param airport is the facility of the origin airport.
         * @param runway is the onewayrunway
         */
        setOrigin(airport, runway) {
            const plan = this.getFlightPlan();
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Departure);
            if (airport) {
                plan.setOriginAirport(airport.icao);
                plan.setOriginRunway(runway);
                this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Departure);
                this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
                const prevLeg = plan.getPrevLeg(segmentIndex, 1);
                const nextLeg = plan.getNextLeg(segmentIndex, 0);
                if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                    this.planRemoveDuplicateLeg(prevLeg, nextLeg);
                }
            }
            else {
                plan.removeOriginAirport();
                this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, msfssdk.RnavTypeFlags.None, false);
                this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Departure);
            }
            plan.calculate(0);
        }
        /**
         * Method to add a new destination airport and runway to the flight plan.
         * @param airport is the facility of the destination airport.
         * @param runway is the selected runway at the destination facility.
         */
        setDestination(airport, runway) {
            const plan = this.getFlightPlan();
            const destSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Destination);
            if (airport) {
                plan.setDestinationAirport(airport.icao);
                plan.setDestinationRunway(runway);
                this.planClearSegment(destSegmentIndex, msfssdk.FlightPlanSegmentType.Destination);
                const hasArrival = plan.procedureDetails.arrivalIndex > -1;
                const hasApproach = plan.procedureDetails.approachIndex > -1;
                if (!hasArrival && !hasApproach) {
                    this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, runway);
                }
            }
            else {
                plan.removeDestinationAirport();
                this.planClearSegment(destSegmentIndex, msfssdk.FlightPlanSegmentType.Destination);
            }
            plan.calculate(0);
        }
        /**
         * Method to remove runway or airport legs from segments where they shouldn't exist.
         */
        removeDestLegFromSegments() {
            const plan = this.getFlightPlan();
            const destination = plan.destinationAirport;
            const hasArrival = plan.procedureDetails.arrivalIndex > -1;
            const hasApproach = plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach');
            const destinationSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Destination);
            const destinationSegment = plan.getSegment(destinationSegmentIndex);
            if (hasApproach && destination) {
                if (hasArrival) {
                    const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Arrival);
                    const arrival = plan.getSegment(arrivalSegmentIndex);
                    const lastArrivalLegIcao = arrival.legs[arrival.legs.length - 1].leg.fixIcao;
                    if (lastArrivalLegIcao === destination || lastArrivalLegIcao.search('R') === 0) {
                        this.planRemoveLeg(arrivalSegmentIndex, arrival.legs.length - 1);
                    }
                }
                if (destinationSegment.legs.length > 0) {
                    this.planClearSegment(destinationSegmentIndex, msfssdk.FlightPlanSegmentType.Destination);
                }
            }
            else if (hasArrival && destination) {
                if (destinationSegment.legs.length > 0) {
                    this.planClearSegment(destinationSegmentIndex, msfssdk.FlightPlanSegmentType.Destination);
                }
            }
        }
        /**
         * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
         * @param segmentType is the segment type we want to evaluate.
         * @param insert is whether to insert the segment if missing
         * @returns segmentIndex of the only segment of this type in the flight plan.
         */
        ensureOnlyOneSegmentOfType(segmentType, insert = true) {
            const plan = this.getFlightPlan();
            let segmentIndex;
            const selectedSegments = plan.segmentsOfType(segmentType);
            const segmentIndexArray = [];
            for (const element of selectedSegments) {
                segmentIndexArray.push(element.segmentIndex);
            }
            if (segmentIndexArray.length === 0) {
                if (insert) {
                    segmentIndex = this.planInsertSegmentOfType(segmentType);
                }
                else {
                    segmentIndex = -1;
                }
            }
            else if (segmentIndexArray.length > 1) {
                for (let i = 0; i < segmentIndexArray.length; i++) {
                    this.planRemoveSegment(segmentIndexArray[i]);
                }
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = segmentIndexArray[0];
            }
            return segmentIndex;
        }
        /**
         * Method to invert the flightplan.
         */
        invertFlightplan() {
            var _a;
            const plan = this.getFlightPlan();
            const activeLegIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
                this.removeDirectToExisting();
            }
            if (!Simplane.getIsGrounded() && activeLegIcao) {
                this.createDirectToRandom(activeLegIcao);
            }
            const newOriginIcao = plan.destinationAirport;
            const newDestinationIcao = plan.originAirport;
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
                //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
                const segment = Object.assign({}, plan.getSegment(1));
                this.emptyPrimaryFlightPlan();
                for (let l = segment.legs.length - 1; l >= 0; l--) {
                    plan.addLeg(1, segment.legs[l].leg);
                }
            }
            else if (lastEnrouteSegmentIndex > 1) {
                //case for when there is more than 1 enroute segment we know we have to deal with airways
                const legs = [];
                for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                    //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                    //we fly FROM the leg on.
                    const oldSegment = plan.getSegment(i);
                    const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                    for (const leg of oldSegment.legs) {
                        const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                        legs.push(legListItem);
                    }
                }
                //after the array of legs is complete, we just reverse it
                legs.reverse();
                this.emptyPrimaryFlightPlan();
                let currentSegment = 1;
                let lastLegWasAirway = false;
                //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
                //segments as appropriate for these legs.
                for (let i = 0; i < legs.length; i++) {
                    const wpt = legs[i];
                    const segment = plan.getSegment(currentSegment);
                    if (wpt.airway) {
                        const leg = msfssdk.FlightPlan.createLeg({
                            type: msfssdk.LegType.TF,
                            fixIcao: wpt.icao
                        });
                        plan.addLeg(currentSegment, leg);
                        if (!lastLegWasAirway) {
                            plan.insertSegment(currentSegment + 1, msfssdk.FlightPlanSegmentType.Enroute, wpt.airway);
                            currentSegment += 1;
                        }
                        for (let j = i + 1; j < legs.length; j++) {
                            i++;
                            const airwayLeg = msfssdk.FlightPlan.createLeg({
                                type: msfssdk.LegType.TF,
                                fixIcao: legs[j].icao
                            });
                            plan.addLeg(currentSegment, airwayLeg);
                            if (legs[j].airway !== wpt.airway) {
                                lastLegWasAirway = legs[j].airway ? true : false;
                                break;
                            }
                        }
                        plan.setAirway(currentSegment, wpt.airway + '.' + msfssdk.ICAO.getIdent(legs[i].icao));
                        currentSegment += 1;
                        plan.insertSegment(currentSegment, msfssdk.FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                    }
                    else {
                        let leg = undefined;
                        leg = msfssdk.FlightPlan.createLeg({
                            type: msfssdk.LegType.TF,
                            fixIcao: wpt.icao
                        });
                        if (leg) {
                            plan.addLeg(currentSegment, leg);
                            if (lastLegWasAirway) {
                                plan.setAirway(currentSegment, segment.airway + '.' + msfssdk.ICAO.getIdent(wpt.icao));
                                currentSegment += 1;
                                plan.insertSegment(currentSegment, msfssdk.FlightPlanSegmentType.Enroute);
                            }
                            lastLegWasAirway = false;
                        }
                    }
                }
                if (plan.getSegment(currentSegment).airway) {
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, msfssdk.FlightPlanSegmentType.Enroute);
                }
            }
            else {
                this.emptyPrimaryFlightPlan();
            }
            if (newOriginIcao) {
                this.facLoader.getFacility(msfssdk.FacilityType.Airport, newOriginIcao).then((facility) => {
                    this.setOrigin(facility);
                });
            }
            if (newDestinationIcao) {
                this.facLoader.getFacility(msfssdk.FacilityType.Airport, newDestinationIcao).then((facility) => {
                    this.setDestination(facility);
                });
            }
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, msfssdk.RnavTypeFlags.None, false);
            plan.calculate(0);
        }
        /**
         * Method to add or replace a departure procedure in the flight plan.
         * @param facility is the facility that contains the procedure to add.
         * @param departureIndex is the index of the departure
         * @param departureRunwayIndex is the index of the runway transition
         * @param enrouteTransitionIndex is the index of the enroute transition
         * @param oneWayRunway is the one way runway to set as the origin leg.
         */
        insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
            const plan = this.getFlightPlan();
            plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Departure);
            this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Departure);
            const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
            if (oneWayRunway) {
                plan.setOriginAirport(facility.icao);
                plan.setOriginRunway(oneWayRunway);
            }
            else if (plan.originAirport == facility.icao && plan.procedureDetails.originRunway) {
                const originLeg = FmsUtils.buildRunwayLeg(facility, plan.procedureDetails.originRunway, true);
                insertProcedureObject.procedureLegs.splice(0, 1, originLeg);
            }
            else {
                plan.setOriginAirport(facility.icao);
            }
            insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
            const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
            const depSegment = plan.getSegment(segmentIndex);
            const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
            if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
            }
            this.setVerticalData(plan, segmentIndex);
            plan.calculate(0);
        }
        /**
         * Method to insert the arrival legs.
         * @param facility is the facility to build legs from.
         * @param procedureIndex is the procedure index to build legs from.
         * @param enrouteTransitionIndex is the enroute transition index to build legs from.
         * @param runwayTransitionIndex is the runway transition index to build legs from.
         * @param oneWayRunway is the one way runway, if one is specified in the procedure.
         * @returns InsertProcedureObject to insert into the flight plan.
         */
        buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
            const departure = facility.departures[procedureIndex];
            const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
            const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
            const insertProcedureObject = { procedureLegs: [] };
            let originLeg;
            if (oneWayRunway) {
                originLeg = FmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
            }
            else {
                originLeg = msfssdk.FlightPlan.createLeg({
                    lat: facility.lat,
                    lon: facility.lon,
                    type: msfssdk.LegType.IF,
                    fixIcao: facility.icao
                });
            }
            insertProcedureObject.procedureLegs.push(originLeg);
            if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
                runwayTransition.legs.forEach((leg) => {
                    insertProcedureObject.procedureLegs.push(msfssdk.FlightPlan.createLeg(leg));
                });
            }
            for (let i = 0; i < departure.commonLegs.length; i++) {
                const leg = msfssdk.FlightPlan.createLeg(departure.commonLegs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
            if (enRouteTransition) {
                for (let i = 0; i < enRouteTransition.legs.length; i++) {
                    const leg = msfssdk.FlightPlan.createLeg(enRouteTransition.legs[i]);
                    if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                        this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                        insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                            this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                        continue;
                    }
                    insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
                }
            }
            return insertProcedureObject;
        }
        /**
         * Method to add or replace an arrival procedure in the flight plan.
         * @param facility is the facility that contains the procedure to add.
         * @param arrivalIndex is the index of the arrival procedure.
         * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
         * @param enrouteTransitionIndex is the index of the enroute transition.
         * @param oneWayRunway is the one way runway to set as the destination leg.
         */
        insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
            const plan = this.getFlightPlan();
            plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
            if (plan.length > 0 && plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
                if (!this.moveDirectToDestinationLeg(plan, msfssdk.FlightPlanSegmentType.Enroute)) {
                    if (plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport && plan.destinationAirport !== facility.icao && plan.activeLateralLeg === plan.length - 1) {
                        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                        const newDestinationLeg = msfssdk.FlightPlan.createLeg({ fixIcao: plan.destinationAirport, type: msfssdk.LegType.TF });
                        this.planAddLeg(lastEnrouteSegmentIndex, newDestinationLeg);
                    }
                }
            }
            if (plan.procedureDetails.approachIndex < 0) {
                plan.setDestinationAirport(facility.icao);
                plan.setDestinationRunway(oneWayRunway);
            }
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Arrival);
            if (plan.getSegment(segmentIndex).legs.length > 0) {
                this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Arrival);
            }
            const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
            let directTargetLeg;
            let handleDirectToDestination = false;
            const directToState = this.getDirectToState();
            if (plan.procedureDetails.approachIndex > -1) {
                insertProcedureObject.procedureLegs.pop();
            }
            else if (directToState === exports.DirectToState.TOEXISTING) {
                directTargetLeg = this.getDirectToLeg();
                if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                    (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                    insertProcedureObject.procedureLegs.pop();
                    handleDirectToDestination = true;
                }
            }
            insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
            const arrSegment = plan.getSegment(segmentIndex);
            const prevLeg = plan.getPrevLeg(segmentIndex, 0);
            const firstArrLeg = arrSegment.legs[0];
            if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
            }
            this.removeDestLegFromSegments();
            const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
            const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
            if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
            }
            if (handleDirectToDestination) {
                this.moveDirectToDestinationLeg(plan, msfssdk.FlightPlanSegmentType.Arrival, segmentIndex);
                this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
            }
            else if (directToState === exports.DirectToState.TOEXISTING && directTargetLeg && directTargetLeg.fixIcao === plan.destinationAirport) {
                this.removeDirectToExisting();
                this.createDirectToRandom(plan.destinationAirport);
            }
            this.setVerticalData(plan, segmentIndex);
            plan.calculate(0);
        }
        /**
         * Method to insert the arrival legs.
         * @param facility is the facility to build legs from.
         * @param procedureIndex is the procedure index to build legs from.
         * @param enrouteTransitionIndex is the enroute transition index to build legs from.
         * @param runwayTransitionIndex is the runway transition index to build legs from.
         * @param oneWayRunway is the one way runway, if one is specified in the procedure.
         * @returns InsertProcedureObject to insert into the flight plan.
         */
        buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
            const arrival = facility.arrivals[procedureIndex];
            const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
            const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
            const insertProcedureObject = { procedureLegs: [] };
            if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
                enRouteTransition.legs.forEach((leg) => {
                    insertProcedureObject.procedureLegs.push(msfssdk.FlightPlan.createLeg(leg));
                });
            }
            for (let i = 0; i < arrival.commonLegs.length; i++) {
                const leg = msfssdk.FlightPlan.createLeg(arrival.commonLegs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
            if (runwayTransition) {
                for (let i = 0; i < runwayTransition.legs.length; i++) {
                    const leg = msfssdk.FlightPlan.createLeg(runwayTransition.legs[i]);
                    if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                        this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                        insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                            this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                        continue;
                    }
                    insertProcedureObject.procedureLegs.push(leg);
                }
            }
            const destinationLeg = oneWayRunway
                ? FmsUtils.buildRunwayLeg(facility, oneWayRunway, false)
                : msfssdk.FlightPlan.createLeg({
                    lat: facility.lat,
                    lon: facility.lon,
                    type: msfssdk.LegType.TF,
                    fixIcao: facility.icao
                });
            insertProcedureObject.procedureLegs.push(destinationLeg);
            this.tryInsertIFLeg(insertProcedureObject);
            return insertProcedureObject;
        }
        /**
         * Method to move a direct to destination to a specified target segment.
         * @param plan is the primary flight plan.
         * @param targetSegmentType is the target segment type.
         * @param arrivalSegmentIndex is the arrival segment index
         * @returns whether a direct to destination was moved.
         */
        moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
            if (this.getDirectToState() === exports.DirectToState.TOEXISTING) {
                const directTargetSegmentIndex = targetSegmentType === msfssdk.FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
                if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
                    const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
                    const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
                    const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
                    const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                    const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                    plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
                    plan.addLeg(directTargetSegmentIndex, destinationLeg);
                    plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, msfssdk.LegDefinitionFlags.DirectTo);
                    plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, msfssdk.LegDefinitionFlags.DirectTo);
                    const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, msfssdk.LegDefinitionFlags.DirectTo);
                    const newActiveLegIndex = plan.getLegIndexFromLeg(newActiveLeg);
                    plan.setCalculatingLeg(newActiveLegIndex);
                    plan.setLateralLeg(newActiveLegIndex);
                    plan.planIndex !== this.flightPlanner.activePlanIndex && plan.calculate(newActiveLegIndex);
                    return true;
                }
            }
            return false;
        }
        /**
         * Method to find the last enroute segment of the supplied flight plan.
         * @param plan is the flight plan to find the last enroute segment in.
         * @returns a segment index.
         */
        findLastEnrouteSegmentIndex(plan) {
            let enrouteSegmentFound = 0;
            for (let i = 1; i < plan.segmentCount; i++) {
                const segment = plan.getSegment(i);
                if (segment.segmentType === msfssdk.FlightPlanSegmentType.Enroute) {
                    enrouteSegmentFound = i;
                }
            }
            return enrouteSegmentFound;
        }
        /**
         * Method manage the destination leg in the last enroute segment.
         * @param plan is the flight plan.
         * @param currentDestination is the currently set destination airport icao.
         */
        manageAirportLeg(plan, currentDestination) {
            if (plan.procedureDetails.arrivalIndex > -1 || !currentDestination || Simplane.getIsGrounded()) {
                //if we don't have a destination set, or an arrival is selected, don't add the airport to enroute
                return;
            }
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            const segment = plan.getSegment(lastEnrouteSegmentIndex);
            const lastLegIndex = segment.legs.length - 1;
            if (currentDestination && (lastLegIndex < 0 || segment.legs[lastLegIndex].leg.fixIcao !== currentDestination)) {
                //if a destination is set, AND either (a) the last enroute segment is empty OR (b) the last enroute segment isn't empty and
                //the last leg of the last enroute segment is not already the current destination
                this.planAddLeg(lastEnrouteSegmentIndex, msfssdk.FlightPlan.createLeg({ fixIcao: currentDestination, type: msfssdk.LegType.TF }));
            }
        }
        /**
         * Method to check whether an approach can load, or only activate.
         * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
         */
        canApproachLoad() {
            const plan = this.getFlightPlan();
            if (plan.length > 0) {
                const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                if (activeSegment.segmentType !== msfssdk.FlightPlanSegmentType.Approach && plan.length > 1) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Method to add or replace an approach procedure in the flight plan.
         * @param facility is the facility that contains the procedure to add.
         * @param approachIndex is the index of the approach procedure.
         * @param approachTransitionIndex is the index of the approach transition.
         * @param visualRunwayNumber is the visual runway number, if any.
         * @param visualRunwayDesignator is the visual runway designator, if any.
         * @param transStartIndex is the starting leg index for the transition, if any.
         * @param skipCourseReversal Whether to skip the course reversal. False by default.
         * @param skipAutotune Whether to skip autotuning of the approach frequency, if one exists, to the nav radios. False
         * by default.
         * @returns A Promise which is fulfilled with whether the approach was inserted.
         */
        async insertApproach(facility, approachIndex, approachTransitionIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex, skipCourseReversal = false, skipAutotune = false) {
            var _a, _b;
            const plan = this.getFlightPlan();
            let visualRunway;
            if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
                visualRunway = msfssdk.RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
                if (!visualRunway) {
                    return false;
                }
            }
            const opId = ++this.insertApproachOpId;
            const insertProcedureObject = await this.buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal);
            if (opId !== this.insertApproachOpId) {
                return false;
            }
            let skipDestinationLegCheck = false;
            const approachRunway = insertProcedureObject.runway;
            const approachRunwayIcao = approachRunway ? msfssdk.RunwayUtils.getRunwayFacilityIcao(facility, approachRunway) : undefined;
            const isDtoExistingToRunwayActive = approachRunway
                && this.getDirectToState() === exports.DirectToState.TOEXISTING
                && plan.getLeg(plan.activeLateralLeg).leg.fixIcao[0] === 'R';
            const isDtoExistingToApproachRunway = isDtoExistingToRunwayActive && approachRunway && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === approachRunwayIcao;
            let dtoExistingToRunwayIcao = '';
            let dtoExistingToRunwayCourse = undefined;
            if (isDtoExistingToRunwayActive) {
                const dtoLeg = plan.getLeg(plan.activeLateralLeg);
                dtoExistingToRunwayIcao = dtoLeg.leg.fixIcao;
                dtoExistingToRunwayCourse = dtoLeg.leg.type === msfssdk.LegType.DF ? undefined : dtoLeg.leg.course;
                // Do not remove the destination runway leg if it is part of an arrival and the target of a direct to existing
                skipDestinationLegCheck = plan.getSegment(plan.directToData.segmentIndex).segmentType === msfssdk.FlightPlanSegmentType.Arrival;
            }
            if (visualRunway) {
                plan.setUserData('visual_approach', `${visualRunway.designation}`);
            }
            else if (plan.getUserData('visual_approach')) {
                plan.deleteUserData('visual_approach');
            }
            plan.setApproach(facility.icao, approachIndex, approachTransitionIndex);
            if (plan.procedureDetails.arrivalIndex < 0) {
                if (!this.moveDirectToDestinationLeg(plan, msfssdk.FlightPlanSegmentType.Enroute)) {
                    this.manageAirportLeg(plan, plan.destinationAirport);
                }
                else {
                    skipDestinationLegCheck = true;
                }
            }
            plan.setDestinationAirport(facility.icao);
            if (!skipDestinationLegCheck) {
                this.removeDestLegFromSegments();
            }
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Approach);
            if (plan.getSegment(segmentIndex).legs.length > 0) {
                this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Approach);
            }
            if (insertProcedureObject.runway) {
                plan.setDestinationRunway(insertProcedureObject.runway);
            }
            let haveAddedMap = false;
            insertProcedureObject.procedureLegs.forEach((l) => {
                var _a;
                let isMissedLeg = false;
                if (visualRunway !== undefined) {
                    // If the leg's fix is a visual approach fix, we need to add it to the facility repository so that others can
                    // look it up properly.
                    if (l.type !== msfssdk.LegType.Discontinuity && l.type !== msfssdk.LegType.ThruDiscontinuity) {
                        this.addVisualFacilityFromLeg(l, visualRunway.designation);
                    }
                    if (haveAddedMap) {
                        isMissedLeg = true;
                    }
                    if (l.fixTypeFlags & msfssdk.FixTypeFlags.MAP) {
                        haveAddedMap = true;
                    }
                }
                let flags = (_a = l.legDefinitionFlags) !== null && _a !== void 0 ? _a : msfssdk.LegDefinitionFlags.None;
                if (isMissedLeg) {
                    flags |= msfssdk.LegDefinitionFlags.MissedApproach;
                }
                this.planAddLeg(segmentIndex, l, undefined, flags);
            });
            const prevLeg = plan.getPrevLeg(segmentIndex, 0);
            const firstAppLeg = plan.getSegment(segmentIndex).legs[0];
            if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
            }
            // Adds missed approach legs
            if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
                const missedLegs = facility.approaches[approachIndex].missedLegs;
                if (missedLegs.length > 0) {
                    let maphIndex = -1;
                    for (let m = missedLegs.length - 1; m >= 0; m--) {
                        switch (missedLegs[m].type) {
                            case msfssdk.LegType.HA:
                            case msfssdk.LegType.HF:
                            case msfssdk.LegType.HM:
                                maphIndex = m - 1;
                                break;
                        }
                    }
                    for (let n = 0; n < missedLegs.length; n++) {
                        const newLeg = msfssdk.FlightPlan.createLeg(missedLegs[n]);
                        if (maphIndex >= 0 && n === maphIndex) {
                            newLeg.fixTypeFlags |= msfssdk.FixTypeFlags.MAHP;
                            this.planAddLeg(segmentIndex, newLeg, undefined, msfssdk.LegDefinitionFlags.MissedApproach);
                        }
                        else {
                            this.planAddLeg(segmentIndex, newLeg, undefined, msfssdk.LegDefinitionFlags.MissedApproach);
                        }
                    }
                }
            }
            const approachType = visualRunway ? msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL : facility.approaches[approachIndex].approachType;
            const rnavTypeFlag = visualRunway ? msfssdk.RnavTypeFlags.None : FmsUtils.getBestRnavType(facility.approaches[approachIndex].rnavTypeFlags);
            const approachIsCircling = !visualRunway && !facility.approaches[approachIndex].runway ? true : false;
            this.setApproachDetails(true, approachType, rnavTypeFlag, false, approachIsCircling);
            this.setVerticalData(plan, segmentIndex);
            this.loadApproachFrequency(facility, approachIndex);
            if (!skipAutotune) {
                this.setLocFrequency(1);
                this.setLocFrequency(2);
            }
            await plan.calculate();
            if (opId !== this.insertApproachOpId) {
                return false;
            }
            if (isDtoExistingToRunwayActive && this.getDirectToState() !== exports.DirectToState.TOEXISTING) {
                // Direct To Existing to the destination runway was canceled as a result of adding the approach
                if (isDtoExistingToApproachRunway) {
                    // DTO target runway matches the runway of the loaded approach -> need to reactivate DTO to the new runway leg
                    // in the approach
                    const runwayLegIndex = plan.getSegment(segmentIndex).legs.findIndex(leg => leg.leg.fixIcao === approachRunwayIcao);
                    if (runwayLegIndex >= 0) {
                        this.createDirectToExisting(segmentIndex, runwayLegIndex, dtoExistingToRunwayCourse);
                    }
                }
                else {
                    // DTO target runway does not match the runway of the loaded approach (or the approach is circling only) ->
                    // activate DTO random to the old runway
                    this.createDirectToRandom(dtoExistingToRunwayIcao, dtoExistingToRunwayCourse);
                }
            }
            // Handle VTF appraoches without anything leading into the disco by activating them automatically.
            if (this.isApproachVtf()) {
                if (((_b = (_a = plan.segmentsOfType(msfssdk.FlightPlanSegmentType.Approach).next().value) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) <= 1) {
                    this.activateVtf();
                }
            }
            return true;
        }
        /**
         * Method to insert the approach legs.
         * @param facility The facility to build legs from.
         * @param approachIndex The approach procedure index to build legs from.
         * @param approachTransitionIndex The transition index to build legs from.
         * @param visualRunway If this is a visual approach, the visual approach one way runway object.
         * @param transStartIndex The starting leg index for the transition, if any.
         * @param skipCourseReversal Whether to skip the course reversal.
         * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
         * into the flight plan.
         */
        async buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal) {
            const isVisual = !!visualRunway;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const approach = isVisual ? FmsUtils.buildVisualApproach(facility, visualRunway, 1, 2.5) : facility.approaches[approachIndex];
            const transition = approach.transitions[approachTransitionIndex];
            const isVtf = approachTransitionIndex < 0;
            const insertProcedureObject = { procedureLegs: [] };
            if (transition !== undefined && transition.legs.length > 0) {
                const startIndex = transStartIndex !== undefined ? transStartIndex : 0;
                for (let t = startIndex; t < transition.legs.length; t++) {
                    insertProcedureObject.procedureLegs.push(msfssdk.FlightPlan.createLeg(transition.legs[t]));
                }
            }
            const lastTransitionLeg = insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1];
            if (isVtf) {
                insertProcedureObject.procedureLegs.push(msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity }));
            }
            const finalLegs = approach.finalLegs;
            for (let i = 0; i < finalLegs.length; i++) {
                const leg = msfssdk.FlightPlan.createLeg(finalLegs[i]);
                if (i === 0 && lastTransitionLeg && this.isDuplicateIFLeg(lastTransitionLeg, leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] = this.mergeDuplicateLegData(lastTransitionLeg, leg);
                    continue;
                }
                if (!isVisual && leg.fixIcao[0] === 'R') {
                    const approachRunway = msfssdk.RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
                    if (approachRunway) {
                        insertProcedureObject.runway = approachRunway;
                        const runwayLeg = FmsUtils.buildRunwayLeg(facility, approachRunway, false);
                        runwayLeg.altitude1 += 15; //Runway leg altitude should be 50 feet above threshold
                        insertProcedureObject.procedureLegs.push(runwayLeg);
                    }
                }
                else if (isVisual && i === finalLegs.length - 1) {
                    insertProcedureObject.runway = visualRunway;
                    insertProcedureObject.procedureLegs.push(leg);
                    if (approach.missedLegs.length > 0) {
                        insertProcedureObject.procedureLegs.push(approach.missedLegs[0]);
                    }
                }
                else {
                    insertProcedureObject.procedureLegs.push(leg);
                    if (isVtf && msfssdk.BitFlags.isAll(leg.fixTypeFlags, msfssdk.FixTypeFlags.FAF)) {
                        await this.insertVtfLegs(insertProcedureObject, leg, finalLegs[i - 1], finalLegs[i + 1]);
                    }
                }
            }
            if (!isVisual) {
                this.tryInsertIFLeg(insertProcedureObject);
                this.tryReconcileIAFLeg(insertProcedureObject);
                this.manageFafAltitudeRestriction(insertProcedureObject);
                this.tryCleanupHold(insertProcedureObject);
                if (skipCourseReversal) {
                    this.tryRemoveCourseReversal(insertProcedureObject);
                }
                this.tryInsertMap(insertProcedureObject);
                if (!insertProcedureObject.runway && approach.runway) {
                    insertProcedureObject.runway = msfssdk.RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
                }
                return insertProcedureObject;
            }
            return insertProcedureObject;
        }
        /**
         * Inserts vectors-to-final legs into an insert procedure object. Vectors to final legs consist of a discontinuity
         * leg followed by a CF leg to the final approach fix. The course of the CF leg (the vectors-to-final course) is
         * defined as follows:
         * * If the leg to the faf is a CF leg, the VTF course is equal to the CF leg course.
         * * If the leg to the faf is not an IF leg, the VTF course is defined by the great-circle path from the fix
         * immediately prior to the faf to the faf.
         * * If the leg to the faf is an IF leg, the VTF course is defined by the great-circle path from the faf to the fix
         * immediately following it.
         *
         * If a VTF course cannot be defined, then no vectors-to-final legs are inserted.
         * @param proc The insert procedure object to which to insert the vectors-to-final legs.
         * @param fafLeg The leg to the final approach fix in the procedure.
         * @param prevLeg The leg immediately prior to the faf leg.
         * @param nextLeg The leg immediately after the faf leg.
         */
        async insertVtfLegs(proc, fafLeg, prevLeg, nextLeg) {
            if (fafLeg.type === msfssdk.LegType.CF) {
                // faf leg is a CF -> copy the leg into the VTF sequence.
                const discoLeg = msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.ThruDiscontinuity });
                discoLeg.legDefinitionFlags = msfssdk.LegDefinitionFlags.VectorsToFinal;
                proc.procedureLegs.push(discoLeg);
                proc.procedureLegs.push(Object.assign({ legDefinitionFlags: msfssdk.LegDefinitionFlags.VectorsToFinal }, fafLeg));
            }
            else {
                try {
                    const fafFacility = await this.facLoader.getFacility(msfssdk.ICAO.getFacilityType(fafLeg.fixIcao), fafLeg.fixIcao);
                    const fafPoint = Fms.geoPointCache[0].set(fafFacility);
                    let course;
                    if (fafLeg.type === msfssdk.LegType.IF) {
                        // faf leg is an IF, meaning it is the first leg in the approach -> get the course from the next leg.
                        let nextLegFixIcao = '';
                        switch (nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.type) {
                            case msfssdk.LegType.IF:
                            case msfssdk.LegType.TF:
                            case msfssdk.LegType.DF:
                            case msfssdk.LegType.CF:
                            case msfssdk.LegType.AF:
                            case msfssdk.LegType.RF:
                            case msfssdk.LegType.HF:
                            case msfssdk.LegType.HM:
                            case msfssdk.LegType.HA:
                                nextLegFixIcao = nextLeg.fixIcao;
                        }
                        const nextLegFacility = await this.facLoader.getFacility(msfssdk.ICAO.getFacilityType(nextLegFixIcao), nextLegFixIcao);
                        course = msfssdk.MagVar.trueToMagnetic(fafPoint.bearingTo(nextLegFacility), fafPoint);
                    }
                    else {
                        // faf leg is not the first leg in the approach -> get the course from the previous leg.
                        let prevLegFixIcao = '';
                        switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.type) {
                            case msfssdk.LegType.IF:
                            case msfssdk.LegType.TF:
                            case msfssdk.LegType.DF:
                            case msfssdk.LegType.CF:
                            case msfssdk.LegType.AF:
                            case msfssdk.LegType.RF:
                            case msfssdk.LegType.HF:
                            case msfssdk.LegType.HM:
                            case msfssdk.LegType.HA:
                                prevLegFixIcao = prevLeg.fixIcao;
                        }
                        const prevLegFacility = await this.facLoader.getFacility(msfssdk.ICAO.getFacilityType(prevLegFixIcao), prevLegFixIcao);
                        course = msfssdk.MagVar.trueToMagnetic(fafPoint.bearingFrom(prevLegFacility), fafPoint);
                    }
                    const discoLeg = msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity });
                    discoLeg.legDefinitionFlags = msfssdk.LegDefinitionFlags.VectorsToFinal;
                    const vtfLeg = msfssdk.FlightPlan.createLeg({
                        type: msfssdk.LegType.CF,
                        fixIcao: fafLeg.fixIcao,
                        course,
                        fixTypeFlags: fafLeg.fixTypeFlags,
                        altDesc: fafLeg.altDesc,
                        altitude1: fafLeg.altitude1,
                        altitude2: fafLeg.altitude2
                    });
                    vtfLeg.legDefinitionFlags = msfssdk.LegDefinitionFlags.VectorsToFinal;
                    proc.procedureLegs.push(discoLeg);
                    proc.procedureLegs.push(vtfLeg);
                }
                catch (_a) {
                    // noop
                }
            }
        }
        /**
         * Manages the altitude constraints when adding a procedure by creating a VerticalData object for each leg.
         * @param plan The Flight Plan.
         * @param segmentIndex The segment index for the inserted procedure.
         */
        setVerticalData(plan, segmentIndex) {
            const segment = plan.getSegment(segmentIndex);
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                const altitude1 = leg.leg.altitude1;
                const altitude2 = leg.leg.altitude2;
                const altDesc = leg.leg.altDesc;
                const verticalData = {
                    altDesc: altDesc,
                    altitude1: altitude1,
                    altitude2: altitude2
                };
                plan.setLegVerticalData(segmentIndex, l, verticalData);
            }
        }
        /**
         * Method to set a user altitude constraint.
         * @param segmentIndex The segment index to insert the constraint at.
         * @param segmentLegIndex The leg index to insert the constraint at.
         * @param altitude The altitude to set the constraint at; if undefined, delete user constraint.
         * @param revert Whether to revert the constraint data to the nav data constraint.
         */
        setUserConstraint(segmentIndex, segmentLegIndex, altitude, revert = false) {
            if (this.hasPrimaryFlightPlan()) {
                const plan = this.getPrimaryFlightPlan();
                const verticalData = {
                    altDesc: altitude !== undefined ? msfssdk.AltitudeRestrictionType.At : msfssdk.AltitudeRestrictionType.Unused,
                    altitude1: altitude !== undefined ? msfssdk.UnitType.FOOT.convertTo(altitude, msfssdk.UnitType.METER) : 0,
                    altitude2: 0
                };
                if (revert) {
                    const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
                    if (leg !== null) {
                        const altitude1 = leg.leg.altitude1;
                        const altitude2 = leg.leg.altitude2;
                        const altDesc = leg.leg.altDesc;
                        verticalData.altDesc = altDesc;
                        verticalData.altitude1 = altitude1;
                        verticalData.altitude2 = altitude2;
                    }
                }
                plan.setLegVerticalData(segmentIndex, segmentLegIndex, verticalData);
                const directToData = plan.directToData;
                if (this.getDirectToState() === exports.DirectToState.TOEXISTING && segmentIndex === directToData.segmentIndex
                    && segmentLegIndex === directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET) {
                    plan.setLegVerticalData(segmentIndex, directToData.segmentLegIndex, verticalData);
                }
                plan.calculate();
            }
        }
        /**
         * Method to check if a leg has a user specified constraint.
         * @param segmentIndex The segment index to insert the constraint at.
         * @param segmentLegIndex The leg index to insert the constraint at.
         * @returns Whether the leg has a user constraint.
         */
        isConstraintUser(segmentIndex, segmentLegIndex) {
            if (this.hasPrimaryFlightPlan()) {
                const plan = this.getPrimaryFlightPlan();
                const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
                if ((leg === null || leg === void 0 ? void 0 : leg.verticalData.altDesc) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altDesc) || (leg === null || leg === void 0 ? void 0 : leg.verticalData.altitude1) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altitude1) || (leg === null || leg === void 0 ? void 0 : leg.verticalData.altitude2) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altitude2)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Method to check if a leg constraint can be reverted to the nav data constraint.
         * @param segmentIndex The segment index to insert the constraint at.
         * @param segmentLegIndex The leg index to insert the constraint at.
         * @returns Whether the leg has a nav data constraint to be reverted to.
         */
        hasConstraint(segmentIndex, segmentLegIndex) {
            if (this.hasPrimaryFlightPlan()) {
                const plan = this.getPrimaryFlightPlan();
                const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
                if (leg !== null && leg.leg.altDesc !== msfssdk.AltitudeRestrictionType.Unused) {
                    switch (leg.leg.altDesc) {
                        case msfssdk.AltitudeRestrictionType.At:
                        case msfssdk.AltitudeRestrictionType.AtOrAbove:
                        case msfssdk.AltitudeRestrictionType.AtOrBelow:
                            return msfssdk.UnitType.METER.convertTo(leg.leg.altitude1, msfssdk.UnitType.FOOT);
                        case msfssdk.AltitudeRestrictionType.Between:
                            return msfssdk.UnitType.METER.convertTo(leg.leg.altitude2, msfssdk.UnitType.FOOT);
                    }
                }
            }
            return undefined;
        }
        /**
         * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        manageFafAltitudeRestriction(proc) {
            proc.procedureLegs.forEach(leg => {
                if (leg.fixTypeFlags === msfssdk.FixTypeFlags.FAF && leg.altitude2 > 0) {
                    const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                    leg.altDesc = msfssdk.AltitudeRestrictionType.AtOrAbove;
                    leg.altitude1 = alt;
                    leg.altitude2 = 0;
                }
            });
            return proc;
        }
        /**
         * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        tryInsertIFLeg(proc) {
            const firstLeg = proc.procedureLegs[0];
            let icao;
            switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
                case msfssdk.LegType.HA:
                case msfssdk.LegType.HF:
                case msfssdk.LegType.HM:
                case msfssdk.LegType.PI:
                case msfssdk.LegType.FD:
                case msfssdk.LegType.FC:
                    icao = firstLeg.fixIcao;
                    break;
                case msfssdk.LegType.FM:
                case msfssdk.LegType.VM:
                    icao = firstLeg.originIcao;
                    break;
            }
            if (icao && icao !== msfssdk.ICAO.emptyIcao) {
                proc.procedureLegs.unshift(msfssdk.FlightPlan.createLeg({
                    type: msfssdk.LegType.IF,
                    fixIcao: icao,
                    fixTypeFlags: firstLeg.fixTypeFlags & (msfssdk.FixTypeFlags.IF | msfssdk.FixTypeFlags.IAF)
                }));
                if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === msfssdk.LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === msfssdk.LegType.PI) {
                    proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                    proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                    proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
                }
                // need to remove IF/IAF flags from the original first leg (now the second leg)
                const replacementLeg = msfssdk.FlightPlan.createLeg(proc.procedureLegs[1]);
                replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(msfssdk.FixTypeFlags.IF | msfssdk.FixTypeFlags.IAF);
                if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) !== msfssdk.LegType.PI) {
                    replacementLeg.altDesc = msfssdk.AltitudeRestrictionType.Unused;
                    replacementLeg.altitude1 = 0;
                    replacementLeg.altitude2 = 0;
                }
                proc.procedureLegs[1] = replacementLeg;
            }
            return proc;
        }
        /**
         * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
         * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
         * an IF leg type.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        tryReconcileIAFLeg(proc) {
            let iafIndex = -1;
            for (let i = 0; i < proc.procedureLegs.length; i++) {
                const leg = proc.procedureLegs[i];
                if (leg.fixTypeFlags === msfssdk.FixTypeFlags.IAF) {
                    iafIndex = i;
                    switch (leg.type) {
                        case msfssdk.LegType.HA:
                        case msfssdk.LegType.HF:
                        case msfssdk.LegType.HM:
                        case msfssdk.LegType.PI:
                        case msfssdk.LegType.FD:
                        case msfssdk.LegType.FC:
                            if (iafIndex > 0) {
                                leg.fixTypeFlags &= ~msfssdk.FixTypeFlags.IAF;
                                proc.procedureLegs[iafIndex - 1].fixTypeFlags |= msfssdk.FixTypeFlags.IAF;
                                iafIndex--;
                            }
                    }
                    break;
                }
            }
            return proc;
        }
        /**
         * Inserts a MAP fix type flag if none exists on the approach.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        tryInsertMap(proc) {
            let addMap = true;
            let runwayIndex = -1;
            for (let i = 0; i < proc.procedureLegs.length; i++) {
                const leg = proc.procedureLegs[i];
                if (leg.fixTypeFlags === msfssdk.FixTypeFlags.MAP) {
                    addMap = false;
                    break;
                }
                if (leg.fixIcao.search('R') === 0) {
                    runwayIndex = i;
                    break;
                }
            }
            if (addMap && runwayIndex > -1) {
                proc.procedureLegs[runwayIndex].fixTypeFlags = msfssdk.FixTypeFlags.MAP;
            }
            return proc;
        }
        /**
         * Method to remove the duplicate leg after the hold leg.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        tryCleanupHold(proc) {
            for (let i = 0; i < proc.procedureLegs.length; i++) {
                const leg = proc.procedureLegs[i];
                if (leg.type === msfssdk.LegType.HF) {
                    const next = proc.procedureLegs[i + 1];
                    if (leg.fixIcao === next.fixIcao && next.type === msfssdk.LegType.IF) {
                        proc.procedureLegs.splice(i + 1, 1);
                    }
                }
            }
            return proc;
        }
        /**
         * Method to remove a course reversal in an approach procedure.
         * @param proc A procedure object.
         * @returns the procedure object, after it has been changed.
         */
        tryRemoveCourseReversal(proc) {
            let canRemove = false;
            if (proc.procedureLegs.length > 2) {
                const leg = proc.procedureLegs[1];
                switch (leg.type) {
                    case msfssdk.LegType.HA:
                    case msfssdk.LegType.HF:
                    case msfssdk.LegType.HM:
                    case msfssdk.LegType.PI:
                        canRemove = true;
                }
            }
            if (canRemove) {
                proc.procedureLegs.splice(1, 1);
            }
            return proc;
        }
        /**
         * Method to remove the departure from the flight plan.
         */
        async removeDeparture() {
            const plan = this.getFlightPlan();
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Departure);
            plan.setDeparture();
            this.planClearSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Departure);
            if (plan.originAirport) {
                const airport = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.originAirport);
                const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Departure);
                this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
                const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
                const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
                if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                    this.planRemoveDuplicateLeg(prevLeg, nextLeg);
                }
            }
            plan.calculate(0);
        }
        /**
         * Method to remove the arrival from the flight plan.
         */
        async removeArrival() {
            const plan = this.getFlightPlan();
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Arrival);
            plan.setArrival();
            this.planRemoveSegment(segmentIndex);
            if (plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
                const airport = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.destinationAirport);
                const destSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Destination);
                this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, plan.procedureDetails.destinationRunway);
            }
            const prevLeg = plan.getPrevLeg(segmentIndex, 0);
            const nextLeg = plan.getNextLeg(segmentIndex, -1);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
            plan.calculate(0);
        }
        /**
         * Method to remove the approach from the flight plan.
         */
        async removeApproach() {
            this.loadApproachFrequency();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, msfssdk.RnavTypeFlags.None, false);
            const plan = this.getFlightPlan();
            const hasArrival = plan.procedureDetails.arrivalIndex >= 0;
            const segmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Approach);
            if (hasArrival) {
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const segment = plan.getSegment(lastEnrouteSegmentIndex);
                const lastLegIndex = segment && segment.legs.length > 0 ? segment.legs.length - 1 : 0;
                if (plan.destinationAirport && segment.legs[lastLegIndex] && segment.legs[lastLegIndex].leg.fixIcao === plan.destinationAirport) {
                    this.planRemoveLeg(lastEnrouteSegmentIndex, lastLegIndex);
                }
                plan.setDestinationRunway();
                if (plan.procedureDetails.arrivalFacilityIcao && plan.procedureDetails.arrivalFacilityIcao !== plan.destinationAirport) {
                    const arrivalFacility = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                    this.setDestination(arrivalFacility);
                }
            }
            plan.setApproach();
            this.planRemoveSegment(segmentIndex);
            if (plan.destinationAirport) {
                const airport = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.destinationAirport);
                const destLegSegmentIndex = hasArrival
                    ? this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Arrival)
                    : this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Destination);
                this.planAddOriginDestinationLeg(false, destLegSegmentIndex, airport, plan.procedureDetails.destinationRunway);
            }
            const prevLeg = plan.getPrevLeg(segmentIndex, 0);
            const nextLeg = plan.getNextLeg(segmentIndex, -1);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
            if (plan.getUserData('visual_approach')) {
                plan.deleteUserData('visual_approach');
            }
            plan.calculate(0);
        }
        /**
         * Method to activate a leg in the flight plan.
         * @param segmentIndex is the index of the segment containing the leg to activate.
         * @param legIndex is the index of the leg in the selected segment activate.
         * @param fplnIndex is the index of the flight plan in which to activate the leg.
         * @param inhibitImmediateSequence Whether to inhibit immediate automatic sequencing past the activated leg.
         */
        activateLeg(segmentIndex, legIndex, fplnIndex = 0, inhibitImmediateSequence = false) {
            const plan = this.getFlightPlan(fplnIndex);
            const indexInFlightplan = plan.getSegment(segmentIndex).offset + legIndex;
            if (fplnIndex === 0 && this.flightPlanner.activePlanIndex > 0) {
                this.flightPlanner.setActivePlanIndex(0);
            }
            if (this.missedApproachActive) {
                const segment = plan.getSegment(segmentIndex);
                if (segment.legs[legIndex] && !msfssdk.BitFlags.isAll(segment.legs[legIndex].flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                    this.bus.getPublisher().pub('activate_missed_approach', false, true);
                }
            }
            if (fplnIndex === 0
                && (segmentIndex < plan.directToData.segmentIndex || (segmentIndex === plan.directToData.segmentIndex && legIndex <= plan.directToData.segmentLegIndex))) {
                this.removeDirectToExisting(indexInFlightplan);
            }
            else {
                plan.setCalculatingLeg(indexInFlightplan);
                plan.calculate(Math.max(0, indexInFlightplan - 1));
                plan.setLateralLeg(indexInFlightplan);
            }
            const controlEvents = this.bus.getPublisher();
            controlEvents.pub('suspend_sequencing', false, true);
            if (inhibitImmediateSequence) {
                controlEvents.pub('lnav_inhibit_next_sequence', true, true);
            }
        }
        /**
         * Activates a vertical direct to a selected constraint.
         * @param constraintGlobalLegIndex The global leg index of the constraint to set vertical direct to.
         * @returns Whether the vertical direct was activated or not.
         */
        activateVerticalDirect(constraintGlobalLegIndex) {
            if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX) && this.verticalPathCalculator) {
                const lateralPlan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
                const verticalData = {
                    altDesc: msfssdk.AltitudeRestrictionType.Unused,
                    altitude1: 0,
                    altitude2: 0
                };
                if (lateralPlan.length > constraintGlobalLegIndex) {
                    for (let i = 0; i < constraintGlobalLegIndex; i++) {
                        lateralPlan.setLegVerticalData(i, verticalData);
                    }
                    this.verticalPathCalculator.activateVerticalDirect(Fms.PRIMARY_PLAN_INDEX, constraintGlobalLegIndex);
                    return true;
                }
            }
            return false;
        }
        /**
         * Checks whether an approach can be activated. An approach can be activated if and only if the primary flight plan
         * has a non-vectors-to-final approach loaded.
         * @returns Whether an approach can be activated.
         */
        canActivateApproach() {
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return false;
            }
            return FmsUtils.isApproachLoaded(plan) && !FmsUtils.isVtfApproachLoaded(plan);
        }
        /**
         * Activates an approach. Activating an approach activates a Direct To to the first approach waypoint of the primary
         * flight plan, and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary
         * flight plan does not have an approach loaded, this method has no effect.
         */
        activateApproach() {
            if (!this.canActivateApproach()) {
                return;
            }
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(msfssdk.FlightPlanSegmentType.Approach, false);
            this.createDirectToExisting(approachSegmentIndex, 0);
            this.setLocFrequency(1, true);
            this.setLocFrequency(2, true);
        }
        /**
         * Checks whether vectors-to-final can be activated. VTF can be activated if and only if the primary flight plan has
         * an approach loaded.
         * @returns Whether vectors-to-final can be activated.
         */
        canActivateVtf() {
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return false;
            }
            return FmsUtils.isApproachLoaded(plan);
        }
        /**
         * Activates vectors-to-final. Activating vectors-to-final activates the primary flight plan's vectors-to-final leg,
         * and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary flight plan
         * has a non-VTF approach loaded, it will be replaced by its VTF counterpart. If the primary flight plan has no
         * approach loaded, this method has no effect.
         */
        async activateVtf() {
            if (!this.canActivateVtf()) {
                return;
            }
            const plan = this.getPrimaryFlightPlan();
            let vtfLeg = FmsUtils.getApproachVtfLeg(plan);
            let approachType = ApproachType.APPROACH_TYPE_UNKNOWN;
            if (!vtfLeg) {
                // if a VTF approach is not loaded; replace the current approach with its VTF counterpart.
                try {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const airport = await this.facLoader.getFacility(msfssdk.FacilityType.Airport, plan.procedureDetails.approachFacilityIcao);
                    const visApproachRwyDesignation = plan.getUserData('visual_approach');
                    if (plan.procedureDetails.approachIndex >= 0) {
                        await this.insertApproach(airport, plan.procedureDetails.approachIndex, -1);
                        approachType = airport.approaches[plan.procedureDetails.approachIndex].approachType;
                    }
                    else {
                        let runway;
                        if (visApproachRwyDesignation) {
                            runway = msfssdk.RunwayUtils.matchOneWayRunwayFromDesignation(airport, visApproachRwyDesignation);
                        }
                        if (!runway) {
                            return;
                        }
                        approachType = msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL;
                        await this.insertApproach(airport, -1, -1, runway.direction, runway.runwayDesignator);
                    }
                    vtfLeg = FmsUtils.getApproachVtfLeg(plan);
                }
                catch (_a) {
                    return;
                }
            }
            else {
                approachType = this.approachDetails.approachType;
            }
            if (!vtfLeg) {
                return;
            }
            const segment = plan.getSegmentFromLeg(vtfLeg);
            if (!segment) {
                return;
            }
            this.activateLeg(segment.segmentIndex, segment.legs.indexOf(vtfLeg), Fms.PRIMARY_PLAN_INDEX, true);
            this.setLocFrequency(1, true);
            this.setLocFrequency(2, true);
            switch (approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                case ApproachType.APPROACH_TYPE_SDF:
                case ApproachType.APPROACH_TYPE_VOR:
                case ApproachType.APPROACH_TYPE_VORDME:
                    this.bus.getPublisher().pub('cdi_src_set', { type: msfssdk.NavSourceType.Nav, index: 1 }, true);
                    break;
            }
        }
        /**
         * Method to check if the approach is VTF.
         * @returns whether the approach is VTF.
         */
        isApproachVtf() {
            if (!this.hasPrimaryFlightPlan()) {
                return false;
            }
            const plan = this.getPrimaryFlightPlan();
            return FmsUtils.isVtfApproachLoaded(plan);
        }
        /**
         * Method to check if there is a currently loaded missed approach to be activated.
         * @returns whether the approach can activate
         */
        canMissedApproachActivate() {
            const plan = this.getFlightPlan();
            if (this.cdiSource.type === msfssdk.NavSourceType.Gps && plan && plan.activeLateralLeg < plan.length - 1 && plan.segmentCount > 0) {
                const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
                if (segmentIndex > 0) {
                    const segment = plan.getSegment(segmentIndex);
                    if (segment.segmentType === msfssdk.FlightPlanSegmentType.Approach
                        && msfssdk.BitFlags.isAll(segment.legs[segment.legs.length - 1].flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                        for (let i = 0; i < segment.legs.length; i++) {
                            const leg = segment.legs[i];
                            if (leg.leg.fixTypeFlags === msfssdk.FixTypeFlags.FAF) {
                                if (plan.activeLateralLeg - segment.offset >= i) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        /**
         * Method to activate the missed approach.
         */
        activateMissedApproach() {
            if (this.canMissedApproachActivate()) {
                this.bus.getPublisher().pub('activate_missed_approach', true, true);
            }
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        createDirectToRandom(target, course) {
            const icao = typeof target === 'string' ? target : target.icao;
            const plan = this.flightPlanner.createFlightPlan(1);
            plan.setCalculatingLeg(0);
            plan.setLateralLeg(0);
            for (let i = plan.segmentCount - 1; i >= 0; i--) {
                if (plan.getSegment(i) !== undefined) {
                    plan.removeSegment(i);
                }
            }
            plan.insertSegment(0, msfssdk.FlightPlanSegmentType.RandomDirectTo, undefined, true);
            const segment = plan.getSegment(0);
            if (segment) {
                const discoLeg = msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity });
                // Dup the disco leg if we have a defined course so that DTO sequences are always 3 legs long
                const dtoOriginLeg = course === undefined ? this.createDTOOriginLeg(this.ppos) : discoLeg;
                const dtoTargetLeg = this.createDTODirectLeg(icao, undefined, course);
                plan.addLeg(0, discoLeg, 0, msfssdk.LegDefinitionFlags.DirectTo);
                plan.addLeg(0, dtoOriginLeg, 1, msfssdk.LegDefinitionFlags.DirectTo);
                plan.addLeg(0, dtoTargetLeg, 2, msfssdk.LegDefinitionFlags.DirectTo);
                plan.calculate(0);
                plan.setCalculatingLeg(2);
                plan.setLateralLeg(2);
                if (this.flightPlanner.activePlanIndex !== 1) {
                    this.flightPlanner.setActivePlanIndex(1);
                }
                this.bus.getPublisher().pub('suspend_sequencing', false, true);
            }
        }
        /**
         * Method to create a direct to an existing waypoint in the plan. This method will also then call activateLeg.
         * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
         * @param legIndex is the index of the leg in the specified segment to activate as direct to.
         * @param course The magnetic course for the Direct To. If undefined, the Direct To will be initiated from the
         * airplane's present position.
         */
        createDirectToExisting(segmentIndex, legIndex, course) {
            const plan = this.getFlightPlan();
            const segment = plan.getSegment(segmentIndex);
            const leg = segment.legs[legIndex];
            let legIndexDelta = 0;
            if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
                legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && legIndex > plan.directToData.segmentLegIndex ? 3 : 0;
                if (this.getDirectToState() === exports.DirectToState.TOEXISTING) {
                    this.removeDirectToExisting();
                }
                else {
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                    plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                }
            }
            plan.setDirectToData(segmentIndex, legIndex + legIndexDelta);
            if (segment && leg) {
                const discoLeg = msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity });
                // Dup the disco leg if we have a defined course so that DTO sequences are always 3 legs long
                const dtoOriginLeg = course === undefined ? this.createDTOOriginLeg(this.ppos) : discoLeg;
                const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg, course);
                plan.addLeg(segmentIndex, discoLeg, legIndex + legIndexDelta + 1, msfssdk.LegDefinitionFlags.DirectTo);
                plan.addLeg(segmentIndex, dtoOriginLeg, legIndex + legIndexDelta + 2, msfssdk.LegDefinitionFlags.DirectTo);
                plan.addLeg(segmentIndex, dtoTargetLeg, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET, (leg.flags & msfssdk.LegDefinitionFlags.MissedApproach) | msfssdk.LegDefinitionFlags.DirectTo);
                plan.setLegVerticalData(segmentIndex, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET, leg.verticalData);
                this.activateLeg(segmentIndex, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET);
            }
        }
        /**
         * Creates a Direct-To origin IF leg.
         * @param ppos The current plane position.
         * @returns a Direct-To origin IF leg.
         */
        createDTOOriginLeg(ppos) {
            return msfssdk.FlightPlan.createLeg({
                type: msfssdk.LegType.IF,
                lat: ppos.lat,
                lon: ppos.lon
            });
        }
        /**
         * Creates a Direct-To target leg.
         * @param icao is the icao.
         * @param leg The FlightPlanLeg.
         * @param course The magnetic course for the Direct To.
         * @returns a Direct-To leg.
         */
        createDTODirectLeg(icao, leg, course) {
            let legType;
            if (course === undefined) {
                legType = msfssdk.LegType.DF;
                const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
                course = planeHeading === 0 ? 360 : planeHeading;
            }
            else {
                legType = msfssdk.LegType.CF;
            }
            if (leg) {
                const directLeg = Object.assign({}, leg);
                directLeg.type = legType;
                directLeg.course = course;
                directLeg.turnDirection = msfssdk.LegTurnDirection.None;
                return directLeg;
            }
            else {
                return msfssdk.FlightPlan.createLeg({
                    type: legType,
                    fixIcao: icao,
                    course
                });
            }
        }
        /**
         * Empties the primary flight plan.
         * @param doNotCreateDirectTo Option to skip creating a direct to random when deleting the plan.
         */
        async emptyPrimaryFlightPlan(doNotCreateDirectTo = false) {
            if (!this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
                return;
            }
            const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
            const directToState = this.getDirectToState();
            if (!doNotCreateDirectTo && (directToState === exports.DirectToState.TOEXISTING ||
                (directToState !== exports.DirectToState.TORANDOM && !Simplane.getIsGrounded() && plan.activeLateralLeg > 0))) {
                const directToIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
                if (directToIcao) {
                    const facType = msfssdk.ICAO.getFacilityType(directToIcao);
                    const fac = await this.facLoader.getFacility(facType, directToIcao);
                    this.createDirectToRandom(fac);
                }
            }
            for (let i = plan.segmentCount - 1; i >= 0; i--) {
                this.planRemoveSegment(i);
            }
            plan.addSegment(0, msfssdk.FlightPlanSegmentType.Departure);
            plan.addSegment(1, msfssdk.FlightPlanSegmentType.Enroute);
            plan.addSegment(2, msfssdk.FlightPlanSegmentType.Destination);
            plan.removeOriginAirport();
            plan.removeDestinationAirport();
            plan.setDirectToData(-1);
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, msfssdk.RnavTypeFlags.None, false);
            plan.setCalculatingLeg(0);
            plan.setLateralLeg(0);
            plan.setVerticalLeg(0);
        }
        /**
         * Builds a flight plan to preview a procedure.
         * @param calculator The flight path calculator to assign to the preview plan.
         * @param facility The airport facility to load the approach from
         * @param procType The type of procedure to preview.
         * @param procIndex The procedure index selected.
         * @param transIndex The transition index selected.
         * @param oneWayRunway The one way runway to build the preview with, if any.
         * @param rwyTransIndex The runway transition index selected, if any.
         * @param visualRunwayNumber is the visual runway number, if any.
         * @param visualRunwayDesignator is the visual runway designator, if any.
         * @param transStartIndex The transition start offset, if any.
         * @returns A Promise which is fulfilled with whether the preview plan was successfully built.
         */
        async buildProcedurePreviewPlan(calculator, facility, procType, procIndex, transIndex, oneWayRunway, rwyTransIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex) {
            var _a;
            const plan = new msfssdk.FlightPlan(0, calculator, msfssdk.FlightPlanner.buildDefaultLegName);
            let procedureLegObject;
            switch (procType) {
                case exports.ProcedureType.APPROACH:
                    procedureLegObject = await this.buildApproachLegs(facility, procIndex, transIndex, undefined, transStartIndex !== undefined ? transStartIndex : 0);
                    plan.addSegment(0, msfssdk.FlightPlanSegmentType.Approach, undefined, false);
                    break;
                case exports.ProcedureType.ARRIVAL: {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildArrivalLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, msfssdk.FlightPlanSegmentType.Arrival, undefined, false);
                    break;
                }
                case exports.ProcedureType.DEPARTURE: {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildDepartureLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, msfssdk.FlightPlanSegmentType.Departure, undefined, false);
                    break;
                }
                case exports.ProcedureType.VISUALAPPROACH:
                    if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
                        const visualRunway = msfssdk.RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
                        procedureLegObject = await this.buildApproachLegs(facility, -1, transIndex, visualRunway);
                        plan.addSegment(0, msfssdk.FlightPlanSegmentType.Approach, undefined, false);
                    }
                    break;
            }
            if (procedureLegObject && procedureLegObject.procedureLegs.length > 0) {
                // remove discontinuity legs from the start of the procedure
                while (((_a = procedureLegObject.procedureLegs[0]) === null || _a === void 0 ? void 0 : _a.type) === msfssdk.LegType.Discontinuity) {
                    procedureLegObject.procedureLegs.shift();
                }
                if (procedureLegObject.procedureLegs[0].type !== msfssdk.LegType.IF) {
                    const replacementLeg = msfssdk.FlightPlan.createLeg({
                        type: msfssdk.LegType.IF,
                        fixIcao: procedureLegObject.procedureLegs[0].fixIcao,
                        fixTypeFlags: procedureLegObject.procedureLegs[0].fixTypeFlags,
                    });
                    procedureLegObject.procedureLegs.splice(0, 1, replacementLeg);
                }
                const visualRunway = visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined
                    ? msfssdk.RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator)
                    : undefined;
                procedureLegObject.procedureLegs.forEach((l) => {
                    var _a;
                    // If the leg's fix is a visual approach fix, we need to add it to the facility repository so that others can
                    // look it up properly.
                    if (visualRunway !== undefined && msfssdk.ICAO.isFacility(l.fixIcao) && msfssdk.ICAO.getFacilityType(l.fixIcao) === msfssdk.FacilityType.VIS) {
                        this.addVisualFacilityFromLeg(l, visualRunway.designation);
                    }
                    plan.addLeg(0, l, undefined, (_a = l.legDefinitionFlags) !== null && _a !== void 0 ? _a : msfssdk.LegDefinitionFlags.None, false);
                });
                if (procType === exports.ProcedureType.APPROACH) {
                    // Adds missed approach legs
                    if (visualRunwayNumber === undefined && visualRunwayDesignator === undefined && procedureLegObject.procedureLegs.length > 0) {
                        const missedLegs = facility.approaches[procIndex].missedLegs;
                        if (missedLegs && missedLegs.length > 0) {
                            let maphIndex = -1;
                            for (let m = missedLegs.length - 1; m >= 0; m--) {
                                switch (missedLegs[m].type) {
                                    case msfssdk.LegType.HA:
                                    case msfssdk.LegType.HF:
                                    case msfssdk.LegType.HM:
                                        maphIndex = m - 1;
                                        break;
                                }
                            }
                            for (let n = 0; n < missedLegs.length; n++) {
                                const newLeg = msfssdk.FlightPlan.createLeg(missedLegs[n]);
                                if (maphIndex > 0 && n === maphIndex) {
                                    newLeg.fixTypeFlags |= msfssdk.FixTypeFlags.MAHP;
                                    plan.addLeg(0, newLeg, undefined, msfssdk.LegDefinitionFlags.MissedApproach, false);
                                }
                                else {
                                    plan.addLeg(0, newLeg, undefined, msfssdk.LegDefinitionFlags.MissedApproach, false);
                                }
                            }
                        }
                    }
                }
                await plan.calculate(0);
                return plan;
            }
            else {
                return plan;
            }
        }
        /**
         * Builds a flight plan to preview procedure transitions.
         * @param calculator The flight path calculator to assign to the preview plan.
         * @param facility The airport facility to which the procedure to preview belongs.
         * @param procType The type of procedure to preview.
         * @param procIndex The index of the procedure to preview.
         * @param excludeTransitionIndex The index of the transition to exclude in the preview.
         * @param rwyTransIndex The index of the procedure's runway transition.
         * @returns The index of the procedure transition preview plan.
         */
        async buildProcedureTransitionPreviewPlan(calculator, facility, procType, procIndex, excludeTransitionIndex, rwyTransIndex) {
            const plan = new msfssdk.FlightPlan(0, calculator, msfssdk.FlightPlanner.buildDefaultLegName);
            let legs;
            switch (procType) {
                case exports.ProcedureType.DEPARTURE:
                    if (facility.departures[procIndex] && rwyTransIndex !== undefined) {
                        legs = this.buildDepartureTransitionPreviewLegs(facility.departures[procIndex], excludeTransitionIndex, rwyTransIndex);
                    }
                    break;
                case exports.ProcedureType.ARRIVAL:
                    if (facility.arrivals[procIndex] && rwyTransIndex !== undefined) {
                        legs = this.buildArrivalTransitionPreviewLegs(facility.arrivals[procIndex], excludeTransitionIndex, rwyTransIndex);
                    }
                    break;
                case exports.ProcedureType.APPROACH:
                    if (facility.approaches[procIndex]) {
                        legs = this.buildApproachTransitionPreviewLegs(facility.approaches[procIndex], excludeTransitionIndex);
                    }
                    break;
            }
            if (legs && legs.length > 0) {
                plan.addSegment(0, msfssdk.FlightPlanSegmentType.Enroute, undefined, false);
                legs.forEach((l) => {
                    plan.addLeg(0, l, undefined, 0, false);
                });
                await plan.calculate(0);
            }
            return plan;
        }
        /**
         * Builds a sequence of legs for a departure transition preview. The sequence consists of the legs of each departure
         * transition in order. Discontinuity legs separate legs of different transitions.
         * @param departure A departure.
         * @param excludeTransitionIndex The index of the transition to exclude in the preview.
         * @param rwyTransIndex The runway transition index of the departure.
         * @returns A sequence of legs for a departure transition preview.
         */
        buildDepartureTransitionPreviewLegs(departure, excludeTransitionIndex, rwyTransIndex) {
            var _a;
            const runwayTransition = departure.runwayTransitions[rwyTransIndex];
            if (!runwayTransition && departure.runwayTransitions.length > 0) {
                return [];
            }
            const insertProcObject = { procedureLegs: [] };
            const legs = [];
            const preTransitionLegs = [];
            const lastCommonLeg = departure.commonLegs[departure.commonLegs.length - 1];
            const lastPreTransitionLeg = lastCommonLeg !== null && lastCommonLeg !== void 0 ? lastCommonLeg : runwayTransition.legs[runwayTransition.legs.length - 1];
            const secondLastPreTransitionLeg = lastPreTransitionLeg
                ? lastCommonLeg
                    ? (_a = departure.commonLegs[departure.commonLegs.length - 2]) !== null && _a !== void 0 ? _a : runwayTransition.legs[runwayTransition.legs.length - 1]
                    : runwayTransition.legs[runwayTransition.legs.length - 2]
                : undefined;
            secondLastPreTransitionLeg && preTransitionLegs.push(secondLastPreTransitionLeg);
            lastPreTransitionLeg && preTransitionLegs.push(lastPreTransitionLeg);
            const transitions = departure.enRouteTransitions;
            for (let i = 0; i < transitions.length; i++) {
                if (i === excludeTransitionIndex) {
                    continue;
                }
                const transition = transitions[i];
                if (transition.legs.length > 0) {
                    insertProcObject.procedureLegs.push(...preTransitionLegs);
                    for (let j = 0; j < transition.legs.length; j++) {
                        const leg = transition.legs[j];
                        if (j === 0 && lastPreTransitionLeg && this.isDuplicateIFLeg(lastPreTransitionLeg, leg)) {
                            continue;
                        }
                        insertProcObject.procedureLegs.push(leg);
                    }
                    this.tryCleanupHold(insertProcObject);
                    legs.push(...insertProcObject.procedureLegs, msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity }));
                    insertProcObject.procedureLegs.length = 0;
                }
            }
            return legs;
        }
        /**
         * Builds a sequence of legs for an arrival transition preview. The sequence consists of the legs of each arrival
         * transition in order. Discontinuity legs separate legs of different transitions.
         * @param arrival An arrival.
         * @param excludeTransitionIndex The index of the transition to exclude in the preview.
         * @param rwyTransIndex The runway transition index of the arrival.
         * @returns A sequence of legs for an arrival transition preview.
         */
        buildArrivalTransitionPreviewLegs(arrival, excludeTransitionIndex, rwyTransIndex) {
            var _a;
            const runwayTransition = arrival.runwayTransitions[rwyTransIndex];
            if (!runwayTransition && arrival.runwayTransitions.length > 0) {
                return [];
            }
            const insertProcObject = { procedureLegs: [] };
            const legs = [];
            const firstCommonLeg = arrival.commonLegs[0];
            const firstPostTransitionLeg = firstCommonLeg !== null && firstCommonLeg !== void 0 ? firstCommonLeg : runwayTransition.legs[0];
            const secondPostTransitionLeg = firstPostTransitionLeg
                ? firstCommonLeg
                    ? (_a = arrival.commonLegs[1]) !== null && _a !== void 0 ? _a : runwayTransition.legs[0]
                    : runwayTransition.legs[1]
                : undefined;
            const transitions = arrival.enRouteTransitions;
            for (let i = 0; i < transitions.length; i++) {
                if (i === excludeTransitionIndex) {
                    continue;
                }
                const transition = transitions[i];
                if (transition.legs.length > 0) {
                    for (let j = 0; j < transition.legs.length; j++) {
                        insertProcObject.procedureLegs.push(transition.legs[j]);
                    }
                    const lastTransitionLeg = insertProcObject.procedureLegs[insertProcObject.procedureLegs.length - 1];
                    if (firstPostTransitionLeg && !this.isDuplicateIFLeg(lastTransitionLeg, firstPostTransitionLeg)) {
                        insertProcObject.procedureLegs.push(firstPostTransitionLeg);
                        // need to add the second post-transition leg if the last transition leg is a PI leg and first post-
                        // transition leg is an IF so that the calculator can get an inbound course for the PI leg.
                        if (lastTransitionLeg.type === msfssdk.LegType.PI && firstPostTransitionLeg.type === msfssdk.LegType.IF && secondPostTransitionLeg) {
                            insertProcObject.procedureLegs.push(secondPostTransitionLeg);
                        }
                    }
                    this.tryInsertIFLeg(insertProcObject);
                    this.tryCleanupHold(insertProcObject);
                    legs.push(...insertProcObject.procedureLegs, msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity }));
                    insertProcObject.procedureLegs.length = 0;
                }
            }
            return legs;
        }
        /**
         * Builds a sequence of legs for an approach transition preview. The sequence consists of the legs of each approach
         * transition in order, followed by the first leg of the final approach. Discontinuity legs separate legs of
         * different transitions.
         * @param approach An approach.
         * @param excludeTransitionIndex The index of the transition to exclude in the preview.
         * @returns A sequence of legs for an approach transition preview.
         */
        buildApproachTransitionPreviewLegs(approach, excludeTransitionIndex) {
            const insertProcObject = { procedureLegs: [] };
            const legs = [];
            const firstFinalLeg = approach.finalLegs[0];
            const secondFinalLeg = approach.finalLegs[1];
            const transitions = approach.transitions;
            for (let i = 0; i < transitions.length; i++) {
                if (i === excludeTransitionIndex) {
                    continue;
                }
                const transition = transitions[i];
                if (transition.legs.length > 0) {
                    for (let j = 0; j < transition.legs.length; j++) {
                        insertProcObject.procedureLegs.push(transition.legs[j]);
                    }
                    const lastTransitionLeg = insertProcObject.procedureLegs[insertProcObject.procedureLegs.length - 1];
                    if (firstFinalLeg && !this.isDuplicateIFLeg(lastTransitionLeg, firstFinalLeg)) {
                        insertProcObject.procedureLegs.push(firstFinalLeg);
                        // need to add the second final approach leg if the last transition leg is a PI leg and first final leg is
                        // an IF so that the calculator can get an inbound course for the PI leg.
                        if (lastTransitionLeg.type === msfssdk.LegType.PI && firstFinalLeg.type === msfssdk.LegType.IF && secondFinalLeg) {
                            insertProcObject.procedureLegs.push(secondFinalLeg);
                        }
                    }
                    this.tryInsertIFLeg(insertProcObject);
                    this.tryCleanupHold(insertProcObject);
                    legs.push(...insertProcObject.procedureLegs, msfssdk.FlightPlan.createLeg({ type: msfssdk.LegType.Discontinuity }));
                    insertProcObject.procedureLegs.length = 0;
                }
            }
            return legs;
        }
        /**
         * Builds a temporary flight plan to preview an airway entry.
         * @param airway The airway object.
         * @param entry The entry intersection facility.
         * @param exit The exit intersection facility.
         * @returns the index of the temporary flight plan.
         */
        buildAirwayPreviewSegment(airway, entry, exit) {
            this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
            const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
            const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
            plan.insertSegment(0, msfssdk.FlightPlanSegmentType.Enroute, airway.name, false);
            if (airwayLegObject.procedureLegs.length > 0) {
                airwayLegObject.procedureLegs.forEach((l) => {
                    plan.addLeg(0, l, undefined, msfssdk.LegDefinitionFlags.None, false);
                });
                plan.calculate(0, true);
            }
            return Fms.PROC_PREVIEW_PLAN_INDEX;
        }
        /**
         * Adds an airway and airway segment to the flight plan.
         * @param airway The airway object.
         * @param entry The entry intersection facility.
         * @param exit The exit intersection facility.
         * @param segmentIndex Is the segment index for the entry leg.
         * @param legIndex Is the leg index of the entry leg in the segment of the
         */
        insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
            const plan = this.getFlightPlan();
            const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}.${msfssdk.ICAO.getIdent(exit.icao)}`, segmentIndex, legIndex);
            const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
            const airwayLegs = airwayLegObject.procedureLegs;
            for (let i = 1; i < airwayLegs.length; i++) {
                this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
            }
            // handle duplicates
            const airwaySegment = plan.getSegment(airwaySegmentIndex);
            const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
            const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
            if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
                const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
                const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
                const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
                if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === exports.AirwayLegType.ENTRY) {
                    // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                    // contain just the one leg)
                    this.planRemoveSegment(nextLegSegmentIndex);
                }
                else {
                    this.planRemoveDuplicateLeg(lastLeg, nextLeg);
                }
            }
            plan.calculate(0, true);
        }
        /**
         * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
         * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
         * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
         * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
         * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
         * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
         * removed.
         * @param airwayName The name of the airway.
         * @param entrySegmentIndex The index of the segment containing the airway entry leg.
         * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
         * @returns The index of the new airway segment.
         */
        prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
            const plan = this.getPrimaryFlightPlan();
            if (entrySegmentIndex < plan.directToData.segmentIndex
                || (entrySegmentIndex === plan.directToData.segmentIndex && entrySegmentLegIndex < plan.directToData.segmentLegIndex)) {
                this.removeDirectToExisting();
            }
            const entrySegment = plan.getSegment(entrySegmentIndex);
            const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
            let airwaySegmentIndex = entrySegmentIndex + 1;
            let removeLegsSegmentIndex = -1;
            let removeLegsFromIndex = -1;
            if (entrySegment.airway !== undefined) {
                // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
                removeLegsSegmentIndex = entrySegmentIndex;
                removeLegsFromIndex = entrySegmentLegIndex + 1;
            }
            else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
                // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
                removeLegsSegmentIndex = entrySegmentIndex + 1;
                removeLegsFromIndex = 0;
            }
            // remove legs as required
            if (removeLegsSegmentIndex >= 0) {
                const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
                if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === exports.AirwayLegType.EXIT_ENTRY) {
                    // preserve the airway entry leg
                    const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                    this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                    this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
                }
                if (removeLegsFromIndex > 0) {
                    while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                        this.planRemoveLeg(removeLegsSegmentIndex, removeLegsSegment.legs.length - 1, true, true);
                    }
                }
                else {
                    this.planRemoveSegment(removeLegsSegmentIndex);
                }
            }
            if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
                // entry leg is not the last leg in its segment -> split the segment after the entry leg
                airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
            }
            else if (plan.getSegment(entrySegmentIndex).segmentType === msfssdk.FlightPlanSegmentType.Enroute
                && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== msfssdk.FlightPlanSegmentType.Enroute)) {
                // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
                plan.insertSegment(airwaySegmentIndex, msfssdk.FlightPlanSegmentType.Enroute);
            }
            plan.insertSegment(airwaySegmentIndex, msfssdk.FlightPlanSegmentType.Enroute, airwayName);
            return airwaySegmentIndex;
        }
        /**
         * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
         * @param plan is the flight plan to edit.
         * @param segmentIndex Is the segment index for the entry leg.
         * @param legIndex Is the leg index of the entry leg in the segment of the
         * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
         */
        splitSegment(plan, segmentIndex, legIndex) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.segmentType === msfssdk.FlightPlanSegmentType.Enroute) {
                const nextSegmentIndex = this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, segmentIndex + 1);
                for (let i = legIndex + 1; i < segment.legs.length; i++) {
                    const leg = segment.legs[i].leg;
                    this.planAddLeg(nextSegmentIndex, leg);
                    this.planRemoveLeg(segmentIndex, i);
                }
                return nextSegmentIndex;
            }
            else if (segment.segmentType === msfssdk.FlightPlanSegmentType.Departure) {
                for (let i = legIndex + 1; i < segment.legs.length; i++) {
                    this.planRemoveLeg(segmentIndex, i);
                }
            }
            return segmentIndex;
        }
        /**
         * Builds a legs for an airway.
         * @param airway The airway object.
         * @param entry The entry intersection facility.
         * @param exit The exit intersection facility.
         * @returns the InsertProcedureObject.
         */
        buildAirwayLegs(airway, entry, exit) {
            const insertAirwayObject = { procedureLegs: [] };
            const waypoints = airway.waypoints;
            const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
            const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
            const ascending = exitIndex > entryIndex;
            if (ascending) {
                for (let i = entryIndex; i <= exitIndex; i++) {
                    const leg = msfssdk.FlightPlan.createLeg({
                        fixIcao: waypoints[i].icao,
                        type: i === entryIndex ? msfssdk.LegType.IF : msfssdk.LegType.TF
                    });
                    insertAirwayObject.procedureLegs.push(leg);
                }
            }
            else {
                for (let i = entryIndex; i >= exitIndex; i--) {
                    const leg = msfssdk.FlightPlan.createLeg({
                        fixIcao: waypoints[i].icao,
                        type: i === entryIndex ? msfssdk.LegType.IF : msfssdk.LegType.TF
                    });
                    insertAirwayObject.procedureLegs.push(leg);
                }
            }
            return insertAirwayObject;
        }
        /**
         * Method to remove an airway from the flight plan.
         * @param segmentIndex is the segment index of the airway to remove.
         */
        removeAirway(segmentIndex) {
            const plan = this.getFlightPlan();
            let combineSegments = false;
            const nextSegmentIsAirway = plan.getSegment(segmentIndex + 1).airway;
            if (segmentIndex > 0) {
                const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === msfssdk.FlightPlanSegmentType.Enroute
                    && plan.getSegment(segmentIndex - 1).airway === undefined;
                const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === msfssdk.FlightPlanSegmentType.Enroute
                    && plan.getSegment(segmentIndex + 1).airway === undefined;
                if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                    combineSegments = true;
                }
                let entryLeg = undefined;
                if (nextSegmentIsAirway) {
                    const segment = plan.getSegment(segmentIndex);
                    entryLeg = segment.legs[segment.legs.length - 1].leg;
                }
                this.planRemoveSegment(segmentIndex);
                if (combineSegments) {
                    this.mergeSegments(plan, segmentIndex - 1);
                }
                if (priorSegmentEnrouteNonAirway && entryLeg !== undefined) {
                    this.planAddLeg(segmentIndex - 1, entryLeg);
                }
                else if (entryLeg !== undefined) {
                    const newSegmentIndex = this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, segmentIndex);
                    this.planAddLeg(newSegmentIndex, entryLeg);
                }
            }
            plan.calculate(0, true);
        }
        /**
         * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
         * first, and the second segment is removed from the flight plan.
         * @param plan The flight plan to modify.
         * @param segmentIndex The index of the first segment to merge.
         */
        mergeSegments(plan, segmentIndex) {
            const segmentToGrow = plan.getSegment(segmentIndex);
            const segmentToRemove = plan.getSegment(segmentIndex + 1);
            const segmentToGrowOrigLength = segmentToGrow.legs.length;
            segmentToRemove.legs.forEach((l) => {
                plan.addLeg(segmentIndex, l.leg, undefined, l.flags);
            });
            if (plan.directToData.segmentIndex === segmentIndex + 1) {
                plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
            }
            this.planRemoveSegment(segmentIndex + 1);
        }
        /**
         * Inserts a hold-at-waypoint leg to the primary flight plan. The hold leg will be inserted immediately after the
         * specified parent leg. The hold leg must have the same fix as the parent leg.
         * @param planIndex The plan index to add the hold to.
         * @param segmentIndex The index of the segment that contains the hold's parent leg.
         * @param legIndex The index of the hold's parent leg in its segment.
         * @param holdLeg The hold leg to add.
         * @returns Whether the hold-at-waypoint leg was successfully inserted.
         */
        insertHold(planIndex, segmentIndex, legIndex, holdLeg) {
            const plan = this.hasFlightPlan(planIndex) && this.getFlightPlan(planIndex);
            if (!plan) {
                return false;
            }
            const prevLeg = plan.getPrevLeg(segmentIndex, legIndex + 1);
            if ((prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.fixIcao) !== holdLeg.fixIcao) {
                return false;
            }
            if (planIndex === Fms.PRIMARY_PLAN_INDEX) {
                this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
                return true;
            }
            else {
                plan.addLeg(segmentIndex, holdLeg);
                this.bus.getPublisher().pub('suspend_sequencing', false, true);
                return true;
            }
        }
        /**
         * Activates the nearest and most applicable leg of the primary flightplan.
         */
        activateNearestLeg() {
            const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
            if (!plan) {
                return;
            }
            //Filter to legs that we are potentially on
            const validLegs = [];
            for (const leg of plan.legs()) {
                const calcs = leg.calculated;
                if (calcs !== undefined) {
                    const position = this.getLegReferencePosition(leg);
                    if (position !== undefined && position >= 0 && position <= 1) {
                        validLegs.push(leg);
                    }
                }
            }
            //Try to active the second or last leg if we're beyond the end or the beginning of the plan
            if (validLegs.length === 0 && plan.length >= 2) {
                const secondLeg = plan.tryGetLeg(2);
                if (secondLeg !== null) {
                    const secondLegPosition = this.getLegReferencePosition(secondLeg);
                    if (secondLegPosition !== undefined && secondLegPosition > 1) {
                        const segmentIndex = plan.getSegmentIndex(plan.length - 1);
                        const segment = plan.getSegment(segmentIndex);
                        if (segment !== null) {
                            this.activateLeg(segment.segmentIndex, segment.legs.length - 1);
                        }
                    }
                    else if (secondLegPosition !== undefined && secondLegPosition <= 1) {
                        const segment = plan.getSegmentFromLeg(secondLeg);
                        if (segment !== null) {
                            this.activateLeg(segment.segmentIndex, segment.legs.indexOf(secondLeg));
                        }
                    }
                }
            }
            let closestLeg = undefined;
            let closestXtk = undefined;
            for (const leg of validLegs) {
                const calcs = leg.calculated;
                if (calcs !== undefined) {
                    const xtk = this.getClosestLegXtk(leg);
                    if (xtk !== undefined) {
                        if (closestXtk === undefined || xtk < closestXtk) {
                            closestLeg = leg;
                            closestXtk = xtk;
                        }
                    }
                }
            }
            if (closestLeg !== undefined) {
                const segment = plan.getSegmentFromLeg(closestLeg);
                if (segment !== null) {
                    this.activateLeg(segment.segmentIndex, segment.legs.indexOf(closestLeg));
                }
            }
        }
        /**
         * Gets the normalized leg reference position from the leg.
         * @param leg The leg to get the position for.
         * @returns The normalized reference position.
         */
        getLegReferencePosition(leg) {
            if (leg.calculated !== undefined && leg.calculated.flightPath.length > 0) {
                let numBefore = 0;
                let firstBeforePosition = 0;
                let numAfter = 0;
                let lastAfterPosition = 0;
                let latestInside = undefined;
                const flightPath = leg.calculated.flightPath;
                for (let i = 0; i < flightPath.length; i++) {
                    const vector = flightPath[i];
                    const circle = msfssdk.FlightPathUtils.setGeoCircleFromVector(flightPath[i], Fms.geoCircleCache[0]);
                    const start = Fms.geoPointCache[0].set(vector.startLat, vector.startLon);
                    const end = Fms.geoPointCache[1].set(vector.endLat, vector.endLon);
                    const position = msfssdk.FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.ppos);
                    if (position < 0) {
                        numBefore++;
                        if (i === 0) {
                            firstBeforePosition = position;
                        }
                    }
                    else if (position > 1) {
                        numAfter++;
                        if (i === flightPath.length - 1) {
                            lastAfterPosition = position;
                        }
                    }
                    else {
                        latestInside = position;
                    }
                }
                if (numBefore === flightPath.length) {
                    return firstBeforePosition;
                }
                else if (numAfter === flightPath.length) {
                    return lastAfterPosition;
                }
                else if (latestInside !== undefined) {
                    return latestInside;
                }
                else {
                    return undefined;
                }
            }
            return undefined;
        }
        /**
         * Gets the XTK of the closest vector on the leg.
         * @param leg The leg to get the XTK for.
         * @returns The closest leg vector XTK.
         */
        getClosestLegXtk(leg) {
            if (leg.calculated !== undefined) {
                return Math.min(...leg.calculated.flightPath.map(vector => {
                    const circle = msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, Fms.geoCircleCache[0]);
                    const start = Fms.geoPointCache[0].set(vector.startLat, vector.startLon);
                    const end = Fms.geoPointCache[1].set(vector.endLat, vector.endLon);
                    const position = msfssdk.FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.ppos);
                    if (position >= 0 || position <= 1) {
                        return Math.abs(circle.distance(this.ppos));
                    }
                    else {
                        return Number.MAX_SAFE_INTEGER;
                    }
                }));
            }
        }
        /**
         * Returns the index of the last element in the array where predicate is true, and -1
         * otherwise.
         * @param array The source array to search in
         * @param predicate find calls predicate once for each element of the array, in descending
         * order, until it finds one where predicate returns true. If such an element is found,
         * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
         * @param defaultReturn is the default value
         * @returns either the index or the default if the predicate criteria is not met
         */
        findLastSegmentIndex(array, predicate, defaultReturn = -1) {
            let l = array.length;
            while (l--) {
                if (predicate(array[l], l, array)) {
                    return array[l].segmentIndex;
                }
            }
            return defaultReturn;
        }
        /**
         * Adds a leg to the flight plan.
         * @param segmentIndex The segment to add the leg to.
         * @param leg The leg to add to the plan.
         * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
         * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
         * @param notify Whether or not to send notifications after the operation.
         */
        planAddLeg(segmentIndex, leg, index, flags = 0, notify = true) {
            const plan = this.getFlightPlan();
            const dtoLegIndex = plan.directToData.segmentLegIndex;
            const dtoSegmentIndex = plan.directToData.segmentIndex;
            if (dtoSegmentIndex >= 0
                && (segmentIndex < dtoSegmentIndex
                    || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex))) {
                this.removeDirectToExisting();
            }
            const segment = plan.getSegment(segmentIndex);
            const addIndex = index !== undefined ? index : Math.max(segment.legs.length - 1, 0);
            if (segment.segmentType === msfssdk.FlightPlanSegmentType.Approach
                && addIndex > 0
                && msfssdk.BitFlags.isAll(segment.legs[addIndex - 1].flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                flags |= msfssdk.LegDefinitionFlags.MissedApproach;
            }
            plan.addLeg(segmentIndex, leg, index, flags, notify);
            plan.calculate(plan.activeLateralLeg - 1);
            const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            if (activeSegmentIndex !== -1) {
                const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
                if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                    const newActiveLegIndex = plan.activeLateralLeg + 1;
                    plan.setCalculatingLeg(newActiveLegIndex);
                    plan.setLateralLeg(newActiveLegIndex);
                }
            }
            else {
                console.error('planAddLeg: activeSegmentIndex was -1');
            }
        }
        /**
         * Removes a leg from the flight plan.
         * @param segmentIndex The segment to add the leg to.
         * @param segmentLegIndex The index of the leg in the segment to remove.
         * @param notify Whether or not to send notifications after the operation. True by default.
         * @param skipDupCheck Whether to skip checking for duplicates. False by default.
         * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
         * located before the direct to target. False by default.
         * @returns whether a leg was removed.
         */
        planRemoveLeg(segmentIndex, segmentLegIndex, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
            const plan = this.getFlightPlan();
            if (segmentIndex < 0 || segmentIndex >= plan.segmentCount) {
                return false;
            }
            const toRemoveLeg = plan.getSegment(segmentIndex).legs[segmentLegIndex];
            if (!toRemoveLeg) {
                return false;
            }
            const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
            const isDirectToExistingActive = this.getDirectToState() === exports.DirectToState.TOEXISTING;
            let removed = false;
            const airwayLegType = this.getAirwayLegType(plan, segmentIndex, segmentLegIndex);
            if (airwayLegType !== exports.AirwayLegType.NONE) {
                removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex);
            }
            else {
                removed = plan.removeLeg(segmentIndex, segmentLegIndex, notify) !== null;
                if (!removed) {
                    return false;
                }
                const dtoLegIndex = plan.directToData.segmentLegIndex;
                const dtoSegmentIndex = plan.directToData.segmentIndex;
                if (!skipCancelDirectTo
                    && dtoSegmentIndex >= 0
                    && (segmentIndex < dtoSegmentIndex
                        || (segmentIndex === dtoSegmentIndex && segmentLegIndex <= dtoLegIndex))) {
                    // Need to adjust direct to data to compensate for removed leg.
                    if (segmentIndex === dtoSegmentIndex) {
                        plan.directToData.segmentLegIndex--;
                    }
                    if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && segmentLegIndex === dtoLegIndex) {
                        // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                        const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg.fixIcao;
                        this.createDirectToRandom(directIcao);
                    }
                    this.removeDirectToExisting(plan.activeLateralLeg - 1);
                }
                else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                    const newActiveLegIndex = plan.activeLateralLeg - 1;
                    plan.setCalculatingLeg(newActiveLegIndex);
                    plan.setLateralLeg(newActiveLegIndex);
                }
            }
            const prevLeg = removeLegGlobalIndex - 1 >= 0 ? plan.getLeg(removeLegGlobalIndex - 1) : null;
            const nextLeg = removeLegGlobalIndex < plan.length ? plan.getLeg(removeLegGlobalIndex) : null;
            // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
            if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
            if (!skipDupCheck) {
                this.checkAndRemoveEmptySegment(plan, segmentIndex);
            }
            plan.calculate(plan.activeLateralLeg - 1);
            return true;
        }
        /**
         * Handles removing a leg that is either in an airway segment or is an entry for an airway segment.
         * @param plan The flight plan containing the leg to remove.
         * @param airwayLegType The type of the leg to remove with respect to its associated airway.
         * @param segmentIndex The index of the segment containing the leg to remove.
         * @param segmentLegIndex The index of the leg to remove in its segment.
         * @returns Whether this handler processed the remove request.
         */
        removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex) {
            var _a, _b;
            const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
            let removed = false;
            let needReconcileDto = plan.directToData.segmentIndex >= 0;
            if (segmentIndex < plan.directToData.segmentIndex
                || (segmentIndex === plan.directToData.segmentIndex && segmentLegIndex <= plan.directToData.segmentLegIndex)) {
                // If there are DTO legs after the leg we are removing, we need to remove them (canceling the active DTO existing if necessary)
                if (this.getDirectToState() === exports.DirectToState.TOEXISTING && segmentLegIndex === plan.directToData.segmentLegIndex) {
                    // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                    const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg.fixIcao;
                    this.createDirectToRandom(directIcao);
                }
                this.removeDirectToExisting();
                needReconcileDto = false;
            }
            switch (airwayLegType) {
                case exports.AirwayLegType.ONROUTE: {
                    const segment = plan.getSegment(segmentIndex);
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    if (segmentLegIndex > 0) {
                        // Need to rename the airway segment with the new exit (if we removed the first leg after the entry, the
                        // airway segment will be deleted so no need to bother)
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        plan.setAirway(segmentIndex, segment.airway.replace(/\..*/, `.${segment.legs[segmentLegIndex - 1].name}`));
                    }
                    // We need to move the leg immediately after the removed leg to the next enroute segment
                    // (if the next enroute segment does not exist we will create one)
                    if (plan.segmentCount <= segmentIndex + 1 || plan.getSegment(segmentIndex + 1).segmentType !== msfssdk.FlightPlanSegmentType.Enroute) {
                        plan.insertSegment(segmentIndex + 1, msfssdk.FlightPlanSegmentType.Enroute);
                    }
                    const legAfterRemoved = segment.legs[segmentLegIndex].leg;
                    plan.addLeg(segmentIndex + 1, legAfterRemoved, 0);
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    if (segmentLegIndex < segment.legs.length) {
                        // There is at least one more leg in the original airway segment after the one we moved to the next enroute
                        // segment -> move these remaining legs into a new airway segment
                        const newEntrySegment = plan.getSegment(segmentIndex + 1);
                        let newAirwaySegmentIndex = segmentIndex + 2;
                        if (newEntrySegment.legs.length > 1) {
                            // need to split the segment containing the entry leg of the new airway segment
                            newAirwaySegmentIndex = this.splitSegment(plan, segmentIndex + 1, 0);
                        }
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const airwayName = segment.airway.replace(/\..*/, `.${segment.legs[segment.legs.length - 1].name}`);
                        plan.insertSegment(newAirwaySegmentIndex, msfssdk.FlightPlanSegmentType.Enroute, airwayName);
                        while (segment.legs.length > segmentLegIndex) {
                            const leg = segment.legs[segmentLegIndex].leg;
                            plan.removeLeg(segmentIndex, segmentLegIndex);
                            plan.addLeg(newAirwaySegmentIndex, leg);
                        }
                        // If the newly added airway segment is the last enroute segment, we need to insert an empty enroute segment
                        // after it to ensure that the last enroute segment in the plan is not an airway segment
                        if (newAirwaySegmentIndex >= plan.segmentCount - 1 || plan.getSegment(newAirwaySegmentIndex + 1).segmentType !== msfssdk.FlightPlanSegmentType.Enroute) {
                            plan.insertSegment(newAirwaySegmentIndex + 1, msfssdk.FlightPlanSegmentType.Enroute);
                        }
                    }
                    removed = true;
                    break;
                }
                case exports.AirwayLegType.ENTRY: {
                    if (plan.getSegment(segmentIndex).segmentType === msfssdk.FlightPlanSegmentType.Enroute) {
                        // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                        // and into the previous enroute segment to serve as the new entry leg.
                        const segment = plan.getSegment(segmentIndex + 1);
                        const leg = segment.legs[0].leg;
                        plan.removeLeg(segmentIndex + 1, 0);
                        this.checkAndRemoveEmptySegment(plan, segmentIndex + 1);
                        this.planAddLeg(segmentIndex, leg);
                    }
                    else if (plan.getSegment(segmentIndex).segmentType === msfssdk.FlightPlanSegmentType.Departure) {
                        // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                        // and into a newly created enroute segment placed before the airway segment to serve as the new entry leg.
                        this.planInsertSegmentOfType(msfssdk.FlightPlanSegmentType.Enroute, segmentIndex + 1);
                        const segment = plan.getSegment(segmentIndex + 2);
                        const leg = segment.legs[0].leg;
                        plan.removeLeg(segmentIndex + 2, 0);
                        this.checkAndRemoveEmptySegment(plan, segmentIndex + 2);
                        this.planAddLeg(segmentIndex + 1, leg);
                    }
                    removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                    break;
                }
                case exports.AirwayLegType.EXIT: {
                    if (segmentLegIndex < 1) {
                        // We are removing the only leg in the airway segment, so just delete the segment.
                        this.removeAirway(segmentIndex);
                        return true;
                    }
                    else {
                        // Remove the leg, then change the name of the airway segment to reflect the new exit waypoint.
                        const segment = plan.getSegment(segmentIndex);
                        const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                        segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[segmentLegIndex - 1].name : segment.airway;
                        plan.setAirway(segmentIndex, segment.airway);
                        removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                    }
                    break;
                }
                case exports.AirwayLegType.EXIT_ENTRY: {
                    // We need to move the first leg in the next airway segment out of that segment and into an enroute segment
                    // before the next airway segment.
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    if (segmentLegIndex < 1) {
                        // We are removing the only leg in the first airway segment, so just remove the segment.
                        plan.removeSegment(segmentIndex);
                        let prevSegmentIndex = segmentIndex - 1;
                        const prevSegment = plan.getSegment(prevSegmentIndex);
                        if (prevSegment.segmentType !== msfssdk.FlightPlanSegmentType.Enroute || prevSegment.airway !== undefined) {
                            plan.insertSegment(segmentIndex, msfssdk.FlightPlanSegmentType.Enroute);
                            prevSegmentIndex = segmentIndex;
                        }
                        plan.addLeg(prevSegmentIndex, leg);
                    }
                    else {
                        // Remove the leg from the first airway segment, then change the name of the airway segment to reflect the
                        // new exit waypoint.
                        plan.removeLeg(segmentIndex, segmentLegIndex);
                        plan.insertSegment(segmentIndex + 1, msfssdk.FlightPlanSegmentType.Enroute);
                        plan.addLeg(segmentIndex + 1, leg);
                        const firstAirwaySegment = plan.getSegment(segmentIndex);
                        const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                        firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[segmentLegIndex - 1].name : firstAirwaySegment.airway;
                        plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                    }
                    removed = true;
                }
            }
            if (removed) {
                if (needReconcileDto) {
                    FmsUtils.reconcileDirectToData(plan);
                }
                if (removeLegGlobalIndex <= plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                    const newActiveLegIndex = plan.activeLateralLeg - 1;
                    plan.setCalculatingLeg(newActiveLegIndex);
                    plan.setLateralLeg(newActiveLegIndex);
                }
            }
            return removed;
        }
        /**
         * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
         * segments that are followed by another Enroute segment are eligible to be removed if empty.
         * @param plan A flight plan.
         * @param segmentIndex The index of the segment to check.
         * @returns Whether the segment was removed.
         */
        checkAndRemoveEmptySegment(plan, segmentIndex) {
            if (this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
                this.planRemoveSegment(segmentIndex);
                const prevSegmentIndex = segmentIndex - 1;
                const nextSegmentIndex = segmentIndex;
                const prevSegment = prevSegmentIndex >= 0 ? plan.getSegment(prevSegmentIndex) : undefined;
                const nextSegment = nextSegmentIndex < plan.segmentCount ? plan.getSegment(nextSegmentIndex) : undefined;
                if ((prevSegment === null || prevSegment === void 0 ? void 0 : prevSegment.segmentType) === msfssdk.FlightPlanSegmentType.Enroute
                    && prevSegment.airway === undefined
                    && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) === msfssdk.FlightPlanSegmentType.Enroute
                    && nextSegment.airway === undefined) {
                    // We are left with two consecutive non-airway enroute segments -> merge the two
                    this.mergeSegments(plan, prevSegmentIndex);
                }
                return true;
            }
            else {
                return false;
            }
        }
        /**
         * Checks if a remove left an empty segment that also needs to be removed.
         * @param plan is the flight plan
         * @param segmentIndex The segment to add the leg to.
         * @returns whether to remove the segment.
         */
        checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
            const segment = plan.getSegment(segmentIndex);
            let nextSegment;
            if (segmentIndex < plan.segmentCount - 1) {
                nextSegment = plan.getSegment(segmentIndex + 1);
            }
            if (segment.legs.length < 1) {
                switch (segment.segmentType) {
                    case msfssdk.FlightPlanSegmentType.Enroute:
                        if (nextSegment && nextSegment.segmentType === msfssdk.FlightPlanSegmentType.Enroute) {
                            return true;
                        }
                        break;
                    //TODO: Add more cases as appropriate
                }
            }
            return false;
        }
        /**
         * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
         * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
         * segment.
         * @param isOrigin Whether to add an origin leg.
         * @param segmentIndex The index of the segment to which to add the leg.
         * @param airport The origin airport.
         * @param runway The origin runway.
         */
        planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
            let leg;
            if (runway) {
                leg = FmsUtils.buildRunwayLeg(airport, runway, isOrigin);
            }
            else {
                leg = msfssdk.FlightPlan.createLeg({
                    lat: airport.lat,
                    lon: airport.lon,
                    type: isOrigin ? msfssdk.LegType.IF : msfssdk.LegType.TF,
                    fixIcao: airport.icao,
                    altitude1: airport.runways[0].elevation + msfssdk.UnitType.FOOT.convertTo(50, msfssdk.UnitType.METER)
                });
            }
            if (leg) {
                this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
                if (!isOrigin) {
                    const plan = this.getFlightPlan();
                    const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                    const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                    for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                        if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                            this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                        }
                    }
                }
            }
        }
        /**
         * Method to add a segment to the flightplan.
         * @param segmentType is the FlightPlanSegmentType.
         * @param index is the optional segment index to insert the segment.
         * @returns the segment index of the inserted segment.
         */
        planInsertSegmentOfType(segmentType, index) {
            const plan = this.getFlightPlan();
            let segmentIndex = -1;
            if (index) {
                segmentIndex = index - 1;
            }
            else {
                const segments = [];
                for (const segment of plan.segments()) {
                    segments.push(segment);
                }
                switch (segmentType) {
                    case msfssdk.FlightPlanSegmentType.Origin:
                        break;
                    case msfssdk.FlightPlanSegmentType.Departure:
                        segmentIndex = 0;
                        break;
                    case msfssdk.FlightPlanSegmentType.Arrival:
                        segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                            return v.segmentType === msfssdk.FlightPlanSegmentType.Enroute;
                        }, 2);
                        break;
                    case msfssdk.FlightPlanSegmentType.Approach:
                        segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                            return v.segmentType === msfssdk.FlightPlanSegmentType.Enroute || v.segmentType === msfssdk.FlightPlanSegmentType.Arrival;
                        }, 2);
                        break;
                    case msfssdk.FlightPlanSegmentType.MissedApproach:
                        segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                            return v.segmentType === msfssdk.FlightPlanSegmentType.Approach;
                        }, 2);
                        break;
                    case msfssdk.FlightPlanSegmentType.Destination:
                        segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                            return v.segmentType === msfssdk.FlightPlanSegmentType.Enroute || v.segmentType === msfssdk.FlightPlanSegmentType.Arrival
                                || v.segmentType === msfssdk.FlightPlanSegmentType.Approach;
                        }, 5);
                        break;
                    default:
                        segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                            return v.segmentType === msfssdk.FlightPlanSegmentType.Enroute || v.segmentType === msfssdk.FlightPlanSegmentType.Arrival
                                || v.segmentType === msfssdk.FlightPlanSegmentType.Approach || v.segmentType === msfssdk.FlightPlanSegmentType.Destination;
                        }, 1);
                        segmentIndex--;
                        break;
                }
            }
            return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
        }
        /**
         * Method to remove all legs from a segment.
         * @param segmentIndex is the index of the segment to delete all legs from.
         * @param segmentType is the type if segment to delete all legs from, if known.
         */
        planClearSegment(segmentIndex, segmentType) {
            this.planRemoveSegment(segmentIndex);
            this.planInsertSegment(segmentIndex, segmentType);
        }
        /**
         * Inserts a segment into the flight plan at the specified index and
         * reflows the subsequent segments.
         * @param segmentIndex The index to insert the flight plan segment.
         * @param segmentType The type of segment this will be.
         * @param airway The airway this segment is made up of, if any
         * @param notify Whether or not to send notifications after the operation.
         * @returns The new flight plan segment.
         */
        planInsertSegment(segmentIndex, segmentType = msfssdk.FlightPlanSegmentType.Enroute, airway, notify = true) {
            const plan = this.getFlightPlan();
            const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
            plan.calculate(plan.activeLateralLeg - 1);
            if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
            }
            return segment;
        }
        /**
         * Removes a segment from the flight plan and reflows the segments following
         * the removed segment, not leaving an empty segment at the specified index.
         * @param segmentIndex The index of the segment to remove.
         * @param notify Whether or not to send notifications after the operation.
         */
        planRemoveSegment(segmentIndex, notify = true) {
            const plan = this.getFlightPlan();
            const segment = plan.getSegment(segmentIndex);
            const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            if (plan.directToData.segmentIndex >= 0) {
                if (segmentIndex < plan.directToData.segmentIndex) {
                    plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
                }
                else if (segmentIndex === plan.directToData.segmentIndex) {
                    plan.setDirectToData(-1);
                }
            }
            if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1) {
                const directIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
                this.removeDirectToExisting();
                if (this.getDirectToState() !== exports.DirectToState.TORANDOM) {
                    this.createDirectToRandom(directIcao);
                }
            }
            const newActiveLegIndex = plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
            plan.removeSegment(segmentIndex, notify);
            plan.calculate(plan.activeLateralLeg - 1);
        }
        /**
         * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
         * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
         * which is also an IF, TF, or DF leg.
         * @param leg1 The first leg.
         * @param leg2 The second leg.
         * @returns whether the second leg is a duplicate of the first.
         */
        isDuplicateLeg(leg1, leg2) {
            if (leg2.type !== msfssdk.LegType.IF
                && leg2.type !== msfssdk.LegType.DF
                && leg2.type !== msfssdk.LegType.TF
                && leg2.type !== msfssdk.LegType.CF) {
                return false;
            }
            const isLeg1TypeValidForDuplicate = leg1.type === msfssdk.LegType.IF
                || leg1.type === msfssdk.LegType.TF
                || leg1.type === msfssdk.LegType.DF
                || leg1.type === msfssdk.LegType.CF;
            if (!isLeg1TypeValidForDuplicate) {
                return false;
            }
            if (leg1.fixIcao === leg2.fixIcao) {
                return true;
            }
            const leg1Airport = msfssdk.ICAO.getAssociatedAirportIdent(leg1.fixIcao);
            const leg2Airport = msfssdk.ICAO.getAssociatedAirportIdent(leg2.fixIcao);
            if (leg1Airport.length > 0 && leg2Airport.length > 0 && leg1Airport !== leg2Airport) {
                return false;
            }
            if (leg1Airport.length > 0 && leg2Airport.length === 0 || leg2Airport.length > 0 && leg1Airport.length === 0) {
                if (msfssdk.ICAO.getRegionCode(leg1.fixIcao) === msfssdk.ICAO.getRegionCode(leg2.fixIcao)) {
                    return msfssdk.ICAO.getIdent(leg1.fixIcao) === msfssdk.ICAO.getIdent(leg2.fixIcao);
                }
            }
            return false;
        }
        /**
         * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
         * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
         * @param leg1 The first leg.
         * @param leg2 The second leg.
         * @returns whether the second leg is an duplicate IF leg of the first.
         */
        isDuplicateIFLeg(leg1, leg2) {
            if (leg2.type !== msfssdk.LegType.IF) {
                return false;
            }
            if (leg1.type !== msfssdk.LegType.TF
                && leg1.type !== msfssdk.LegType.DF
                && leg1.type !== msfssdk.LegType.RF
                && leg1.type !== msfssdk.LegType.CF
                && leg1.type !== msfssdk.LegType.AF
                && leg1.type !== msfssdk.LegType.IF) {
                return false;
            }
            return leg1.fixIcao === leg2.fixIcao;
        }
        /**
         * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
         * and all other data is derived from the target leg.
         * @param target The target leg.
         * @param source The source leg.
         * @returns the merged leg.
         */
        mergeDuplicateLegData(target, source) {
            const merged = msfssdk.FlightPlan.createLeg(target);
            merged.fixTypeFlags |= source.fixTypeFlags;
            merged.altDesc = source.altDesc;
            merged.altitude1 = source.altitude1;
            merged.altitude2 = source.altitude2;
            return merged;
        }
        /**
         * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
         * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
         * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
         * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
         * @param leg1 The first duplicate leg.
         * @param leg2 The second duplicate leg.
         * @returns the leg that was deleted, or null if neither leg was deleted.
         * @throws Error if direct to legs could not be updated.
         */
        planRemoveDuplicateLeg(leg1, leg2) {
            const plan = this.getFlightPlan();
            const leg1Segment = plan.getSegmentFromLeg(leg1);
            const leg1Index = plan.getLegIndexFromLeg(leg1);
            const leg2Segment = plan.getSegmentFromLeg(leg2);
            const leg2Index = plan.getLegIndexFromLeg(leg2);
            const prevLegIndex = leg1Index - 1;
            const prevLeg = plan.tryGetLeg(prevLegIndex);
            if (!leg1Segment || !leg2Segment) {
                return null;
            }
            const isLeg1DirectToLeg = msfssdk.BitFlags.isAll(leg1.flags, msfssdk.LegDefinitionFlags.DirectTo);
            const isLeg2DirectToLeg = msfssdk.BitFlags.isAll(leg2.flags, msfssdk.LegDefinitionFlags.DirectTo);
            const dupDirectToLeg = isLeg1DirectToLeg ? leg1
                : isLeg2DirectToLeg ? leg2
                    : null;
            if (dupDirectToLeg) {
                if (dupDirectToLeg.leg.type === msfssdk.LegType.IF) {
                    // Technically this should never happen.
                    return null;
                }
                else {
                    // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                    // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                    const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                    return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
                }
            }
            const isLeg1InProc = leg1Segment.segmentType !== msfssdk.FlightPlanSegmentType.Enroute;
            const isLeg2InProc = leg2Segment.segmentType !== msfssdk.FlightPlanSegmentType.Enroute;
            const prevLegIsIntercept = prevLeg !== null && (prevLeg.leg.type === msfssdk.LegType.CI || prevLeg.leg.type === msfssdk.LegType.VI);
            let toDeleteSegment;
            let toDeleteIndex;
            let toDeleteLeg;
            if (prevLegIsIntercept
                || (!isLeg1InProc && isLeg2InProc)
                || (isLeg1InProc && isLeg2InProc && leg1Segment !== leg2Segment)
                || msfssdk.BitFlags.isAny(leg2.leg.fixTypeFlags, msfssdk.FixTypeFlags.FAF | msfssdk.FixTypeFlags.MAP)) {
                toDeleteSegment = leg1Segment;
                toDeleteIndex = leg1Index - leg1Segment.offset;
                toDeleteLeg = leg1;
            }
            else {
                toDeleteSegment = leg2Segment;
                toDeleteIndex = leg2Index - leg2Segment.offset;
                //Merge data into first leg and replace
                const mergedLeg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
                const leg1SegmentLegIndex = leg1Index - leg1Segment.offset;
                plan.removeLeg(leg1Segment.segmentIndex, leg1SegmentLegIndex);
                plan.addLeg(leg1Segment.segmentIndex, mergedLeg, leg1SegmentLegIndex, leg2.flags);
                toDeleteLeg = leg2;
            }
            if (toDeleteIndex >= 0) {
                const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
                if (needMoveDtoLegs) {
                    const isDtoExistingActive = this.getDirectToState() === exports.DirectToState.TOEXISTING;
                    // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                    // that was not removed.
                    const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                    const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                    const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                    if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                        throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                    }
                    const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                    const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                    const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                    const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                    plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                    plan.addLeg(newTargetSegmentIndex, msfssdk.FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, msfssdk.LegDefinitionFlags.DirectTo);
                    plan.addLeg(newTargetSegmentIndex, msfssdk.FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, msfssdk.LegDefinitionFlags.DirectTo);
                    plan.addLeg(newTargetSegmentIndex, msfssdk.FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, msfssdk.LegDefinitionFlags.DirectTo);
                    if (isDtoExistingActive) {
                        const newActiveLegIndex = preservedLegIndex + FmsUtils.DTO_LEG_OFFSET;
                        plan.setCalculatingLeg(newActiveLegIndex);
                        plan.setLateralLeg(newActiveLegIndex);
                    }
                }
                const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
                if (success) {
                    return toDeleteLeg;
                }
            }
            return null;
        }
        /**
         * Converts an OBS course to a Direct-To. The OBS leg is assumed to be the currently active flight plan leg.
         * @param obsCourse The OBS course, in degrees magnetic.
         */
        convertObsToDirectTo(obsCourse) {
            const dtoState = this.getDirectToState();
            if (dtoState === exports.DirectToState.TORANDOM) {
                // Just replace the DTO random with one with a custom course
                const dtoTargetIcao = this.getDirectToTargetIcao();
                this.createDirectToRandom(dtoTargetIcao, obsCourse);
            }
            else if (dtoState === exports.DirectToState.TOEXISTING) {
                const dtoData = this.getPrimaryFlightPlan().directToData;
                this.createDirectToExisting(dtoData.segmentIndex, dtoData.segmentLegIndex, obsCourse);
            }
            else {
                const plan = this.getPrimaryFlightPlan();
                const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
                const segmentLegIndex = plan.getSegmentLegIndex(plan.activeLateralLeg);
                if (segmentIndex >= 0 && segmentLegIndex >= 0) {
                    this.createDirectToExisting(segmentIndex, segmentLegIndex, obsCourse);
                }
            }
        }
        /**
         * Loads an approach frequency into the fms.
         * @param facility The airport facility.
         * @param approachIndex The approach Index.
         */
        loadApproachFrequency(facility, approachIndex) {
            this.approachFrequency.set(FmsUtils.getApproachFrequency(facility, approachIndex));
        }
        /**
         * Loads an approach frequency into the fms.
         * @param radioIndex The radio index to set (1 or 2).
         * @param forceNotify resets the subject to force a cross-instrument notification.
         */
        setLocFrequency(radioIndex, forceNotify = false) {
            const approachFrequency = this.approachFrequency.get();
            if (forceNotify) {
                this.approachFrequency.set(undefined);
                this.approachFrequency.set(approachFrequency);
            }
            if (approachFrequency === undefined || Math.abs(this.navActiveFreqs[radioIndex].get() - approachFrequency.freqMHz) < 0.001) {
                return;
            }
            const setActive = this.cdiSource.type === msfssdk.NavSourceType.Gps || this.cdiSource.index !== radioIndex;
            SimVar.SetSimVarValue(`K:NAV${radioIndex}_STBY_SET_HZ`, 'Hz', approachFrequency.freqMHz * 1000000);
            if (setActive) {
                SimVar.SetSimVarValue(`K:NAV${radioIndex}_RADIO_SWAP`, 'Bool', 1);
            }
        }
        /**
         * Sets the approach details for the loaded approach and sends an event across the bus.
         * @param approachLoaded Whether an approach is loaded.
         * @param approachType The approach type.
         * @param approachRnavType The approach RNAV type.
         * @param approachIsActive Whether the approach is active.
         * @param approachIsCircling Whether the approach is a circling approach.
         */
        setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling) {
            const approachDetails = {
                approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
                approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
                approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
                approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive,
                approachIsCircling: approachIsCircling !== undefined ? approachIsCircling : this.approachDetails.approachIsCircling
            };
            if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
                this.checkApproachState();
                return;
            }
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
                this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
                this.bus.getPublisher().pub('approach_available', approachDetails.approachIsActive && approachDetails.approachLoaded, true);
                this.bus.getPublisher().pub('gp_available', this.isGpAvailable(), true);
            }
        }
        /**
         * Checks whether the approach details indicate that a GP should be available for tracking and display.
         * @returns whether or not the GP is available.
         */
        isGpAvailable() {
            if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive && !this.approachDetails.approachIsCircling) {
                switch (this.approachDetails.approachType) {
                    case ApproachType.APPROACH_TYPE_GPS:
                    case ApproachType.APPROACH_TYPE_RNAV:
                    case msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL:
                        return true;
                }
            }
            return false;
        }
    }
    Fms.PRIMARY_PLAN_INDEX = 0;
    Fms.DTO_RANDOM_PLAN_INDEX = 1;
    Fms.PROC_PREVIEW_PLAN_INDEX = 2;
    Fms.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
    Fms.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0)];

    /**
     * Setting modes for map orientation.
     */
    exports.MapOrientationSettingMode = void 0;
    (function (MapOrientationSettingMode) {
        MapOrientationSettingMode["NorthUp"] = "NorthUp";
        MapOrientationSettingMode["TrackUp"] = "TrackUp";
        MapOrientationSettingMode["HeadingUp"] = "HeadingUp";
    })(exports.MapOrientationSettingMode || (exports.MapOrientationSettingMode = {}));
    /**
     * Setting modes for map terrain display.
     */
    exports.MapTerrainSettingMode = void 0;
    (function (MapTerrainSettingMode) {
        MapTerrainSettingMode["None"] = "None";
        MapTerrainSettingMode["Absolute"] = "Absolute";
        MapTerrainSettingMode["Relative"] = "Relative";
    })(exports.MapTerrainSettingMode || (exports.MapTerrainSettingMode = {}));
    /**
     * Setting modes for map declutter.
     */
    exports.MapDeclutterSettingMode = void 0;
    (function (MapDeclutterSettingMode) {
        MapDeclutterSettingMode["All"] = "All";
        MapDeclutterSettingMode["Level3"] = "Level3";
        MapDeclutterSettingMode["Level2"] = "Level2";
        MapDeclutterSettingMode["Level1"] = "Level1";
    })(exports.MapDeclutterSettingMode || (exports.MapDeclutterSettingMode = {}));
    exports.MapTrafficAlertLevelSettingMode = void 0;
    (function (MapTrafficAlertLevelSettingMode) {
        MapTrafficAlertLevelSettingMode["All"] = "All";
        MapTrafficAlertLevelSettingMode["Advisories"] = "Advisories";
        MapTrafficAlertLevelSettingMode["TA_RA"] = "TA/RA";
        MapTrafficAlertLevelSettingMode["RA"] = "RA";
    })(exports.MapTrafficAlertLevelSettingMode || (exports.MapTrafficAlertLevelSettingMode = {}));
    /**
     * A utility class for working with map user settings.
     */
    class MapUserSettingsUtils {
    }
    /** An array of all map user setting names. */
    MapUserSettingsUtils.SETTING_NAMES = [
        'mapRangeIndex',
        'mapOrientation',
        'mapAutoNorthUpActive',
        'mapAutoNorthUpRangeIndex',
        'mapDeclutter',
        'mapTerrainMode',
        'mapTerrainRangeIndex',
        'mapTerrainScaleShow',
        'mapAirportLargeShow',
        'mapAirportLargeRangeIndex',
        'mapAirportMediumShow',
        'mapAirportMediumRangeIndex',
        'mapAirportSmallShow',
        'mapAirportSmallRangeIndex',
        'mapVorShow',
        'mapVorRangeIndex',
        'mapNdbShow',
        'mapNdbRangeIndex',
        'mapIntersectionShow',
        'mapIntersectionRangeIndex',
        'mapUserWaypointShow',
        'mapUserWaypointRangeIndex',
        'mapAirspaceClassBShow',
        'mapAirspaceClassBRangeIndex',
        'mapAirspaceClassCShow',
        'mapAirspaceClassCRangeIndex',
        'mapAirspaceClassDShow',
        'mapAirspaceClassDRangeIndex',
        'mapAirspaceRestrictedShow',
        'mapAirspaceRestrictedRangeIndex',
        'mapAirspaceMoaShow',
        'mapAirspaceMoaRangeIndex',
        'mapAirspaceOtherShow',
        'mapAirspaceOtherRangeIndex',
        'mapTrafficShow',
        'mapTrafficRangeIndex',
        'mapTrafficLabelShow',
        'mapTrafficLabelRangeIndex',
        'mapTrafficAlertLevelMode',
        'mapNexradShow',
        'mapNexradRangeIndex',
        'mapTrackVectorShow',
        'mapTrackVectorLookahead',
        'mapAltitudeArcShow'
    ];

    /**
     * A collection of common keys used by the GarminMap API.
     */
    class GarminMapKeys {
    }
    GarminMapKeys.Units = 'units';
    GarminMapKeys.Range = 'range';
    GarminMapKeys.RangeRTR = 'rangeRTR';
    GarminMapKeys.UseRangeSetting = 'useRangeSettingModerator';
    GarminMapKeys.Orientation = 'orientation';
    GarminMapKeys.OrientationRTR = 'orientationRTR';
    GarminMapKeys.OrientationControl = 'orientationControlModerator';
    GarminMapKeys.Declutter = 'declutter';
    GarminMapKeys.Terrain = 'terrain';
    GarminMapKeys.Nexrad = 'nexrad';
    GarminMapKeys.RangeRing = 'rangeRing';
    GarminMapKeys.RangeCompass = 'rangeCompass';
    GarminMapKeys.Crosshair = 'crosshair';
    GarminMapKeys.WaypointDisplayBuilder = 'waypointDisplayBuilder';
    GarminMapKeys.WaypointsVisibility = 'waypointsVis';
    GarminMapKeys.WaypointHighlight = 'waypointHighlight';
    GarminMapKeys.WaypointHighlightLine = 'waypointHighlightLine';
    GarminMapKeys.WaypointHighlightRTR = 'waypointHighlightRTR';
    GarminMapKeys.FlightPlanWaypoints = 'flightPlanWaypoints';
    GarminMapKeys.FlightPlanFocus = 'flightPlanFocus';
    GarminMapKeys.AirspaceVisibility = 'airspaceVis';
    GarminMapKeys.Traffic = 'garminTraffic';
    GarminMapKeys.TrafficRange = 'trafficRange';
    GarminMapKeys.Pointer = 'pointer';
    GarminMapKeys.PointerRTR = 'pointerRTR';
    GarminMapKeys.PointerInfo = 'pointerInfo';
    GarminMapKeys.AltitudeArc = 'altitudeArc';
    GarminMapKeys.TrackVector = 'trackVector';
    GarminMapKeys.MiniCompass = 'miniCompass';
    GarminMapKeys.Nearest = 'nearest';
    GarminMapKeys.ProcedurePreview = 'procedurePreview';
    GarminMapKeys.DataIntegrityRTR = 'dataIntegrityRTR';
    GarminMapKeys.TopLeftIndicators = 'topLeftIndicators';
    GarminMapKeys.TopRightIndicators = 'topRightIndicators';
    GarminMapKeys.BottomLeftIndicators = 'bottomLeftIndicators';
    GarminMapKeys.BottomCenterIndicators = 'bottomCenterIndicators';
    GarminMapKeys.BottomRightIndicators = 'bottomRightIndicators';
    GarminMapKeys.CenterIndicators = 'centerIndicators';

    /**
     * Airspace show types for Garmin maps.
     */
    exports.AirspaceShowType = void 0;
    (function (AirspaceShowType) {
        AirspaceShowType["ClassB"] = "ClassB";
        AirspaceShowType["ClassC"] = "ClassC";
        AirspaceShowType["ClassD"] = "ClassD";
        AirspaceShowType["Restricted"] = "Restricted";
        AirspaceShowType["MOA"] = "MOA";
        AirspaceShowType["Other"] = "Other";
    })(exports.AirspaceShowType || (exports.AirspaceShowType = {}));
    /**
     * A utility class containing a map of Garmin map airspace show types to their associated boundary filters.
     */
    class GarminAirspaceShowTypeMap {
    }
    /** A map of Garmin map airspace show types to their associated boundary filters. */
    GarminAirspaceShowTypeMap.MAP = {
        [exports.AirspaceShowType.ClassB]: 1 << msfssdk.BoundaryType.ClassB,
        [exports.AirspaceShowType.ClassC]: 1 << msfssdk.BoundaryType.ClassC,
        [exports.AirspaceShowType.ClassD]: 1 << msfssdk.BoundaryType.ClassD,
        [exports.AirspaceShowType.Restricted]: msfssdk.BitFlags.union(1 << msfssdk.BoundaryType.Restricted, 1 << msfssdk.BoundaryType.Prohibited),
        [exports.AirspaceShowType.MOA]: 1 << msfssdk.BoundaryType.MOA,
        [exports.AirspaceShowType.Other]: msfssdk.BitFlags.union(1 << msfssdk.BoundaryType.ClassE, 1 << msfssdk.BoundaryType.Warning, 1 << msfssdk.BoundaryType.Alert, 1 << msfssdk.BoundaryType.Danger, 1 << msfssdk.BoundaryType.Training)
    };

    exports.MapDeclutterMode = void 0;
    (function (MapDeclutterMode) {
        MapDeclutterMode[MapDeclutterMode["All"] = 0] = "All";
        MapDeclutterMode[MapDeclutterMode["Level3"] = 1] = "Level3";
        MapDeclutterMode[MapDeclutterMode["Level2"] = 2] = "Level2";
        MapDeclutterMode[MapDeclutterMode["Level1"] = 3] = "Level1";
    })(exports.MapDeclutterMode || (exports.MapDeclutterMode = {}));
    /**
     * A module describing the declutter mode.
     */
    class MapDeclutterModule {
        constructor() {
            this.mode = msfssdk.Subject.create(exports.MapDeclutterMode.All);
        }
    }

    /**
     * Controls the visibility of a specific type of map symbol whose visibility is dependent on its own show and maximum
     * range index settings as well as the global map declutter setting.
     */
    class MapSymbolVisController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param showSetting A subscribable which provides the show setting of this controller's symbol.
         * @param rangeIndexSetting A subscribable which provides the maximum range index setting of this controller's
         * symbol.
         * @param maxDeclutterMode The highest global declutter mode, inclusive, at which this controller's symbol remains
         * visible.
         * @param symbolVisibility The mutable subscribable which controls the visibility of this controller's symbol.
         */
        constructor(context, showSetting, rangeIndexSetting, maxDeclutterMode, symbolVisibility) {
            super(context);
            this.showSetting = showSetting;
            this.rangeIndexSetting = rangeIndexSetting;
            this.maxDeclutterMode = maxDeclutterMode;
            this.symbolVisibility = symbolVisibility;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.declutterModule = this.context.model.getModule(GarminMapKeys.Declutter);
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a, _b;
            this.isSymbolVisible = msfssdk.MappedSubject.create(([showSetting, rangeIndexSetting, rangeIndex, declutterMode]) => {
                return showSetting && (declutterMode <= this.maxDeclutterMode) && (rangeIndex <= rangeIndexSetting);
            }, this.showSetting, this.rangeIndexSetting, this.rangeModule.nominalRangeIndex, (_b = (_a = this.declutterModule) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(0));
            this.isSymbolVisiblePipe = this.isSymbolVisible.pipe(this.symbolVisibility);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.isSymbolVisible) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.isSymbolVisiblePipe) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * Controls the visibility of map airspace boundaries.
     */
    class MapAirspaceVisController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param settingManager A setting manager containing the user settings controlling airspace visibility.
         */
        constructor(context, settingManager) {
            var _a, _b, _c, _d, _e, _f;
            super(context);
            this.airspaceModule = this.context.model.getModule(msfssdk.MapSystemKeys.Airspace);
            this.controllers = [];
            const classBShow = settingManager.tryGetSetting('mapAirspaceClassBShow');
            const classBRangeIndex = (_a = settingManager.tryGetSetting('mapAirspaceClassBRangeIndex')) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (classBShow) {
                this.controllers.push(new MapSymbolVisController(context, classBShow, classBRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.ClassB]));
            }
            const classCShow = settingManager.tryGetSetting('mapAirspaceClassCShow');
            const classCRangeIndex = (_b = settingManager.tryGetSetting('mapAirspaceClassCRangeIndex')) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (classCShow) {
                this.controllers.push(new MapSymbolVisController(context, classCShow, classCRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.ClassC]));
            }
            const classDShow = settingManager.tryGetSetting('mapAirspaceClassDShow');
            const classDRangeIndex = (_c = settingManager.tryGetSetting('mapAirspaceClassDRangeIndex')) !== null && _c !== void 0 ? _c : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (classDShow) {
                this.controllers.push(new MapSymbolVisController(context, classDShow, classDRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.ClassD]));
            }
            const moaShow = settingManager.tryGetSetting('mapAirspaceMoaShow');
            const moaRangeIndex = (_d = settingManager.tryGetSetting('mapAirspaceMoaRangeIndex')) !== null && _d !== void 0 ? _d : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (moaShow) {
                this.controllers.push(new MapSymbolVisController(context, moaShow, moaRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.MOA]));
            }
            const restrictedShow = settingManager.tryGetSetting('mapAirspaceRestrictedShow');
            const restrictedRangeIndex = (_e = settingManager.tryGetSetting('mapAirspaceRestrictedRangeIndex')) !== null && _e !== void 0 ? _e : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (restrictedShow) {
                this.controllers.push(new MapSymbolVisController(context, restrictedShow, restrictedRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.Restricted]));
            }
            const otherShow = settingManager.tryGetSetting('mapAirspaceOtherShow');
            const otherRangeIndex = (_f = settingManager.tryGetSetting('mapAirspaceOtherRangeIndex')) !== null && _f !== void 0 ? _f : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (otherShow) {
                this.controllers.push(new MapSymbolVisController(context, otherShow, otherRangeIndex, exports.MapDeclutterMode.Level3, this.airspaceModule.show[exports.AirspaceShowType.Other]));
            }
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.controllers.forEach(controller => { controller.onAfterMapRender(); });
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.controllers.forEach(controller => { controller.destroy(); });
        }
    }

    /**
     * Utility class defining the priority values for common resource consumers.
     */
    class MapResourcePriority {
    }
    /** Default follow player airplane behavior. */
    MapResourcePriority.FOLLOW_AIRPLANE = 0;
    /** Rotation behavior from orientation mode. */
    MapResourcePriority.ORIENTATION_ROTATION = 0;
    /** Pointer. */
    MapResourcePriority.POINTER = 100;
    /** Waypoint highlight. */
    MapResourcePriority.WAYPOINT_HIGHLIGHT = 75;
    /** Flight plan focus. */
    MapResourcePriority.FLIGHT_PLAN_FOCUS = 50;
    /** Data integrity. */
    MapResourcePriority.DATA_INTEGRITY = 25;

    /**
     * Orientation types for a map.
     */
    exports.MapOrientation = void 0;
    (function (MapOrientation) {
        MapOrientation[MapOrientation["NorthUp"] = 0] = "NorthUp";
        MapOrientation[MapOrientation["TrackUp"] = 1] = "TrackUp";
        MapOrientation[MapOrientation["HeadingUp"] = 2] = "HeadingUp";
    })(exports.MapOrientation || (exports.MapOrientation = {}));
    /**
     * A module describing the map orientation.
     */
    class MapOrientationModule {
        constructor() {
            /** The orientation of the map. */
            this.orientation = msfssdk.Subject.create(exports.MapOrientation.HeadingUp);
        }
    }

    /**
     * Controls the map's projected target, orientation mode, and player airplane icon based on heading and GPS signal validity.
     */
    class MapDataIntegrityRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param airplaneIconSrc A mutable subscribable which controls the player airplane icon's image source URI.
         * Required for this controller to change the player airplane icon.
         * @param airplaneIconAnchor A mutable subscribable which controls the anchor point of the player airplane icon.
         * Required for this controller to change the player airplane icon.
         * @param normalIconSrc A subscribable which provides the URI of the normal player airplane icon's image source.
         * Required for this controller to change the player airplane icon.
         * @param normalIconAnchor A subscribable which provides the anchor point of the normal player airplane icon, as
         * `[x, y]`, where each component is relative to the width or height of the icon. Required for this controller to
         * change the player airplane icon.
         * @param noHeadingIconSrc A subscribable which provides the URI of the no-heading player airplane icon's image
         * source. Required for this controller to change the player airplane icon.
         * @param noHeadingIconAnchor A subscribable which provides the anchor point of the no-heading player airplane icon,
         * as `[x, y]`, where each component is relative to the width or height of the icon. Required for this controller to
         * change the player airplane icon.
         */
        constructor(context, airplaneIconSrc, airplaneIconAnchor, normalIconSrc, normalIconAnchor, noHeadingIconSrc, noHeadingIconAnchor) {
            super(context);
            this.airplaneIconSrc = airplaneIconSrc;
            this.airplaneIconAnchor = airplaneIconAnchor;
            this.normalIconSrc = normalIconSrc;
            this.normalIconAnchor = normalIconAnchor;
            this.noHeadingIconSrc = noHeadingIconSrc;
            this.noHeadingIconAnchor = noHeadingIconAnchor;
            this.dataIntegrityModule = this.context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
            this.orientationModule = this.context.model.getModule(GarminMapKeys.Orientation);
            this.ownAirplaneIconModule = this.context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneIcon);
            this.targetControl = this.context[msfssdk.MapSystemKeys.TargetControl];
            this.targetControlConsumer = {
                priority: MapResourcePriority.DATA_INTEGRITY,
                onAcquired: () => { },
                onCeded: () => { }
            };
            this.orientationControl = this.context[GarminMapKeys.OrientationControl];
            this.orientationControlConsumer = {
                priority: MapResourcePriority.DATA_INTEGRITY,
                onAcquired: () => {
                    var _a;
                    (_a = this.orientationModule) === null || _a === void 0 ? void 0 : _a.orientation.set(exports.MapOrientation.NorthUp);
                },
                onCeded: () => { }
            };
            this.canChangeAirplaneIcon = this.airplaneIconSrc !== undefined
                && this.airplaneIconAnchor !== undefined
                && this.normalIconSrc !== undefined
                && this.normalIconAnchor !== undefined
                && this.noHeadingIconSrc !== undefined
                && this.noHeadingIconAnchor !== undefined;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            if (this.canChangeAirplaneIcon) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.normalIconSrcPipe = this.normalIconSrc.pipe(this.airplaneIconSrc, true);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.normalIconAnchorPipe = this.normalIconAnchor.pipe(this.airplaneIconAnchor, true);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.noHeadingIconSrcPipe = this.noHeadingIconSrc.pipe(this.airplaneIconSrc, true);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.noHeadingIconAnchorPipe = this.noHeadingIconAnchor.pipe(this.airplaneIconAnchor, true);
            }
            this.headingSignalSub = this.dataIntegrityModule.headingSignalValid.sub(isValid => {
                var _a, _b;
                if (isValid) {
                    (_a = this.orientationControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.orientationControlConsumer);
                    this.setNormalAirplaneIcon();
                }
                else {
                    this.setNoHeadingAirplaneIcon();
                    if (this.orientationControl === undefined) {
                        (_b = this.orientationModule) === null || _b === void 0 ? void 0 : _b.orientation.set(exports.MapOrientation.NorthUp);
                    }
                    else {
                        this.orientationControl.claim(this.orientationControlConsumer);
                    }
                }
            }, true);
            this.gpsSignalSub = this.dataIntegrityModule.gpsSignalValid.sub(isValid => {
                var _a, _b, _c, _d;
                if (isValid) {
                    (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
                    (_b = this.ownAirplaneIconModule) === null || _b === void 0 ? void 0 : _b.show.set(true);
                }
                else {
                    (_c = this.ownAirplaneIconModule) === null || _c === void 0 ? void 0 : _c.show.set(false);
                    (_d = this.targetControl) === null || _d === void 0 ? void 0 : _d.claim(this.targetControlConsumer);
                }
            }, true);
        }
        /**
         * Changes the player airplane icon to the normal variety.
         */
        setNormalAirplaneIcon() {
            var _a, _b, _c, _d;
            (_a = this.noHeadingIconSrcPipe) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.noHeadingIconAnchorPipe) === null || _b === void 0 ? void 0 : _b.pause();
            (_c = this.normalIconSrcPipe) === null || _c === void 0 ? void 0 : _c.resume(true);
            (_d = this.normalIconAnchorPipe) === null || _d === void 0 ? void 0 : _d.resume(true);
        }
        /**
         * Changes the player airplane icon to the no-heading variety.
         */
        setNoHeadingAirplaneIcon() {
            var _a, _b, _c, _d;
            (_a = this.normalIconSrcPipe) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.normalIconAnchorPipe) === null || _b === void 0 ? void 0 : _b.pause();
            (_c = this.noHeadingIconSrcPipe) === null || _c === void 0 ? void 0 : _c.resume(true);
            (_d = this.noHeadingIconAnchorPipe) === null || _d === void 0 ? void 0 : _d.resume(true);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            super.destroy();
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
            (_b = this.orientationControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.orientationControlConsumer);
            (_c = this.headingSignalSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.gpsSignalSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.normalIconSrcPipe) === null || _e === void 0 ? void 0 : _e.destroy();
            (_f = this.normalIconAnchorPipe) === null || _f === void 0 ? void 0 : _f.destroy();
            (_g = this.noHeadingIconSrcPipe) === null || _g === void 0 ? void 0 : _g.destroy();
            (_h = this.noHeadingIconAnchorPipe) === null || _h === void 0 ? void 0 : _h.destroy();
        }
    }

    /**
     * Controls the pointer of a map.
     */
    class MapFlightPlanFocusRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param nominalFocusMargins A subscribable which provides the nominal focus margins, as
         * `[left, top, right, bottom]` in pixels. The nominal margins define the offset of the boundaries of the focus
         * region relative to the map's projected window, *excluding* the dead zone. Positive values represent offsets
         * toward the center of the window. When the flight plan is focused, the focused elements of the plan are guaranteed
         * to be contained within the focus region.
         * @param defaultFocusRangeIndex The default map range index to apply when the flight plan focus consists of only a
         * single point in space.
         * @param focusDebounceDelay The debounce delay, in milliseconds, to apply to focus target calculations when the
         * flight plan focus changes. Defaults to 500 milliseconds.
         */
        constructor(context, nominalFocusMargins, defaultFocusRangeIndex, focusDebounceDelay = MapFlightPlanFocusRTRController.DEFAULT_FOCUS_DEBOUNCE_DELAY) {
            super(context);
            this.nominalFocusMargins = nominalFocusMargins;
            this.defaultFocusRangeIndex = defaultFocusRangeIndex;
            this.focusDebounceDelay = focusDebounceDelay;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.ownAirplanePropsModule = this.context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
            this.focusModule = this.context.model.getModule(GarminMapKeys.FlightPlanFocus);
            this.orientationModule = this.context.model.getModule(GarminMapKeys.Orientation);
            this.mapTargetParam = {
                target: new msfssdk.GeoPoint(0, 0)
            };
            this.hasTargetControl = msfssdk.Subject.create(this.context.targetControlModerator === undefined);
            this.hasRangeSettingControl = msfssdk.Subject.create(this.context.useRangeSettingModerator === undefined);
            this.canActivateFocus = msfssdk.MappedSubject.create(([hasTargetControl, hasRangeSettingControl]) => {
                return hasTargetControl && hasRangeSettingControl;
            }, this.hasTargetControl, this.hasRangeSettingControl);
            this.targetControl = this.context[msfssdk.MapSystemKeys.TargetControl];
            this.targetControlConsumer = {
                priority: MapResourcePriority.FLIGHT_PLAN_FOCUS,
                onAcquired: () => {
                    this.hasTargetControl.set(true);
                },
                onCeded: () => {
                    this.hasTargetControl.set(false);
                }
            };
            this.orientationControl = this.context[GarminMapKeys.OrientationControl];
            this.orientationControlConsumer = {
                priority: MapResourcePriority.FLIGHT_PLAN_FOCUS,
                onAcquired: () => {
                    var _a;
                    (_a = this.orientationModule) === null || _a === void 0 ? void 0 : _a.orientation.set(exports.MapOrientation.NorthUp);
                },
                onCeded: () => { }
            };
            this.useRangeSetting = this.context[GarminMapKeys.UseRangeSetting];
            this.useRangeSettingConsumer = {
                priority: MapResourcePriority.FLIGHT_PLAN_FOCUS,
                onAcquired: (useRangeSetting) => {
                    useRangeSetting.set(false);
                    this.hasRangeSettingControl.set(true);
                },
                onCeded: () => {
                    this.hasRangeSettingControl.set(false);
                }
            };
            this.focusMargins = msfssdk.VecNMath.create(4, 20, 20, 20, 20);
            this.isPlanFocusValid = msfssdk.MappedSubject.create(([planHasFocus, planFocus]) => {
                return planHasFocus && planFocus !== null;
            }, this.focusModule.planHasFocus, this.focusModule.focus);
            this.isFocusActive = msfssdk.MappedSubject.create(([isPlanFocusValid, canActivateFocus]) => {
                return isPlanFocusValid && canActivateFocus;
            }, this.isPlanFocusValid, this.canActivateFocus);
            this.focusCalculator = new MapFlightPlanFocusCalculator(this.context.projection);
            this.focusRangeTarget = { range: 0, target: new msfssdk.GeoPoint(0, 0) };
            this.focusDebounceTimer = new msfssdk.DebounceTimer();
            this.skipFlightPlanFocusDebounce = false;
            this.updateRangeTargetFromFocusBound = this.updateRangeTargetFromFocus.bind(this);
            this.focusMarginsSub = this.nominalFocusMargins.sub(this.updateFocusMargins.bind(this), true);
        }
        /** @inheritdoc */
        onDeadZoneChanged() {
            this.updateFocusMargins();
        }
        /**
         * Updates the flight plan focus margins.
         */
        updateFocusMargins() {
            const deadZone = this.context.deadZone.get();
            const nominalMargins = this.nominalFocusMargins.get();
            this.focusMargins[0] = deadZone[0] + nominalMargins[0];
            this.focusMargins[1] = deadZone[1] + nominalMargins[1];
            this.focusMargins[2] = deadZone[2] + nominalMargins[2];
            this.focusMargins[3] = deadZone[3] + nominalMargins[3];
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.rangeArraySub = this.rangeModule.nominalRanges.sub(this.onFlightPlanFocusChanged.bind(this), false, true);
            this.focusSub = this.focusModule.focus.sub(this.onFlightPlanFocusChanged.bind(this), false, true);
            this.dataProviderSub = this.focusModule.dataProvider.sub(this.onDataProviderChanged.bind(this), true);
            this.isFocusActivePipe = this.isFocusActive.pipe(this.focusModule.isActive);
            this.isFocusActiveSub = this.focusModule.isActive.sub(this.onIsFocusActiveChanged.bind(this), true);
            this.isPlanFocusValid.sub(this.onIsPlanFocusValidChanged.bind(this), true);
        }
        /**
         * Responds to changes in whether the current flight plan focus is valid.
         * @param isValid Whether the current flight plan focus is valid.
         */
        onIsPlanFocusValidChanged(isValid) {
            var _a, _b, _c, _d;
            if (isValid) {
                (_a = this.useRangeSetting) === null || _a === void 0 ? void 0 : _a.claim(this.useRangeSettingConsumer);
                (_b = this.targetControl) === null || _b === void 0 ? void 0 : _b.claim(this.targetControlConsumer);
            }
            else {
                (_c = this.targetControl) === null || _c === void 0 ? void 0 : _c.forfeit(this.targetControlConsumer);
                (_d = this.useRangeSetting) === null || _d === void 0 ? void 0 : _d.forfeit(this.useRangeSettingConsumer);
            }
        }
        /**
         * Responds to changes in whether flight plan focus is active.
         * @param isActive Whether flight plan focus is active.
         */
        onIsFocusActiveChanged(isActive) {
            var _a, _b;
            if (isActive) {
                if (this.orientationControl === undefined) {
                    // If there is no moderator, assume we have control
                    (_a = this.orientationModule) === null || _a === void 0 ? void 0 : _a.orientation.set(exports.MapOrientation.NorthUp);
                }
                else {
                    this.orientationControl.claim(this.orientationControlConsumer);
                }
            }
            else {
                this.focusDebounceTimer.clear();
                (_b = this.orientationControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.orientationControlConsumer);
            }
            this.setFlightPlanFocusListenersActive(isActive);
        }
        /**
         * Activates or deactivates flight plan focus listeners.
         * @param isActive Whether to activate flight plan focus listeners.
         */
        setFlightPlanFocusListenersActive(isActive) {
            var _a, _b;
            if (isActive) {
                this.skipFlightPlanFocusDebounce = true;
                this.focusSub.resume(true);
                this.skipFlightPlanFocusDebounce = false;
                (_a = this.planCalculatedSub) === null || _a === void 0 ? void 0 : _a.resume();
                this.rangeArraySub.resume();
            }
            else {
                this.focusSub.pause();
                (_b = this.planCalculatedSub) === null || _b === void 0 ? void 0 : _b.pause();
                this.rangeArraySub.pause();
            }
        }
        /**
         * Responds to changes in the flight plan focus.
         */
        onFlightPlanFocusChanged() {
            if (this.skipFlightPlanFocusDebounce) {
                this.updateRangeTargetFromFocus();
            }
            else {
                this.scheduleUpdateRangeTargetFromFocus();
            }
        }
        /**
         * Responds to changes in the flight plan focus data provider.
         * @param dataProvider The new flight plan focus data provider.
         */
        onDataProviderChanged(dataProvider) {
            var _a;
            (_a = this.planCalculatedSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.planCalculatedSub = dataProvider === null || dataProvider === void 0 ? void 0 : dataProvider.planCalculated.on(this.onFlightPlanCalculated.bind(this), !this.focusModule.isActive.get());
        }
        /**
         * A callback which is called when the flight plan is calculated.
         */
        onFlightPlanCalculated() {
            // only update from flight plan focus if the focus is not null and a valid range and target do not already exist.
            if (this.focusModule.planHasFocus.get() && this.focusModule.focus.get() !== null && isNaN(this.focusRangeTarget.range)) {
                this.updateRangeTargetFromFocus();
            }
        }
        /**
         * Schedules an update of the map target and range from the current flight plan focus after a debounce delay.
         */
        scheduleUpdateRangeTargetFromFocus() {
            this.focusDebounceTimer.schedule(this.updateRangeTargetFromFocusBound, this.focusDebounceDelay);
        }
        /**
         * Updates the map target and range from the current flight plan focus.
         */
        updateRangeTargetFromFocus() {
            const targetRange = this.focusCalculator.calculateRangeTarget(this.focusModule.focus.get(), this.focusMargins, this.ownAirplanePropsModule.position.get(), this.focusRangeTarget);
            if (isNaN(targetRange.range)) {
                return;
            }
            this.mapTargetParam.target.set(targetRange.target);
            this.context.projection.setQueued(this.mapTargetParam);
            const ranges = this.rangeModule.nominalRanges.get();
            const rangeIndex = targetRange.range > 0
                ? ranges.findIndex(range => range.asUnit(msfssdk.UnitType.GA_RADIAN) >= targetRange.range)
                : this.defaultFocusRangeIndex;
            const rangeIndexToSet = rangeIndex < 0 ? ranges.length - 1 : rangeIndex;
            this.context.getController(GarminMapKeys.Range).setRangeIndex(rangeIndexToSet);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            super.destroy();
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
            (_b = this.orientationControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.orientationControlConsumer);
            (_c = this.useRangeSetting) === null || _c === void 0 ? void 0 : _c.forfeit(this.useRangeSettingConsumer);
            this.isPlanFocusValid.destroy();
            (_d = this.focusSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.planCalculatedSub) === null || _e === void 0 ? void 0 : _e.destroy();
            (_f = this.rangeArraySub) === null || _f === void 0 ? void 0 : _f.destroy();
            (_g = this.isFocusActivePipe) === null || _g === void 0 ? void 0 : _g.destroy();
            (_h = this.isFocusActiveSub) === null || _h === void 0 ? void 0 : _h.destroy();
            this.focusMarginsSub.destroy();
        }
    }
    MapFlightPlanFocusRTRController.DEFAULT_FOCUS_DEBOUNCE_DELAY = 500; // ms

    exports.TrafficOperatingModeSetting = void 0;
    (function (TrafficOperatingModeSetting) {
        TrafficOperatingModeSetting["Standby"] = "Standby";
        TrafficOperatingModeSetting["Operating"] = "Operating";
        TrafficOperatingModeSetting["Auto"] = "Auto";
        TrafficOperatingModeSetting["TAOnly"] = "TAOnly";
        TrafficOperatingModeSetting["Test"] = "Test";
    })(exports.TrafficOperatingModeSetting || (exports.TrafficOperatingModeSetting = {}));
    exports.TrafficAltitudeModeSetting = void 0;
    (function (TrafficAltitudeModeSetting) {
        TrafficAltitudeModeSetting["Below"] = "Below";
        TrafficAltitudeModeSetting["Normal"] = "Normal";
        TrafficAltitudeModeSetting["Above"] = "Above";
        TrafficAltitudeModeSetting["Unrestricted"] = "Unrestricted";
    })(exports.TrafficAltitudeModeSetting || (exports.TrafficAltitudeModeSetting = {}));
    exports.TrafficMotionVectorModeSetting = void 0;
    (function (TrafficMotionVectorModeSetting) {
        TrafficMotionVectorModeSetting["Off"] = "Off";
        TrafficMotionVectorModeSetting["Absolute"] = "Absolute";
        TrafficMotionVectorModeSetting["Relative"] = "Relative";
    })(exports.TrafficMotionVectorModeSetting || (exports.TrafficMotionVectorModeSetting = {}));
    /**
     * Utility class for retrieving traffic user setting managers.
     */
    class TrafficUserSettings extends msfssdk.DefaultUserSettingManager {
        /**
         * Gets an instance of the traffic user settings manager.
         * @param bus The event bus.
         * @returns An instance of the traffic user settings manager.
         */
        static getManager(bus) {
            var _a;
            return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new msfssdk.DefaultUserSettingManager(bus, [
                {
                    name: 'trafficOperatingMode',
                    defaultValue: exports.TrafficOperatingModeSetting.Standby
                },
                {
                    name: 'trafficAdsbEnabled',
                    defaultValue: true
                },
                {
                    name: 'trafficAltitudeMode',
                    defaultValue: exports.TrafficAltitudeModeSetting.Unrestricted
                },
                {
                    name: 'trafficMotionVectorMode',
                    defaultValue: exports.TrafficMotionVectorModeSetting.Off
                },
                {
                    name: 'trafficMotionVectorLookahead',
                    defaultValue: 60
                }
            ]));
        }
    }

    /**
     * Traffic alert level modes.
     */
    exports.MapTrafficAlertLevelMode = void 0;
    (function (MapTrafficAlertLevelMode) {
        MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["All"] = 0] = "All";
        MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["Advisories"] = 1] = "Advisories";
        MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["TA_RA"] = 2] = "TA_RA";
        MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["RA"] = 3] = "RA";
    })(exports.MapTrafficAlertLevelMode || (exports.MapTrafficAlertLevelMode = {}));
    /**
     * Traffic motion vector modes.
     */
    exports.MapTrafficMotionVectorMode = void 0;
    (function (MapTrafficMotionVectorMode) {
        MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Off"] = 0] = "Off";
        MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Absolute"] = 1] = "Absolute";
        MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Relative"] = 2] = "Relative";
    })(exports.MapTrafficMotionVectorMode || (exports.MapTrafficMotionVectorMode = {}));
    /**
     * Traffic display altitude restriction modes.
     */
    exports.MapTrafficAltitudeRestrictionMode = void 0;
    (function (MapTrafficAltitudeRestrictionMode) {
        MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Unrestricted"] = 0] = "Unrestricted";
        MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Above"] = 1] = "Above";
        MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Normal"] = 2] = "Normal";
        MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Below"] = 3] = "Below";
    })(exports.MapTrafficAltitudeRestrictionMode || (exports.MapTrafficAltitudeRestrictionMode = {}));
    /**
     * A module describing the display of traffic.
     */
    class MapGarminTrafficModule {
        /**
         * Constructor.
         * @param trafficSystem This module's associated traffic system.
         */
        constructor(trafficSystem) {
            var _a;
            this.trafficSystem = trafficSystem;
            /** Whether to show traffic information. */
            this.show = msfssdk.Subject.create(true);
            /** The TCAS operating mode. */
            this.operatingMode = msfssdk.Subject.create(msfssdk.TcasOperatingMode.Standby);
            /** The ADS-B operating mode. */
            this.adsbOperatingMode = msfssdk.Subject.create(msfssdk.AdsbOperatingMode.Standby);
            /** Whether to show intruder labels. */
            this.showIntruderLabel = msfssdk.Subject.create(true);
            /** The index of the outer ring range. */
            this.outerRangeIndex = msfssdk.Subject.create(0);
            /** The index of the inner ring range. */
            this.innerRangeIndex = msfssdk.Subject.create(0);
            /** The alert level mode. */
            this.alertLevelMode = msfssdk.Subject.create(exports.MapTrafficAlertLevelMode.All);
            /** The altitude restriction mode. */
            this.altitudeRestrictionMode = msfssdk.Subject.create(exports.MapTrafficAltitudeRestrictionMode.Normal);
            /** Whether displayed intruder altitude is relative. */
            this.isAltitudeRelative = msfssdk.Subject.create(true);
            /** The motion vector mode. */
            this.motionVectorMode = msfssdk.Subject.create(exports.MapTrafficMotionVectorMode.Off);
            /** The motion vector mode. */
            this.motionVectorLookahead = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.SECOND.createNumber(60));
            trafficSystem.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
                this.operatingMode.set(mode);
            });
            (_a = trafficSystem.adsb) === null || _a === void 0 ? void 0 : _a.getEventSubscriber().on('adsb_operating_mode').whenChanged().handle(mode => {
                this.adsbOperatingMode.set(mode);
            });
        }
    }

    /**
     * Controls the display of traffic on a map based on user settings.
     */
    class MapGarminTrafficController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param trafficSettingManager A user settings manager containing traffic settings.
         * @param mapSettingManager A user settings manager containing map traffic settings. If not defined, the display of
         * traffic will not be bound to map traffic user settings.
         */
        constructor(context, trafficSettingManager, mapSettingManager) {
            var _a, _b, _c;
            super(context);
            this.garminTrafficModule = this.context.model.getModule(GarminMapKeys.Traffic);
            this.altitudeModeSetting = (_a = trafficSettingManager.tryGetSetting('trafficAltitudeMode')) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(exports.TrafficAltitudeModeSetting.Normal);
            this.motionVectorModeSetting = (_b = trafficSettingManager.tryGetSetting('trafficMotionVectorMode')) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(exports.TrafficMotionVectorModeSetting.Off);
            this.motionVectorLookaheadSetting = (_c = trafficSettingManager.tryGetSetting('trafficMotionVectorLookahead')) !== null && _c !== void 0 ? _c : msfssdk.Subject.create(60);
            if (mapSettingManager !== undefined) {
                const iconShowSetting = mapSettingManager.tryGetSetting('mapTrafficShow');
                const iconRangeIndexSetting = mapSettingManager.tryGetSetting('mapTrafficRangeIndex');
                if (iconShowSetting !== undefined) {
                    this.iconVisController = new MapSymbolVisController(context, iconShowSetting, iconRangeIndexSetting !== null && iconRangeIndexSetting !== void 0 ? iconRangeIndexSetting : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER), exports.MapDeclutterMode.Level1, this.garminTrafficModule.show);
                }
                const labelShowSetting = mapSettingManager.tryGetSetting('mapTrafficLabelShow');
                const labelRangeIndexSetting = mapSettingManager.tryGetSetting('mapTrafficLabelRangeIndex');
                if (labelShowSetting !== undefined) {
                    this.labelVisController = new MapSymbolVisController(context, labelShowSetting, labelRangeIndexSetting !== null && labelRangeIndexSetting !== void 0 ? labelRangeIndexSetting : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER), exports.MapDeclutterMode.Level1, this.garminTrafficModule.showIntruderLabel);
                }
                this.alertLevelModeSetting = mapSettingManager.tryGetSetting('mapTrafficAlertLevelMode');
            }
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a, _b, _c;
            this.altitudeModeSettingPipe = this.altitudeModeSetting.pipe(this.garminTrafficModule.altitudeRestrictionMode, setting => { var _a; return (_a = MapGarminTrafficController.ALT_MODE_MAP[setting]) !== null && _a !== void 0 ? _a : exports.MapTrafficAltitudeRestrictionMode.Unrestricted; });
            this.motionVectorModeSettingPipe = this.motionVectorModeSetting.pipe(this.garminTrafficModule.motionVectorMode, setting => { var _a; return (_a = MapGarminTrafficController.MOTION_VECTOR_MODE_MAP[setting]) !== null && _a !== void 0 ? _a : exports.MapTrafficMotionVectorMode.Off; });
            this.motionVectorLookaheadSettingSub = this.motionVectorLookaheadSetting.sub(setting => {
                this.garminTrafficModule.motionVectorLookahead.set(setting, msfssdk.UnitType.SECOND);
            });
            (_a = this.iconVisController) === null || _a === void 0 ? void 0 : _a.onAfterMapRender();
            (_b = this.labelVisController) === null || _b === void 0 ? void 0 : _b.onAfterMapRender();
            this.alertLevelModePipe = (_c = this.alertLevelModeSetting) === null || _c === void 0 ? void 0 : _c.pipe(this.garminTrafficModule.alertLevelMode, setting => { var _a; return (_a = MapGarminTrafficController.ALERT_LEVEL_MODE_MAP[setting]) !== null && _a !== void 0 ? _a : exports.MapTrafficAlertLevelMode.All; });
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e, _f;
            super.destroy();
            (_a = this.altitudeModeSettingPipe) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.motionVectorModeSettingPipe) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.motionVectorLookaheadSettingSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.iconVisController) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.labelVisController) === null || _e === void 0 ? void 0 : _e.destroy();
            (_f = this.alertLevelModePipe) === null || _f === void 0 ? void 0 : _f.destroy();
        }
    }
    MapGarminTrafficController.ALT_MODE_MAP = {
        [exports.TrafficAltitudeModeSetting.Above]: exports.MapTrafficAltitudeRestrictionMode.Above,
        [exports.TrafficAltitudeModeSetting.Below]: exports.MapTrafficAltitudeRestrictionMode.Below,
        [exports.TrafficAltitudeModeSetting.Normal]: exports.MapTrafficAltitudeRestrictionMode.Normal,
        [exports.TrafficAltitudeModeSetting.Unrestricted]: exports.MapTrafficAltitudeRestrictionMode.Unrestricted
    };
    MapGarminTrafficController.MOTION_VECTOR_MODE_MAP = {
        [exports.TrafficMotionVectorModeSetting.Off]: exports.MapTrafficMotionVectorMode.Off,
        [exports.TrafficMotionVectorModeSetting.Absolute]: exports.MapTrafficMotionVectorMode.Absolute,
        [exports.TrafficMotionVectorModeSetting.Relative]: exports.MapTrafficMotionVectorMode.Relative
    };
    MapGarminTrafficController.ALERT_LEVEL_MODE_MAP = {
        [exports.MapTrafficAlertLevelSettingMode.All]: exports.MapTrafficAlertLevelMode.All,
        [exports.MapTrafficAlertLevelSettingMode.Advisories]: exports.MapTrafficAlertLevelMode.Advisories,
        [exports.MapTrafficAlertLevelSettingMode.TA_RA]: exports.MapTrafficAlertLevelMode.TA_RA,
        [exports.MapTrafficAlertLevelSettingMode.RA]: exports.MapTrafficAlertLevelMode.RA
    };

    /**
     * Controls the display of NEXRAD based on user settings.
     */
    class MapNexradController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param minRangeIndex The minimum range range index, inclusive, at which NEXRAD is visible.
         * @param settingManager A setting manager containing the user settings controlling the display of terrain. If not
         * defined, the display of NEXRAD will not be bound to user settings.
         * @param maxDeclutterMode The highest global declutter mode, inclusive, at which NEXRAD is visible. Defaults to
         * `MapDeclutterMode.Level2`. Ignored if `settingManager` is not defined.
         */
        constructor(context, minRangeIndex, settingManager, maxDeclutterMode = exports.MapDeclutterMode.Level2) {
            var _a, _b, _c;
            super(context);
            this.minRangeIndex = minRangeIndex;
            this.maxDeclutterMode = maxDeclutterMode;
            this.nexradModule = this.context.model.getModule(GarminMapKeys.Nexrad);
            this.rangeIndex = this.context.model.getModule(GarminMapKeys.Range).nominalRangeIndex;
            this.declutterMode = (_b = (_a = this.context.model.getModule(GarminMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(exports.MapDeclutterMode.All);
            this.showSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapNexradShow');
            this.rangeIndexSetting = (_c = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapNexradRangeIndex')) !== null && _c !== void 0 ? _c : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
        }
        /** @inheritdoc */
        onAfterMapRender() {
            if (this.showSetting) {
                this.show = msfssdk.MappedSubject.create(([showSetting, rangeIndexSetting, declutterMode, rangeIndex]) => {
                    return showSetting && declutterMode <= this.maxDeclutterMode && rangeIndex >= this.minRangeIndex && rangeIndex <= rangeIndexSetting;
                }, this.showSetting, this.rangeIndexSetting, this.declutterMode, this.rangeIndex);
                this.show.pipe(this.nexradModule.showNexrad);
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.show) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Controls the orientation of a map based on user settings.
     */
    class MapOrientationController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param settingManager The setting manager used by this controller.
         */
        constructor(context, settingManager) {
            super(context);
            this.settingManager = settingManager;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.orientationModule = this.context.model.getModule(GarminMapKeys.Orientation);
            this.pointerModule = this.context.model.getModule(GarminMapKeys.Pointer);
            this.orientationControl = this.context[GarminMapKeys.OrientationControl];
            this.orientationControlConsumer = {
                priority: MapResourcePriority.ORIENTATION_ROTATION,
                onAcquired: () => {
                    var _a;
                    // If pointer is active, preserve the initial orientation mode when we regain control, but pass through any
                    // further changes in the orientation setting to the model. This ensures that if some other controller was
                    // manually setting the orientation mode but forfeited control, we don't force a change in orientation as control
                    // passes back to us
                    (_a = this.orientationSub) === null || _a === void 0 ? void 0 : _a.resume(this.pointerModule === undefined || !this.pointerModule.isActive.get());
                },
                onCeded: () => {
                    var _a;
                    (_a = this.orientationSub) === null || _a === void 0 ? void 0 : _a.pause();
                }
            };
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a, _b, _c;
            const orientationSetting = this.settingManager.tryGetSetting('mapOrientation');
            if (orientationSetting !== undefined) {
                this.orientation = msfssdk.MappedSubject.create(([orientation, isAutoNorthUpActive, autoNorthUpRangeIndex, rangeIndex]) => {
                    var _a;
                    return isAutoNorthUpActive && rangeIndex > autoNorthUpRangeIndex
                        ? exports.MapOrientation.NorthUp
                        : (_a = MapOrientationController.MODE_MAP[orientation]) !== null && _a !== void 0 ? _a : exports.MapOrientation.NorthUp;
                }, orientationSetting, (_a = this.settingManager.tryGetSetting('mapAutoNorthUpActive')) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(false), (_b = this.settingManager.tryGetSetting('mapAutoNorthUpRangeIndex')) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(0), this.rangeModule.nominalRangeIndex);
                const orientationSub = this.orientationSub = this.orientation.sub(orientation => { this.orientationModule.orientation.set(orientation); }, false, true);
                this.isPointerActiveSub = (_c = this.pointerModule) === null || _c === void 0 ? void 0 : _c.isActive.sub(isActive => {
                    if (!isActive && !orientationSub.isPaused) {
                        // If pointer deactivates while we have control, sync orientation with setting in case we inhibited
                        // the sync when control passed to us.
                        orientationSub.pause();
                        orientationSub.resume(true);
                    }
                });
                this.orientationControl.claim(this.orientationControlConsumer);
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            this.orientationControl.forfeit(this.orientationControlConsumer);
            (_a = this.orientation) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.orientationSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.isPointerActiveSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    MapOrientationController.MODE_MAP = {
        [exports.MapOrientationSettingMode.NorthUp]: exports.MapOrientation.NorthUp,
        [exports.MapOrientationSettingMode.HeadingUp]: exports.MapOrientation.HeadingUp,
        [exports.MapOrientationSettingMode.TrackUp]: exports.MapOrientation.TrackUp
    };

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * Controls the rotation, range, and projected target offset of a map based on the orientation module's orientation
     * value.
     */
    class MapOrientationRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param nominalTargetOffsets The nominal projected target offsets this controller applies for each orientation.
         * If an orientation does not have a defined offset, it will default to `[0, 0]`.
         * @param nominalRangeEndpoints The nominal range endpoints this controller applies for each orientation. If an
         * orientation does not have defined range endpoints, it will default to `[0.5, 0.5, 0.5, 0]`.
         */
        constructor(context, nominalTargetOffsets, nominalRangeEndpoints) {
            super(context);
            this.nominalTargetOffsets = nominalTargetOffsets;
            this.nominalRangeEndpoints = nominalRangeEndpoints;
            this.orientationModule = this.context.model.getModule(GarminMapKeys.Orientation);
            this.rotationModule = this.context.model.getModule(msfssdk.MapSystemKeys.Rotation);
            this.ownAirplanePropsModule = this.context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
            this.targetOffsetParam = {
                targetProjectedOffset: msfssdk.Vec2Math.create()
            };
            this.rangeEndpointsParam = {
                rangeEndpoints: msfssdk.VecNMath.create(4)
            };
            this.nominalTargetOffsetSubject = msfssdk.VecNSubject.createFromVector(msfssdk.Vec2Math.create());
            this.nominalRangeEndpointsSubject = msfssdk.VecNSubject.createFromVector(msfssdk.VecNMath.create(4));
            this.needUpdateTargetOffset = false;
            this.needUpdateRangeEndpoints = false;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            this.onGroundSub = (_a = this.ownAirplanePropsModule) === null || _a === void 0 ? void 0 : _a.isOnGround.sub(isOnGround => {
                if (this.orientationModule.orientation.get() === exports.MapOrientation.TrackUp) {
                    this.rotationModule.rotationType.set(isOnGround ? msfssdk.MapRotation.HeadingUp : msfssdk.MapRotation.TrackUp);
                }
            });
            this.orientationSub = this.orientationModule.orientation.sub(orientation => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                let rotationType;
                switch (orientation) {
                    case exports.MapOrientation.HeadingUp:
                        rotationType = msfssdk.MapRotation.HeadingUp;
                        break;
                    case exports.MapOrientation.TrackUp:
                        if ((_b = (_a = this.ownAirplanePropsModule) === null || _a === void 0 ? void 0 : _a.isOnGround.get()) !== null && _b !== void 0 ? _b : false) {
                            rotationType = msfssdk.MapRotation.HeadingUp;
                        }
                        else {
                            rotationType = msfssdk.MapRotation.TrackUp;
                        }
                        break;
                    default:
                        rotationType = msfssdk.MapRotation.NorthUp;
                }
                this.rotationModule.rotationType.set(rotationType);
                (_c = this.targetOffsetPipe) === null || _c === void 0 ? void 0 : _c.destroy();
                (_d = this.rangeEndpointsPipe) === null || _d === void 0 ? void 0 : _d.destroy();
                this.targetOffsetPipe = undefined;
                this.rangeEndpointsPipe = undefined;
                const targetOffset = (_f = (_e = this.nominalTargetOffsets) === null || _e === void 0 ? void 0 : _e[orientation]) !== null && _f !== void 0 ? _f : MapOrientationRTRController.DEFAULT_TARGET_OFFSET;
                const rangeEndpoints = (_h = (_g = this.nominalRangeEndpoints) === null || _g === void 0 ? void 0 : _g[orientation]) !== null && _h !== void 0 ? _h : MapOrientationRTRController.DEFAULT_RANGE_ENDPOINTS;
                if (msfssdk.SubscribableUtils.isSubscribable(targetOffset)) {
                    this.targetOffsetPipe = targetOffset.pipe(this.nominalTargetOffsetSubject);
                }
                else {
                    this.nominalTargetOffsetSubject.set(targetOffset);
                }
                if (msfssdk.SubscribableUtils.isSubscribable(rangeEndpoints)) {
                    this.rangeEndpointsPipe = rangeEndpoints.pipe(this.nominalRangeEndpointsSubject);
                }
                else {
                    this.nominalRangeEndpointsSubject.set(rangeEndpoints);
                }
            }, true);
            this.nominalTargetOffsetSubject.sub(() => { this.needUpdateTargetOffset = true; }, true);
            this.nominalRangeEndpointsSubject.sub(() => { this.needUpdateRangeEndpoints = true; }, true);
        }
        /** @inheritdoc */
        onDeadZoneChanged() {
            this.needUpdateTargetOffset = true;
            this.needUpdateRangeEndpoints = true;
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            const projectedSizeChanged = msfssdk.BitFlags.isAny(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize);
            this.needUpdateTargetOffset || (this.needUpdateTargetOffset = projectedSizeChanged);
            this.needUpdateRangeEndpoints || (this.needUpdateRangeEndpoints = projectedSizeChanged);
        }
        /** @inheritdoc */
        onBeforeUpdated() {
            if (this.needUpdateTargetOffset) {
                this.updateTargetOffset();
                this.context.projection.setQueued(this.targetOffsetParam);
                this.needUpdateTargetOffset = false;
            }
            if (this.needUpdateRangeEndpoints) {
                this.updateRangeEndpoints();
                this.context.projection.setQueued(this.rangeEndpointsParam);
                this.needUpdateRangeEndpoints = false;
            }
        }
        /**
         * Updates this controller's projected target offset.
         */
        updateTargetOffset() {
            const projectedSize = this.context.projection.getProjectedSize();
            const nominalTargetOffset = this.nominalTargetOffsetSubject.get();
            const targetOffset = msfssdk.Vec2Math.copy(nominalTargetOffset, this.targetOffsetParam.targetProjectedOffset);
            targetOffset[0] += 0.5;
            targetOffset[1] += 0.5;
            msfssdk.MapSystemUtils.nominalToTrueRelativeXY(targetOffset, projectedSize, this.context.deadZone.get(), targetOffset);
            targetOffset[0] -= 0.5;
            targetOffset[1] -= 0.5;
            targetOffset[0] *= projectedSize[0];
            targetOffset[1] *= projectedSize[1];
        }
        /**
         * Updates this controller's range endpoints.
         */
        updateRangeEndpoints() {
            const projectedSize = this.context.projection.getProjectedSize();
            const deadZone = this.context.deadZone.get();
            const nominalEndpoints = this.nominalRangeEndpointsSubject.get();
            const rangeEndpoints = this.rangeEndpointsParam.rangeEndpoints;
            rangeEndpoints[0] = msfssdk.MapSystemUtils.nominalToTrueRelativeX(nominalEndpoints[0], projectedSize[0], deadZone);
            rangeEndpoints[1] = msfssdk.MapSystemUtils.nominalToTrueRelativeY(nominalEndpoints[1], projectedSize[1], deadZone);
            rangeEndpoints[2] = msfssdk.MapSystemUtils.nominalToTrueRelativeX(nominalEndpoints[2], projectedSize[0], deadZone);
            rangeEndpoints[3] = msfssdk.MapSystemUtils.nominalToTrueRelativeY(nominalEndpoints[3], projectedSize[1], deadZone);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.orientationSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.onGroundSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.targetOffsetPipe) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.rangeEndpointsPipe) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }
    MapOrientationRTRController.DEFAULT_TARGET_OFFSET = msfssdk.Vec2Math.create();
    MapOrientationRTRController.DEFAULT_RANGE_ENDPOINTS = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0);

    /**
     * Controls the pointer of a map.
     */
    class MapPointerController extends msfssdk.MapSystemController {
        constructor() {
            super(...arguments);
            this.pointerModule = this.context.model.getModule(GarminMapKeys.Pointer);
        }
        /**
         * Activates or deactivates the map pointer.
         * @param isActive Whether to activate the map pointer.
         */
        setPointerActive(isActive) {
            if (isActive === this.pointerModule.isActive.get()) {
                return;
            }
            if (isActive) {
                this.pointerModule.target.set(this.context.projection.getTarget());
                this.pointerModule.position.set(this.context.projection.getTargetProjected());
            }
            this.pointerModule.isActive.set(isActive);
        }
        /**
         * Toggles activation of the map pointer.
         * @returns Whether the map pointer is active after the toggle operation.
         */
        togglePointerActive() {
            this.setPointerActive(!this.pointerModule.isActive.get());
            return this.pointerModule.isActive.get();
        }
        /**
         * Moves the map pointer.
         * @param dx The horizontal displacement, in pixels.
         * @param dy The vertical dispacement, in pixels.
         */
        movePointer(dx, dy) {
            const currentPos = this.pointerModule.position.get();
            this.pointerModule.position.set(currentPos[0] + dx, currentPos[1] + dy);
        }
        /**
         * Sets the map target to the current position of the pointer. The pointer will also be moved to the new projected
         * target position.
         */
        targetPointer() {
            const target = this.context.projection.invert(this.pointerModule.position.get(), MapPointerController.geoPointCache[0]);
            this.pointerModule.target.set(target);
            this.pointerModule.position.set(this.context.projection.getTargetProjected());
        }
    }
    MapPointerController.geoPointCache = [new msfssdk.GeoPoint(0, 0)];

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * Controls the pointer of a map.
     */
    class MapPointerRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param pointerBoundsOffset A subscribable which provides the offset of the boundary surrounding the area in which
         * the pointer can freely move, from the edge of the projected map, excluding the dead zone. Expressed as
         * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map. A positive
         * offset is directed toward the center of the map.
         */
        constructor(context, pointerBoundsOffset) {
            super(context);
            this.pointerBoundsOffset = pointerBoundsOffset;
            this.pointerModule = this.context.model.getModule(GarminMapKeys.Pointer);
            this.orientationModule = this.context.model.getModule(GarminMapKeys.Orientation);
            this.mapProjectionParams = {
                target: new msfssdk.GeoPoint(0, 0)
            };
            this.targetControl = this.context[msfssdk.MapSystemKeys.TargetControl];
            this.hasTargetControl = this.context.targetControlModerator === undefined;
            this.targetControlConsumer = {
                priority: MapResourcePriority.POINTER,
                onAcquired: () => {
                    this.hasTargetControl = true;
                },
                onCeded: () => {
                    this.hasTargetControl = false;
                }
            };
            this.rotationControl = this.context[msfssdk.MapSystemKeys.RotationControl];
            this.rotationControlConsumer = {
                priority: MapResourcePriority.POINTER,
                onAcquired: () => { },
                onCeded: () => { }
            };
            this.rangeControl = this.context[msfssdk.MapSystemKeys.RangeControl];
            this.rangeControlConsumer = {
                priority: MapResourcePriority.POINTER,
                onAcquired: () => { },
                onCeded: () => { }
            };
            this.useRangeSetting = this.context[GarminMapKeys.UseRangeSetting];
            this.useRangeSettingConsumer = {
                priority: MapResourcePriority.POINTER,
                onAcquired: () => { },
                onCeded: () => { }
            };
            this.pointerBounds = msfssdk.VecNSubject.createFromVector(msfssdk.VecNMath.create(4));
            this.needUpdatePointerScroll = false;
            this.pointerVec2Cache = [new Float64Array(2)];
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            this.pointerBoundsSub = this.pointerBounds.sub(this.onPointerBoundsChanged.bind(this), false, true);
            this.pointerPositionSub = this.pointerModule.position.sub(this.onPointerPositionChanged.bind(this), false, true);
            this.pointerTargetSub = this.pointerModule.target.sub(this.onPointerTargetChanged.bind(this), false, true);
            this.pointerBoundsOffsetSub = this.pointerBoundsOffset.sub(this.updatePointerBounds.bind(this), true);
            this.pointerActiveSub = this.pointerModule.isActive.sub(this.onPointerActiveChanged.bind(this), true);
            this.orientationSub = (_a = this.orientationModule) === null || _a === void 0 ? void 0 : _a.orientation.sub(() => { this.pointerModule.isActive.set(false); }, false, true);
        }
        /**
         * Updates this controller's pointer bounds.
         */
        updatePointerBounds() {
            const deadZone = this.context.deadZone.get();
            const offset = this.pointerBoundsOffset.get();
            const size = this.context.projection.getProjectedSize();
            const minX = deadZone[0];
            const minY = deadZone[1];
            const maxX = size[0] - deadZone[2];
            const maxY = size[1] - deadZone[3];
            const width = maxX - minX;
            const height = maxY - minY;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            this.pointerBounds.set(Math.min(centerX, minX + width * offset[0]), Math.min(centerY, minY + height * offset[1]), Math.max(centerX, maxX - width * offset[2]), Math.max(centerY, maxY - height * offset[3]));
        }
        /**
         * Responds to map pointer activation changes.
         * @param isActive Whether the map pointer is active.
         */
        onPointerActiveChanged(isActive) {
            this.updatePointerListeners();
            if (isActive) {
                this.onPointerActivated();
            }
            else {
                this.onPointerDeactivated();
            }
        }
        /**
         * Responds to map pointer activation.
         */
        onPointerActivated() {
            var _a, _b, _c, _d, _e;
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.claim(this.targetControlConsumer);
            (_b = this.rotationControl) === null || _b === void 0 ? void 0 : _b.claim(this.rotationControlConsumer);
            (_c = this.rangeControl) === null || _c === void 0 ? void 0 : _c.claim(this.rangeControlConsumer);
            (_d = this.useRangeSetting) === null || _d === void 0 ? void 0 : _d.claim(this.useRangeSettingConsumer);
            (_e = this.orientationSub) === null || _e === void 0 ? void 0 : _e.resume();
        }
        /**
         * Responds to map pointer deactivation.
         */
        onPointerDeactivated() {
            var _a, _b, _c, _d, _e;
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
            (_b = this.rotationControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.rotationControlConsumer);
            (_c = this.rangeControl) === null || _c === void 0 ? void 0 : _c.forfeit(this.rangeControlConsumer);
            (_d = this.useRangeSetting) === null || _d === void 0 ? void 0 : _d.forfeit(this.useRangeSettingConsumer);
            (_e = this.orientationSub) === null || _e === void 0 ? void 0 : _e.pause();
        }
        /**
         * Responds to map pointer position changes.
         */
        onPointerPositionChanged() {
            this.schedulePointerScrollUpdate();
        }
        /**
         * Responds to map pointer desired target changes.
         * @param target The desired target.
         */
        onPointerTargetChanged(target) {
            if (this.hasTargetControl) {
                this.mapProjectionParams.target.set(target);
                this.context.projection.setQueued(this.mapProjectionParams);
            }
        }
        /**
         * Responds to map pointer bounds changes.
         */
        onPointerBoundsChanged() {
            const position = this.pointerModule.position.get();
            const bounds = this.pointerBounds.get();
            const clampedPositionX = msfssdk.MathUtils.clamp(position[0], bounds[0], bounds[2]);
            const clampedPositionY = msfssdk.MathUtils.clamp(position[1], bounds[1], bounds[3]);
            this.pointerModule.position.set(clampedPositionX, clampedPositionY);
        }
        /**
         * Updates the pointer position listener.
         */
        updatePointerListeners() {
            var _a, _b, _c, _d, _e, _f;
            if (this.pointerModule.isActive.get()) {
                (_a = this.pointerBoundsSub) === null || _a === void 0 ? void 0 : _a.resume();
                (_b = this.pointerPositionSub) === null || _b === void 0 ? void 0 : _b.resume();
                (_c = this.pointerTargetSub) === null || _c === void 0 ? void 0 : _c.resume(true);
            }
            else {
                (_d = this.pointerBoundsSub) === null || _d === void 0 ? void 0 : _d.pause();
                (_e = this.pointerPositionSub) === null || _e === void 0 ? void 0 : _e.pause();
                (_f = this.pointerTargetSub) === null || _f === void 0 ? void 0 : _f.pause();
            }
        }
        /**
         * Schedules an update to scrolling due to the pointer.
         */
        schedulePointerScrollUpdate() {
            this.needUpdatePointerScroll = true;
        }
        /**
         * Updates scrolling due to the pointer.
         */
        updatePointerScroll() {
            if (!this.needUpdatePointerScroll) {
                return;
            }
            const position = this.pointerModule.position.get();
            const bounds = this.pointerBounds.get();
            const clampedPositionX = msfssdk.MathUtils.clamp(position[0], bounds[0], bounds[2]);
            const clampedPositionY = msfssdk.MathUtils.clamp(position[1], bounds[1], bounds[3]);
            const scrollDeltaX = position[0] - clampedPositionX;
            const scrollDeltaY = position[1] - clampedPositionY;
            if (scrollDeltaX === 0 && scrollDeltaY === 0) {
                return;
            }
            this.pointerModule.position.set(clampedPositionX, clampedPositionY);
            if (this.hasTargetControl) {
                const newTargetProjected = msfssdk.Vec2Math.add(this.context.projection.getTargetProjected(), msfssdk.Vec2Math.set(scrollDeltaX, scrollDeltaY, this.pointerVec2Cache[0]), this.pointerVec2Cache[0]);
                this.context.projection.invert(newTargetProjected, this.mapProjectionParams.target);
                this.context.projection.setQueued(this.mapProjectionParams);
            }
            this.needUpdatePointerScroll = false;
        }
        /** @inheritdoc */
        onDeadZoneChanged() {
            this.updatePointerBounds();
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize)) {
                this.updatePointerBounds();
            }
        }
        /** @inheritdoc */
        onBeforeUpdated() {
            this.updatePointerScroll();
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            super.destroy();
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
            (_b = this.rotationControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.rotationControlConsumer);
            (_c = this.rangeControl) === null || _c === void 0 ? void 0 : _c.forfeit(this.rangeControlConsumer);
            (_d = this.useRangeSetting) === null || _d === void 0 ? void 0 : _d.forfeit(this.useRangeSettingConsumer);
            (_e = this.pointerBoundsOffsetSub) === null || _e === void 0 ? void 0 : _e.destroy();
            (_f = this.pointerActiveSub) === null || _f === void 0 ? void 0 : _f.destroy();
            (_g = this.pointerBoundsSub) === null || _g === void 0 ? void 0 : _g.destroy();
            (_h = this.pointerPositionSub) === null || _h === void 0 ? void 0 : _h.destroy();
            (_j = this.pointerTargetSub) === null || _j === void 0 ? void 0 : _j.destroy();
            (_k = this.orientationSub) === null || _k === void 0 ? void 0 : _k.destroy();
        }
    }

    /**
     * Controls the display of the range compass, and optionally the range ring, based on map orientation.
     */
    class MapRangeCompassController extends msfssdk.MapSystemController {
        constructor() {
            var _a;
            super(...arguments);
            this.orientation = this.context.model.getModule(GarminMapKeys.Orientation).orientation;
            this.rangeCompassShow = this.context.model.getModule(GarminMapKeys.RangeCompass).show;
            this.rangeRingShow = (_a = this.context.model.getModule(GarminMapKeys.RangeRing)) === null || _a === void 0 ? void 0 : _a.show;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.orientationSub = this.orientation.sub(mode => {
                var _a;
                const show = mode === exports.MapOrientation.HeadingUp || mode === exports.MapOrientation.TrackUp;
                this.rangeCompassShow.set(show);
                (_a = this.rangeRingShow) === null || _a === void 0 ? void 0 : _a.set(!show);
            }, true);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.orientationSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Controls map range.
     */
    class MapRangeController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param nauticalRangeArray The map range array this controller sets for nautical distance mode. If not defined,
         * this controller will not change the range array when entering nautical distance mode.
         * @param metricRangeArray The map range array this controller sets for metric distance mode. If not defined, this
         * controller will not change the range array when entering metric distance mode.
         * @param settingManager A setting manager containing the map range index setting. If not defined, map range will
         * be set directly through the map model.
         * @param useSetting A subscribable which provides whether to control map range via the user setting. If not defined,
         * map range will always be controlled via the user setting. Ignored if `settingManager` is undefined.
         */
        constructor(context, nauticalRangeArray, metricRangeArray, settingManager, useSetting) {
            var _a, _b;
            super(context);
            this.nauticalRangeArray = nauticalRangeArray;
            this.metricRangeArray = metricRangeArray;
            this.useSetting = useSetting;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.distanceUnitsMode = (_b = (_a = this.context.model.getModule(GarminMapKeys.Units)) === null || _a === void 0 ? void 0 : _a.distanceMode) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(exports.UnitsDistanceSettingMode.Nautical);
            this.rangeSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.getSetting('mapRangeIndex');
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            this.distanceModeSub = this.distanceUnitsMode.sub(mode => {
                if (mode === exports.UnitsDistanceSettingMode.Nautical) {
                    if (this.nauticalRangeArray !== undefined) {
                        this.rangeModule.nominalRanges.set(this.nauticalRangeArray);
                    }
                }
                else {
                    if (this.metricRangeArray) {
                        this.rangeModule.nominalRanges.set(this.metricRangeArray);
                    }
                }
            }, true);
            this.settingSub = (_a = this.rangeSetting) === null || _a === void 0 ? void 0 : _a.sub(setting => {
                this.rangeModule.setNominalRangeIndex(setting);
            }, false, true);
            if (this.settingSub) {
                if (this.useSetting) {
                    this.useSettingSub = this.useSetting.sub(useSetting => {
                        if (useSetting) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.settingSub.resume(true);
                        }
                        else {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.settingSub.pause();
                        }
                    }, true);
                }
                else {
                    this.settingSub.resume(true);
                }
            }
        }
        /**
         * Sets the map range index. If the index is out of bounds, it will be clamped before being set.
         * @param index The index to set.
         * @returns The index that was set.
         */
        setRangeIndex(index) {
            var _a, _b;
            index = msfssdk.MathUtils.clamp(index, 0, this.rangeModule.nominalRanges.get().length - 1);
            if (this.rangeSetting !== undefined && ((_b = (_a = this.useSetting) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : true)) {
                this.rangeSetting.value = index;
            }
            else {
                this.rangeModule.setNominalRangeIndex(index);
            }
            return index;
        }
        /**
         * Changes the map range index by a given amount. If the change results in an index that is out of bounds, it will
         * be clamped before being set.
         * @param delta The change to apply to the index.
         * @returns The final index that was set.
         */
        changeRangeIndex(delta) {
            return this.setRangeIndex(this.rangeModule.nominalRangeIndex.get() + delta);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.distanceModeSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.settingSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.useSettingSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }

    /**
     * Controls map projection range based on the range module's nominal range value.
     */
    class MapRangeRTRController extends msfssdk.MapSystemController {
        constructor() {
            super(...arguments);
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.rangeParam = {
                range: 0
            };
            this.needUpdateRange = false;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.rangeSub = this.rangeModule.nominalRange.sub(() => {
                this.needUpdateRange = true;
            }, true);
        }
        /** @inheritdoc */
        onBeforeUpdated() {
            if (this.needUpdateRange) {
                const range = this.rangeModule.nominalRange.get();
                this.rangeParam.range = range.asUnit(msfssdk.UnitType.GA_RADIAN);
                this.context.projection.setQueued(this.rangeParam);
                this.needUpdateRange = false;
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.rangeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Provides utility functions for working with Garmin maps.
     */
    class MapUtils {
        /**
         * Gets the standard map range array for next-generation (NXi, G3000, etc) avionics units.
         * @param units The distance units mode for which to get the array.
         * @returns The standard map range array for next-generation (NXi, G3000, etc) avionics units.
         */
        static nextGenMapRanges(units) {
            return MapUtils.NEXT_GEN_MAP_RANGES[units];
        }
        /**
         * Gets the standard traffic map range array for next-generation (NXi, G3000, etc) avionics units.
         * @returns The standard traffic map range array for next-generation (NXi, G3000, etc) avionics units.
         */
        static nextGenTrafficMapRanges() {
            return MapUtils.NEXT_GEN_TRAFFIC_MAP_RANGES;
        }
        /**
         * Gets the full Bing component earth color array for no terrain colors.
         * @returns The full Bing component earth color array for no terrain colors.
         */
        static noTerrainEarthColors() {
            return MapUtils.NO_TERRAIN_EARTH_COLORS;
        }
        /**
         * Gets the full Bing component earth color array for absolute terrain colors.
         * @returns The full Bing component earth color array for absolute terrain colors.
         */
        static absoluteTerrainEarthColors() {
            return MapUtils.ABSOLUTE_TERRAIN_EARTH_COLORS;
        }
        /**
         * Gets the full Bing component earth color array for relative terrain colors.
         * @returns The full Bing component earth color array for relative terrain colors.
         */
        static relativeTerrainEarthColors() {
            return MapUtils.RELATIVE_TERRAIN_EARTH_COLORS;
        }
    }
    MapUtils.NEXT_GEN_MAP_RANGES = {
        [exports.UnitsDistanceSettingMode.Nautical]: [
            ...[
                250,
                400,
                500,
                750,
                1000,
                1500,
                2500
            ].map(value => msfssdk.UnitType.FOOT.createNumber(value).readonly),
            ...[
                0.5,
                0.75,
                1,
                1.5,
                2.5,
                4,
                5,
                7.5,
                10,
                15,
                25,
                40,
                50,
                75,
                100,
                150,
                250,
                400,
                500,
                750,
                1000
            ].map(value => msfssdk.UnitType.NMILE.createNumber(value).readonly)
        ],
        [exports.UnitsDistanceSettingMode.Metric]: [
            ...[
                75,
                100,
                150,
                250,
                400,
                500,
                750
            ].map(value => msfssdk.UnitType.METER.createNumber(value).readonly),
            ...[
                1,
                1.5,
                2.5,
                4,
                5,
                8,
                10,
                15,
                20,
                40,
                50,
                75,
                100,
                150,
                250,
                350,
                500,
                800,
                1000,
                1500,
                2000
            ].map(value => msfssdk.UnitType.KILOMETER.createNumber(value).readonly)
        ]
    };
    MapUtils.NEXT_GEN_TRAFFIC_MAP_RANGES = [
        ...[
            500,
            500,
            500,
            1000,
            1000,
            1000,
            2000,
            2000
        ].map(value => msfssdk.UnitType.FOOT.createNumber(value).readonly),
        ...[
            1,
            1,
            2,
            2,
            6,
            6,
            12,
            12,
            24,
            24,
            40,
            40,
            40,
            40,
            40,
            40,
            40,
            40,
            40,
            40
        ].map(value => msfssdk.UnitType.NMILE.createNumber(value).readonly)
    ];
    MapUtils.NO_TERRAIN_EARTH_COLORS = msfssdk.BingComponent.createEarthColorsArray('#000049', [
        {
            elev: 0,
            color: '#000000'
        },
        {
            elev: 60000,
            color: '#000000'
        }
    ]);
    MapUtils.ABSOLUTE_TERRAIN_EARTH_COLORS = msfssdk.BingComponent.createEarthColorsArray('#000049', [
        {
            elev: 0,
            color: '#427238'
        },
        {
            elev: 500,
            color: '#456821'
        },
        {
            elev: 2000,
            color: '#d0aa43'
        },
        {
            elev: 3000,
            color: '#c58f45'
        },
        {
            elev: 6000,
            color: '#9d6434'
        },
        {
            elev: 8000,
            color: '#904f25'
        },
        {
            elev: 10500,
            color: '#904522'
        },
        {
            elev: 27000,
            color: '#939393'
        },
        {
            elev: 29000,
            color: '#c8c8c8'
        }
    ]);
    MapUtils.RELATIVE_TERRAIN_EARTH_COLORS = msfssdk.BingComponent.createEarthColorsArray('#000049', [
        {
            elev: 0,
            color: '#ff0000'
        },
        {
            elev: 99,
            color: '#ff0000'
        },
        {
            elev: 100,
            color: '#ffff00'
        },
        {
            elev: 999,
            color: '#ffff00'
        },
        {
            elev: 1000,
            color: '#00ff00'
        },
        {
            elev: 1999,
            color: '#00ff00'
        },
        {
            elev: 2000,
            color: '#000000'
        }
    ]);

    /**
     * Map terrain display mode.
     */
    exports.MapTerrainMode = void 0;
    (function (MapTerrainMode) {
        MapTerrainMode[MapTerrainMode["None"] = 0] = "None";
        MapTerrainMode[MapTerrainMode["Absolute"] = 1] = "Absolute";
        MapTerrainMode[MapTerrainMode["Relative"] = 2] = "Relative";
        MapTerrainMode[MapTerrainMode["Ground"] = 3] = "Ground";
    })(exports.MapTerrainMode || (exports.MapTerrainMode = {}));
    /**
     * A module describing the display of terrain.
     */
    class MapTerrainModule {
        constructor() {
            /** The terrain display mode. */
            this.terrainMode = msfssdk.Subject.create(exports.MapTerrainMode.Absolute);
            /** Whether to show the terrain scale. */
            this.showScale = msfssdk.Subject.create(false);
        }
    }

    /**
     * Controls the display of terrain colors based on the terrain mode value in {@link MapTerrainModule}.
     */
    class MapTerrainColorsController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param colors The terrain colors array to use for each terrain mode. A default colors array will be used for any
         * mode which does not have a defined array.
         */
        constructor(context, colors) {
            super(context);
            this.colors = colors;
            this.terrainModule = this.context.model.getModule(GarminMapKeys.Terrain);
            this.terrainColorsModule = this.context.model.getModule(msfssdk.MapSystemKeys.TerrainColors);
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.modeSub = this.terrainModule.terrainMode.sub(mode => {
                var _a;
                this.terrainColorsModule.reference.set(MapTerrainColorsController.MODE_MAP[mode]);
                this.terrainColorsModule.colors.set((_a = this.colors[mode]) !== null && _a !== void 0 ? _a : MapTerrainColorsController.DEFAULT_COLORS);
            }, true);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.modeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    MapTerrainColorsController.DEFAULT_COLORS = MapUtils.noTerrainEarthColors();
    MapTerrainColorsController.MODE_MAP = {
        [exports.MapTerrainMode.None]: EBingReference.SEA,
        [exports.MapTerrainMode.Absolute]: EBingReference.SEA,
        [exports.MapTerrainMode.Relative]: EBingReference.PLANE,
        [exports.MapTerrainMode.Ground]: EBingReference.SEA
    };

    /**
     * Controls the display of terrain based on user settings.
     */
    class MapTerrainController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param settingManager A setting manager containing the user settings controlling the display of terrain. If not
         * defined, the display of terrain will not be bound to user settings.
         * @param allowRelative Whether to allow relative terrain mode. Defaults to `true`. Ignored if `settingManager` is
         * not defined.
         */
        constructor(context, settingManager, allowRelative = true) {
            var _a, _b, _c;
            super(context);
            this.allowRelative = allowRelative;
            this.terrainModule = this.context.model.getModule(GarminMapKeys.Terrain);
            this.rangeIndex = this.context.model.getModule(GarminMapKeys.Range).nominalRangeIndex;
            this.isOnGround = (_b = (_a = this.context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps)) === null || _a === void 0 ? void 0 : _a.isOnGround) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(false);
            this.modeSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTerrainMode');
            this.rangeIndexSetting = (_c = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTerrainRangeIndex')) !== null && _c !== void 0 ? _c : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            this.showScaleSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTerrainScaleShow');
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            if (this.modeSetting !== undefined) {
                this.terrainMode = msfssdk.MappedSubject.create(([modeSetting, rangeIndexSetting, rangeIndex, isOnGround]) => {
                    let mode = exports.MapTerrainMode.None;
                    if (rangeIndex <= rangeIndexSetting) {
                        switch (modeSetting) {
                            case exports.MapTerrainSettingMode.Absolute:
                                mode = exports.MapTerrainMode.Absolute;
                                break;
                            case exports.MapTerrainSettingMode.Relative:
                                if (this.allowRelative && !isOnGround) {
                                    mode = exports.MapTerrainMode.Relative;
                                }
                                break;
                        }
                    }
                    return mode;
                }, this.modeSetting, this.rangeIndexSetting, this.rangeIndex, this.isOnGround);
                this.terrainMode.pipe(this.terrainModule.terrainMode);
            }
            this.showScalePipe = (_a = this.showScaleSetting) === null || _a === void 0 ? void 0 : _a.pipe(this.terrainModule.showScale);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.terrainMode) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.showScalePipe) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * Controls the display of traffic based on the values in {@link MapGarminTrafficModule}.
     */
    class MapTrafficController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param useOuterRangeAsOffScale Whether to use the map's outer traffic range as the traffic off-scale range.
         */
        constructor(context, useOuterRangeAsOffScale) {
            super(context);
            this.useOuterRangeAsOffScale = useOuterRangeAsOffScale;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.trafficModule = this.context.model.getModule(msfssdk.MapSystemKeys.Traffic);
            this.garminTrafficModule = this.context.model.getModule(GarminMapKeys.Traffic);
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.showPipe = this.garminTrafficModule.show.pipe(this.trafficModule.show);
            this.alertLevelPipe = this.garminTrafficModule.alertLevelMode.pipe(this.trafficModule.alertLevelVisibility, mode => { var _a; return (_a = MapTrafficController.ALERT_LEVEL_VIS_MAP[mode]) !== null && _a !== void 0 ? _a : msfssdk.MapTrafficAlertLevelVisibility.All; });
            this.isAltitudeRelativePipe = this.garminTrafficModule.isAltitudeRelative.pipe(this.trafficModule.isAltitudeRelative);
            this.altitudeModeSub = this.garminTrafficModule.altitudeRestrictionMode.sub(mode => {
                if (mode === exports.MapTrafficAltitudeRestrictionMode.Unrestricted || mode === exports.MapTrafficAltitudeRestrictionMode.Above) {
                    this.trafficModule.altitudeRestrictionAbove.set(MapTrafficController.ALTITUDE_RESTRICTION_UNRES);
                }
                else {
                    this.trafficModule.altitudeRestrictionAbove.set(MapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
                }
                if (mode === exports.MapTrafficAltitudeRestrictionMode.Unrestricted || mode === exports.MapTrafficAltitudeRestrictionMode.Below) {
                    this.trafficModule.altitudeRestrictionBelow.set(MapTrafficController.ALTITUDE_RESTRICTION_UNRES);
                }
                else {
                    this.trafficModule.altitudeRestrictionBelow.set(MapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
                }
            });
            if (this.useOuterRangeAsOffScale && this.rangeModule !== undefined) {
                this.offScaleRange = msfssdk.MappedSubject.create(([rangeArray, outerRangeIndex]) => {
                    var _a;
                    return (_a = rangeArray[outerRangeIndex]) !== null && _a !== void 0 ? _a : MapTrafficController.NAN_RANGE;
                }, this.rangeModule.nominalRanges, this.garminTrafficModule.outerRangeIndex);
                this.offScaleRange.pipe(this.trafficModule.offScaleRange);
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e;
            super.destroy();
            (_a = this.showPipe) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.alertLevelPipe) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.isAltitudeRelativePipe) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.altitudeModeSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.offScaleRange) === null || _e === void 0 ? void 0 : _e.destroy();
        }
    }
    MapTrafficController.NAN_RANGE = msfssdk.UnitType.NMILE.createNumber(NaN);
    MapTrafficController.ALERT_LEVEL_VIS_MAP = {
        [exports.MapTrafficAlertLevelMode.All]: msfssdk.MapTrafficAlertLevelVisibility.All,
        [exports.MapTrafficAlertLevelMode.Advisories]: msfssdk.BitFlags.not(msfssdk.MapTrafficAlertLevelVisibility.All, msfssdk.MapTrafficAlertLevelVisibility.Other),
        [exports.MapTrafficAlertLevelMode.TA_RA]: msfssdk.MapTrafficAlertLevelVisibility.TrafficAdvisory | msfssdk.MapTrafficAlertLevelVisibility.ResolutionAdvisory,
        [exports.MapTrafficAlertLevelMode.RA]: msfssdk.MapTrafficAlertLevelVisibility.ResolutionAdvisory
    };
    MapTrafficController.ALTITUDE_RESTRICTION_UNRES = msfssdk.UnitType.FOOT.createNumber(9900);
    MapTrafficController.ALTITUDE_RESTRICTION_NORMAL = msfssdk.UnitType.FOOT.createNumber(2700);

    /**
     * Airport size.
     */
    exports.AirportSize = void 0;
    (function (AirportSize) {
        AirportSize["Large"] = "Large";
        AirportSize["Medium"] = "Medium";
        AirportSize["Small"] = "Small";
    })(exports.AirportSize || (exports.AirportSize = {}));
    /**
     * A waypoint associated with an airport.
     */
    class AirportWaypoint extends msfssdk.FacilityWaypoint {
        /**
         * Constructor.
         * @param airport The airport associated with this waypoint.
         * @param bus The event bus.
         */
        constructor(airport, bus) {
            super(airport, bus);
            this.longestRunway = AirportWaypoint.getLongestRunway(airport);
            this.size = AirportWaypoint.getAirportSize(airport, this.longestRunway);
        }
        /**
         * Gets the longest runway at an airport.
         * @param airport An airport.
         * @returns the longest runway at an airport, or null if the airport has no runways.
         */
        static getLongestRunway(airport) {
            if (airport.runways.length === 0) {
                return null;
            }
            return airport.runways.reduce((a, b) => a.length > b.length ? a : b);
        }
        /**
         * Gets the size of an airport.
         * @param airport An airport.
         * @param longestRunway The longest runway at the airport.
         * @returns the size of the airport.
         */
        static getAirportSize(airport, longestRunway) {
            if (!longestRunway) {
                return exports.AirportSize.Small;
            }
            const longestRwyLengthFeet = msfssdk.UnitType.METER.convertTo(longestRunway.length, msfssdk.UnitType.FOOT);
            return longestRwyLengthFeet >= 8100 ? exports.AirportSize.Large
                : (longestRwyLengthFeet >= 5000 || airport.towered) ? exports.AirportSize.Medium
                    : exports.AirportSize.Small;
        }
    }

    /**
     * Controls the visibility of map waypoint symbols.
     */
    class MapWaypointsVisController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param settingManager A setting manager containing the user settings controlling waypoint visibility.
         */
        constructor(context, settingManager) {
            var _a, _b, _c, _d, _e, _f, _g;
            super(context);
            this.waypointsModule = this.context.model.getModule(msfssdk.MapSystemKeys.NearestWaypoints);
            this.controllers = [];
            const airportLargeShow = settingManager.tryGetSetting('mapAirportLargeShow');
            const airportLargeRangeIndex = (_a = settingManager.tryGetSetting('mapAirportLargeRangeIndex')) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (airportLargeShow) {
                this.controllers.push(new MapSymbolVisController(context, airportLargeShow, airportLargeRangeIndex, exports.MapDeclutterMode.Level2, this.waypointsModule.airportShow[exports.AirportSize.Large]));
            }
            const airportMediumShow = settingManager.tryGetSetting('mapAirportMediumShow');
            const airportMediumRangeIndex = (_b = settingManager.tryGetSetting('mapAirportMediumRangeIndex')) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (airportMediumShow) {
                this.controllers.push(new MapSymbolVisController(context, airportMediumShow, airportMediumRangeIndex, exports.MapDeclutterMode.Level2, this.waypointsModule.airportShow[exports.AirportSize.Medium]));
            }
            const airportSmallShow = settingManager.tryGetSetting('mapAirportSmallShow');
            const airportSmallRangeIndex = (_c = settingManager.tryGetSetting('mapAirportSmallRangeIndex')) !== null && _c !== void 0 ? _c : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (airportSmallShow) {
                this.controllers.push(new MapSymbolVisController(context, airportSmallShow, airportSmallRangeIndex, exports.MapDeclutterMode.Level2, this.waypointsModule.airportShow[exports.AirportSize.Small]));
            }
            const vorShow = settingManager.tryGetSetting('mapVorShow');
            const vorRangeIndex = (_d = settingManager.tryGetSetting('mapVorRangeIndex')) !== null && _d !== void 0 ? _d : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (vorShow) {
                this.controllers.push(new MapSymbolVisController(context, vorShow, vorRangeIndex, exports.MapDeclutterMode.Level3, this.waypointsModule.vorShow));
            }
            const ndbShow = settingManager.tryGetSetting('mapNdbShow');
            const ndbRangeIndex = (_e = settingManager.tryGetSetting('mapNdbRangeIndex')) !== null && _e !== void 0 ? _e : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (ndbShow) {
                this.controllers.push(new MapSymbolVisController(context, ndbShow, ndbRangeIndex, exports.MapDeclutterMode.Level3, this.waypointsModule.ndbShow));
            }
            const intersectionShow = settingManager.tryGetSetting('mapIntersectionShow');
            const intersectionRangeIndex = (_f = settingManager.tryGetSetting('mapIntersectionRangeIndex')) !== null && _f !== void 0 ? _f : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (intersectionShow) {
                this.controllers.push(new MapSymbolVisController(context, intersectionShow, intersectionRangeIndex, exports.MapDeclutterMode.Level3, this.waypointsModule.intShow));
            }
            const userShow = settingManager.tryGetSetting('mapUserWaypointShow');
            const userRangeIndex = (_g = settingManager.tryGetSetting('mapUserWaypointRangeIndex')) !== null && _g !== void 0 ? _g : msfssdk.Subject.create(Number.MAX_SAFE_INTEGER);
            if (userShow) {
                this.controllers.push(new MapSymbolVisController(context, userShow, userRangeIndex, exports.MapDeclutterMode.Level3, this.waypointsModule.userShow));
            }
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.controllers.forEach(controller => { controller.onAfterMapRender(); });
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.controllers.forEach(controller => { controller.destroy(); });
        }
    }

    /**
     * Controls the display of weather based on the show NEXRAD value in {@link MapNexradModule}.
     */
    class MapWxrController extends msfssdk.MapSystemController {
        constructor() {
            super(...arguments);
            this.nexradModule = this.context.model.getModule(GarminMapKeys.Nexrad);
            this.weatherModule = this.context.model.getModule(msfssdk.MapSystemKeys.Weather);
        }
        /** @inheritdoc */
        onAfterMapRender() {
            this.showSub = this.nexradModule.showNexrad.sub(show => {
                if (show) {
                    this.weatherModule.weatherRadarMode.set(EWeatherRadar.TOPVIEW);
                }
                this.weatherModule.isEnabled.set(show);
            }, true);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Controls the range of a nearest waypoint map to keep a highlighted waypoint in view.
     */
    class NearestMapRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param defaultNoTargetRangeIndex A subscribable which provides the default map range index to apply when
         * not targeting a waypoint, or `null` if no range index should be applied.
         */
        constructor(context, defaultNoTargetRangeIndex) {
            super(context);
            this.defaultNoTargetRangeIndex = defaultNoTargetRangeIndex;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.waypointHighlightModule = this.context.model.getModule(GarminMapKeys.WaypointHighlight);
            this.rangeControl = this.context[msfssdk.MapSystemKeys.RangeControl];
            this.hasRangeControl = this.rangeControl !== undefined;
            this.rangeControlConsumer = {
                priority: MapResourcePriority.WAYPOINT_HIGHLIGHT,
                onAcquired: () => {
                    this.hasRangeControl = true;
                    this.trySetRangeForWaypoint(this.waypointHighlightModule.waypoint.get());
                },
                onCeded: () => { this.hasRangeControl = false; }
            };
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            (_a = this.rangeControl) === null || _a === void 0 ? void 0 : _a.claim(this.rangeControlConsumer);
            this.waypointSub = this.waypointHighlightModule.waypoint.sub(this.trySetRangeForWaypoint.bind(this), true);
        }
        /**
         * Attempts to set the range of the map so that the specified waypoint is in view. If this controller does not have
         * permission to change the map's range, the operation will be aborted.
         * @param waypoint The waypoint for which to set the map range.
         */
        trySetRangeForWaypoint(waypoint) {
            if (!this.hasRangeControl) {
                return;
            }
            if (waypoint === null) {
                if (this.defaultNoTargetRangeIndex !== null) {
                    this.context.getController(GarminMapKeys.Range).setRangeIndex(this.defaultNoTargetRangeIndex.get());
                }
            }
            else {
                const distanceFromTarget = this.context.projection.getTarget().distance(waypoint.location.get());
                const ranges = this.rangeModule.nominalRanges.get();
                let index = ranges.findIndex(range => range.compare(distanceFromTarget, msfssdk.UnitType.GA_RADIAN) >= 0);
                if (index === -1) {
                    index = ranges.length - 1;
                }
                this.context.getController(GarminMapKeys.Range).setRangeIndex(index);
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.rangeControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.rangeControlConsumer);
            (_b = this.waypointSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * Controls traffic map range.
     */
    class TrafficMapRangeController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param nauticalRangeArray The map range array this controller sets for nautical distance mode. If not defined,
         * this controller will not change the range array when entering nautical distance mode.
         * @param metricRangeArray The map range array this controller sets for metric distance mode. If not defined, this
         * controller will not change the range array when entering metric distance mode.
         * @param settingManager A setting manager containing the map range index setting. If not defined, map range will
         * be set directly through the map model.
         * @param useSetting A subscribable which provides whether to control map range via the user setting. If not defined,
         * map range will always be controlled via the user setting. Ignored if `settingManager` is undefined.
         */
        constructor(context, nauticalRangeArray, metricRangeArray, settingManager, useSetting) {
            var _a, _b;
            super(context);
            this.nauticalRangeArray = nauticalRangeArray;
            this.metricRangeArray = metricRangeArray;
            this.useSetting = useSetting;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.trafficModule = this.context.model.getModule(GarminMapKeys.Traffic);
            this.distanceUnitsMode = (_b = (_a = this.context.model.getModule(GarminMapKeys.Units)) === null || _a === void 0 ? void 0 : _a.distanceMode) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(exports.UnitsDistanceSettingMode.Nautical);
            this.rangeSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.getSetting('mapRangeIndex');
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            this.distanceModeSub = this.distanceUnitsMode.sub(mode => {
                if (mode === exports.UnitsDistanceSettingMode.Nautical) {
                    if (this.nauticalRangeArray !== undefined) {
                        this.rangeModule.nominalRanges.set(this.nauticalRangeArray);
                    }
                }
                else {
                    if (this.metricRangeArray) {
                        this.rangeModule.nominalRanges.set(this.metricRangeArray);
                    }
                }
            }, true);
            this.indexSub = this.rangeModule.nominalRangeIndex.sub(index => {
                this.trafficModule.outerRangeIndex.set(index);
                const ranges = this.rangeModule.nominalRanges.get();
                const outerRange = ranges[index];
                let innerRangeIndex = index;
                while (--innerRangeIndex >= 0) {
                    if (ranges[innerRangeIndex].compare(outerRange) < 0) {
                        break;
                    }
                }
                this.trafficModule.innerRangeIndex.set(innerRangeIndex);
            }, true);
            this.settingSub = (_a = this.rangeSetting) === null || _a === void 0 ? void 0 : _a.sub(setting => {
                this.rangeModule.setNominalRangeIndex(setting);
            }, false, true);
            if (this.settingSub) {
                if (this.useSetting) {
                    this.useSettingSub = this.useSetting.sub(useSetting => {
                        if (useSetting) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.settingSub.resume(true);
                        }
                        else {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.settingSub.pause();
                        }
                    }, true);
                }
                else {
                    this.settingSub.resume(true);
                }
            }
        }
        /**
         * Sets the map range index. If the index is out of bounds, it will be clamped before being set.
         * @param index The index to set.
         * @returns The index that was set.
         */
        setRangeIndex(index) {
            var _a, _b;
            index = msfssdk.MathUtils.clamp(index, 0, this.rangeModule.nominalRanges.get().length - 1);
            if (this.rangeSetting !== undefined && ((_b = (_a = this.useSetting) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : true)) {
                this.rangeSetting.value = index;
            }
            else {
                this.rangeModule.setNominalRangeIndex(index);
            }
            return index;
        }
        /**
         * Changes the range index by a given number of steps. Each step changes the range index to the next or previous
         * index that holds a range different from the current range.
         * @param delta The number of steps by which to change the range.
         * @returns The final index that was set.
         */
        changeRangeIndex(delta) {
            const currentIndex = this.rangeModule.nominalRangeIndex.get();
            if (delta === 0) {
                return currentIndex;
            }
            const ranges = this.rangeModule.nominalRanges.get();
            const currentRange = ranges[currentIndex];
            let index = currentIndex;
            let stepsToGo = Math.abs(delta);
            if (delta > 0) {
                while (++index < ranges.length) {
                    if (!ranges[index].equals(currentRange)) {
                        stepsToGo--;
                    }
                    if (stepsToGo === 0) {
                        break;
                    }
                }
            }
            else {
                while (--index >= 0) {
                    if (!ranges[index].equals(currentRange)) {
                        stepsToGo--;
                    }
                    if (stepsToGo === 0) {
                        break;
                    }
                }
            }
            index = msfssdk.MathUtils.clamp(index, 0, ranges.length - 1);
            if (currentRange.compare(ranges[index]) === 0) {
                return currentIndex;
            }
            return this.setRangeIndex(index);
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.distanceModeSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.indexSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.settingSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.useSettingSub) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }

    /**
     * A Garmin-specific implementation of {@link FacilityWaypointCache}.
     */
    class GarminFacilityWaypointCache {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param size The maximum size of this cache.
         */
        constructor(bus, size) {
            this.bus = bus;
            this.size = size;
            this.cache = new Map();
        }
        /**
         * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
         * @param facility The facility for which to get a waypoint.
         * @returns A waypoint.
         */
        get(facility) {
            let existing = this.cache.get(facility.icao);
            if (!existing) {
                if (msfssdk.ICAO.getFacilityType(facility.icao) === msfssdk.FacilityType.Airport) {
                    existing = new AirportWaypoint(facility, this.bus);
                }
                else {
                    existing = new msfssdk.FacilityWaypoint(facility, this.bus);
                }
                this.addToCache(facility, existing);
            }
            return existing;
        }
        /**
         * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
         * added, a waypoint will be removed from the cache in FIFO order.
         * @param facility The facility associated with the waypoint to add.
         * @param waypoint The waypoint to add.
         */
        addToCache(facility, waypoint) {
            this.cache.set(facility.icao, waypoint);
            if (this.cache.size > this.size) {
                this.cache.delete(this.cache.keys().next().value);
            }
        }
        /**
         * Gets a FacilityWaypointCache instance.
         * @param bus The event bus.
         * @returns A FacilityWaypointCache instance.
         */
        static getCache(bus) {
            var _a;
            return (_a = GarminFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (GarminFacilityWaypointCache.INSTANCE = new GarminFacilityWaypointCache(bus, 1000));
        }
    }

    /**
     * Valid CDI scale labels for the LVar scale enum.
     */
    exports.CDIScaleLabel = void 0;
    (function (CDIScaleLabel) {
        CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
        CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
        CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
        CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
        CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
        CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
        CDIScaleLabel[CDIScaleLabel["LNav"] = 6] = "LNav";
        CDIScaleLabel[CDIScaleLabel["LNavPlusV"] = 7] = "LNavPlusV";
        CDIScaleLabel[CDIScaleLabel["Visual"] = 8] = "Visual";
        CDIScaleLabel[CDIScaleLabel["LNavVNav"] = 9] = "LNavVNav";
        CDIScaleLabel[CDIScaleLabel["LP"] = 10] = "LP";
        CDIScaleLabel[CDIScaleLabel["LPPlusV"] = 11] = "LPPlusV";
        CDIScaleLabel[CDIScaleLabel["LPV"] = 12] = "LPV";
        CDIScaleLabel[CDIScaleLabel["Approach"] = 13] = "Approach";
        CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 14] = "MissedApproach";
    })(exports.CDIScaleLabel || (exports.CDIScaleLabel = {}));
    /**
     * Sim var names for Garmin LNAV-related data.
     */
    exports.GarminLNavDataVars = void 0;
    (function (GarminLNavDataVars) {
        /** The nominal desired track at the beginning of the flight plan leg following the currently tracked leg, in degrees true. */
        GarminLNavDataVars["NextDTKTrue"] = "L:WTGarmin_LNavData_Next_DTK_True";
        /** The nominal desired track at the beginning of the flight plan leg following the currently tracked leg, in degrees magnetic. */
        GarminLNavDataVars["NextDTKMagnetic"] = "L:WTGarmin_LNavData_Next_DTK_Mag";
        /** The current CDI scale label. */
        // eslint-disable-next-line @typescript-eslint/no-shadow
        GarminLNavDataVars["CDIScaleLabel"] = "L:WTGarmin_LNavData_CDI_Scale_Label";
        /** The nominal distance remaining to the egress transition of the currently tracked flight plan leg. */
        GarminLNavDataVars["EgressDistance"] = "L:WTGarmin_LNavData_Egress_Distance";
    })(exports.GarminLNavDataVars || (exports.GarminLNavDataVars = {}));
    /**
     * A publisher for Garmin LNAV-related data sim var events.
     */
    class LNavDataSimVarPublisher extends msfssdk.SimVarPublisher {
        /**
         * Constructor.
         * @param bus The event bus to which to publish.
         */
        constructor(bus) {
            super(LNavDataSimVarPublisher.simvars, bus);
        }
    }
    LNavDataSimVarPublisher.simvars = new Map([
        ['lnavdata_dtk_true', { name: msfssdk.LNavDataVars.DTKTrue, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_dtk_mag', { name: msfssdk.LNavDataVars.DTKMagnetic, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_xtk', { name: msfssdk.LNavDataVars.XTK, type: msfssdk.SimVarValueType.NM }],
        ['lnavdata_next_dtk_true', { name: exports.GarminLNavDataVars.NextDTKTrue, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_next_dtk_mag', { name: exports.GarminLNavDataVars.NextDTKMagnetic, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_cdi_scale', { name: msfssdk.LNavDataVars.CDIScale, type: msfssdk.SimVarValueType.NM }],
        ['lnavdata_cdi_scale_label', { name: exports.GarminLNavDataVars.CDIScaleLabel, type: msfssdk.SimVarValueType.Number }],
        ['lnavdata_waypoint_bearing_true', { name: msfssdk.LNavDataVars.WaypointBearingTrue, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_waypoint_bearing_mag', { name: msfssdk.LNavDataVars.WaypointBearingMagnetic, type: msfssdk.SimVarValueType.Degree }],
        ['lnavdata_waypoint_distance', { name: msfssdk.LNavDataVars.WaypointDistance, type: msfssdk.SimVarValueType.NM }],
        ['lnavdata_destination_distance', { name: msfssdk.LNavDataVars.DestinationDistance, type: msfssdk.SimVarValueType.NM }],
        ['lnavdata_egress_distance', { name: exports.GarminLNavDataVars.EgressDistance, type: msfssdk.SimVarValueType.NM }]
    ]);

    /**
     * Computes Garmin LNAV-related data.
     */
    class NavdataComputer {
        /**
         * Creates a new instance of the NavdataComputer.
         * @param bus The event bus to use with this instance.
         * @param flightPlanner The flight planner to use with this instance.
         * @param facilityLoader The facility loader to use with this instance.
         */
        constructor(bus, flightPlanner, facilityLoader) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.facilityLoader = facilityLoader;
            this.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];
            this.geoCircleCache = [new msfssdk.GeoCircle(new Float64Array(3), 0), new msfssdk.GeoCircle(new Float64Array(3), 0)];
            this.planePos = new msfssdk.GeoPoint(0, 0);
            this.obsAvailable = msfssdk.Subject.create(false);
            this.approachDetails = {
                approachLoaded: false,
                approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
                approachRnavType: msfssdk.RnavTypeFlags.None,
                approachIsActive: false,
                approachIsCircling: false
            };
            this.lnavData = msfssdk.ObjectSubject.create({
                dtkTrue: 0,
                dtkMag: 0,
                xtk: 0,
                nextDtkTrue: 0,
                nextDtkMag: 0,
                cdiScale: 0,
                cdiScaleLabel: exports.CDIScaleLabel.Enroute,
                waypointBearingTrue: 0,
                waypointBearingMag: 0,
                waypointDistance: 0,
                destinationDistance: 0,
                egressDistance: 0
            });
            this.initialDtk = { true: 0, mag: 0 };
            /**
             * A callback fired when any flight plan leg changes.
             * @param event is the FlightPlanLegEvent
             */
            this.onLegChanged = (event) => {
                if (this.flightPlanner.hasActiveFlightPlan()) {
                    const plan = this.flightPlanner.getActiveFlightPlan();
                    if (FmsUtils.getGlobalLegIndex(plan, event.segmentIndex, event.legIndex) === plan.activeLateralLeg && event.planIndex === this.flightPlanner.activePlanIndex) {
                        this.onActiveLegChanged(plan);
                    }
                }
            };
            const sub = this.bus.getSubscriber();
            this.isObsActive = msfssdk.ConsumerSubject.create(sub.on('gps_obs_active'), false);
            this.lnavIsTracking = msfssdk.ConsumerSubject.create(sub.on('lnav_is_tracking'), false);
            this.lnavLegIndex = msfssdk.ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
            this.lnavVectorIndex = msfssdk.ConsumerSubject.create(sub.on('lnav_tracked_vector_index'), 0);
            this.lnavTransitionMode = msfssdk.ConsumerSubject.create(sub.on('lnav_transition_mode'), msfssdk.LNavTransitionMode.None);
            this.lnavIsSuspended = msfssdk.ConsumerSubject.create(sub.on('lnav_is_suspended'), false);
            this.lnavDtk = msfssdk.ConsumerSubject.create(sub.on('lnav_dtk'), 0);
            this.lnavXtk = msfssdk.ConsumerSubject.create(sub.on('lnav_xtk'), 0);
            this.lnavVectorAnticipationDistance = msfssdk.ConsumerSubject.create(sub.on('lnav_vector_anticipation_distance'), 0);
            sub.on('gps-position').handle(lla => { this.planePos.set(lla.lat, lla.long); });
            sub.on('fplOriginDestChanged').handle(this.flightPlanOriginDestChanged.bind(this));
            sub.on('fplActiveLegChange').handle(event => { event.type === msfssdk.ActiveLegType.Lateral && this.onActiveLegChanged(); });
            sub.on('fplLegChange').handle(this.onLegChanged);
            sub.on('fplIndexChanged').handle(() => this.onActiveLegChanged());
            sub.on('fplSegmentChange').handle(() => this.onActiveLegChanged());
            sub.on('approach_details_set').handle(d => { this.approachDetails = d; });
            sub.on('realTime').atFrequency(1).handle(() => {
                this.computeCDIScaling();
            });
            sub.on('realTime').handle(() => {
                this.computeTrackingVars(msfssdk.MagVar.get(this.planePos));
            });
            this.lnavData.sub((obj, key, value) => {
                switch (key) {
                    case 'dtkTrue':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.DTKTrue, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'dtkMag':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.DTKMagnetic, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'xtk':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.XTK, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'nextDtkTrue':
                        SimVar.SetSimVarValue(exports.GarminLNavDataVars.NextDTKTrue, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'nextDtkMag':
                        SimVar.SetSimVarValue(exports.GarminLNavDataVars.NextDTKMagnetic, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'cdiScale':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.CDIScale, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'cdiScaleLabel':
                        SimVar.SetSimVarValue(exports.GarminLNavDataVars.CDIScaleLabel, msfssdk.SimVarValueType.Number, value);
                        break;
                    case 'waypointBearingTrue':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.WaypointBearingTrue, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'waypointBearingMag':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.WaypointBearingMagnetic, msfssdk.SimVarValueType.Degree, value);
                        break;
                    case 'waypointDistance':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.WaypointDistance, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'destinationDistance':
                        SimVar.SetSimVarValue(msfssdk.LNavDataVars.DestinationDistance, msfssdk.SimVarValueType.NM, value);
                        break;
                    case 'egressDistance':
                        SimVar.SetSimVarValue(exports.GarminLNavDataVars.EgressDistance, msfssdk.SimVarValueType.NM, value);
                        break;
                }
            }, true);
            this.obsAvailable.sub(v => {
                this.bus.getPublisher().pub('obs_available', v, true, true);
            });
        }
        /**
         * A callback fired when the active flight plan leg changes.
         * @param plan The Lateral Flight Plan (optional)
         */
        onActiveLegChanged(plan) {
            let activeLeg = null;
            if (plan === undefined && this.flightPlanner.hasActiveFlightPlan()) {
                plan = this.flightPlanner.getActiveFlightPlan();
            }
            if (plan !== undefined) {
                activeLeg = plan.tryGetLeg(plan.activeLateralLeg);
            }
            this.updateObsAvailable(activeLeg);
        }
        /**
         * A callback fired when the origin or destination changes in the flight plan.
         * @param e The event that was captured.
         */
        flightPlanOriginDestChanged(e) {
            if (e.airport !== undefined) {
                this.facilityLoader.getFacility(msfssdk.FacilityType.Airport, e.airport).then(fac => {
                    switch (e.type) {
                        case msfssdk.OriginDestChangeType.OriginAdded:
                            this.originFacility = fac;
                            break;
                        case msfssdk.OriginDestChangeType.DestinationAdded:
                            this.destinationFacility = fac;
                            break;
                    }
                });
            }
            if (e.type === msfssdk.OriginDestChangeType.OriginRemoved) {
                this.originFacility = undefined;
            }
            if (e.type === msfssdk.OriginDestChangeType.DestinationRemoved) {
                this.destinationFacility = undefined;
            }
        }
        /**
         * Computes the nav tracking data, such as XTK, DTK, and distance to turn.
         * @param magVar The computed current location magvar.
         */
        computeTrackingVars(magVar) {
            var _a, _b;
            let xtk = 0;
            let dtkTrue = 0;
            let dtkMag = 0;
            let nextDtkTrue = 0;
            let nextDtkMag = 0;
            let distance = 0;
            let waypointBearingTrue = 0;
            let waypointBearingMag = 0;
            let egressDistance = 0;
            let totalDistance = 0;
            if (this.lnavIsTracking.get()) {
                const plan = this.flightPlanner.hasActiveFlightPlan() && this.flightPlanner.getActiveFlightPlan();
                const trackedLegIndex = this.lnavLegIndex.get();
                const nextLegIndex = trackedLegIndex + 1;
                const currentLeg = plan && trackedLegIndex >= 0 && trackedLegIndex < plan.length ? plan.getLeg(trackedLegIndex) : undefined;
                const nextLeg = plan && nextLegIndex >= 0 && nextLegIndex < plan.length ? plan.getLeg(nextLegIndex) : undefined;
                if (currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) {
                    distance = this.getActiveDistance(currentLeg, this.planePos);
                    totalDistance = this.getTotalDistance(trackedLegIndex, distance);
                    if (currentLeg.calculated.endLat !== undefined && currentLeg.calculated.endLon) {
                        waypointBearingTrue = this.planePos.bearingTo(currentLeg.calculated.endLat, currentLeg.calculated.endLon);
                        waypointBearingMag = msfssdk.MagVar.trueToMagnetic(waypointBearingTrue, magVar);
                    }
                }
                if (nextLeg) {
                    ({ true: nextDtkTrue, mag: nextDtkMag } = this.getInitialDtk(nextLeg, this.initialDtk));
                }
                if (this.isObsActive.get()) {
                    xtk = this.lnavXtk.get();
                    dtkTrue = this.lnavDtk.get();
                    dtkMag = msfssdk.MagVar.trueToMagnetic(dtkTrue, magVar);
                    egressDistance = Number.MAX_VALUE;
                }
                else {
                    const transitionMode = this.lnavTransitionMode.get();
                    let circle;
                    if (transitionMode === msfssdk.LNavTransitionMode.Egress && ((_a = nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length)) {
                        circle = this.getNominalPathCircle(nextLeg, 0, msfssdk.LNavTransitionMode.Ingress, this.geoCircleCache[0]);
                        egressDistance = this.getDistanceToTurn(nextLeg, this.planePos, 0);
                    }
                    else if ((_b = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) {
                        const vectorIndex = this.lnavVectorIndex.get();
                        const isSuspended = this.lnavIsSuspended.get();
                        circle = this.getNominalPathCircle(currentLeg, vectorIndex, transitionMode, this.geoCircleCache[0]);
                        // Check if the next vector after the current tracked vector is the first egress vector of the leg, or the
                        // start of the next leg if the current leg has no egress.
                        let isNextVectorFirstEgress = false;
                        if (!isSuspended) { // LNAV can only sequence to the egress if it is not suspended
                            switch (transitionMode) {
                                case msfssdk.LNavTransitionMode.Ingress:
                                    isNextVectorFirstEgress = currentLeg.calculated.ingressToEgress.length === 0
                                        && vectorIndex === currentLeg.calculated.ingress.length - 1;
                                    break;
                                case msfssdk.LNavTransitionMode.None:
                                    isNextVectorFirstEgress = vectorIndex === currentLeg.calculated.ingressToEgress.length - 1;
                                    break;
                            }
                        }
                        egressDistance = this.getDistanceToTurn(currentLeg, this.planePos, isNextVectorFirstEgress ? this.lnavVectorAnticipationDistance.get() : 0);
                    }
                    if (circle !== undefined) {
                        xtk = msfssdk.UnitType.GA_RADIAN.convertTo(circle.distance(this.planePos), msfssdk.UnitType.NMILE);
                        dtkTrue = circle.bearingAt(this.planePos, Math.PI);
                        dtkMag = msfssdk.MagVar.trueToMagnetic(dtkTrue, magVar);
                    }
                }
            }
            this.lnavData.set('dtkTrue', dtkTrue);
            this.lnavData.set('dtkMag', dtkMag);
            this.lnavData.set('xtk', xtk);
            this.lnavData.set('nextDtkTrue', nextDtkTrue);
            this.lnavData.set('nextDtkMag', nextDtkMag);
            this.lnavData.set('waypointBearingTrue', waypointBearingTrue);
            this.lnavData.set('waypointBearingMag', waypointBearingMag);
            this.lnavData.set('waypointDistance', distance);
            this.lnavData.set('destinationDistance', totalDistance);
            this.lnavData.set('egressDistance', egressDistance);
        }
        /**
         * Computes the CDI scaling for the given LNAV data.
         */
        computeCDIScaling() {
            var _a, _b, _c, _d, _e, _f;
            let scale = 2.0;
            let scaleLabel = exports.CDIScaleLabel.Enroute;
            const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
            if (flightPlan && flightPlan.length > 0 && flightPlan.activeLateralLeg < flightPlan.length) {
                const activeSegment = flightPlan.getSegment(flightPlan.getSegmentIndex(flightPlan.activeLateralLeg));
                let previousLeg;
                try {
                    previousLeg = flightPlan.getLeg(flightPlan.activeLateralLeg - 1);
                }
                catch ( /*Do nothing*/_g) { /*Do nothing*/ }
                //We are currently in the departure segment
                if (activeSegment.segmentType === msfssdk.FlightPlanSegmentType.Departure) {
                    scale = 0.3;
                    scaleLabel = exports.CDIScaleLabel.Departure;
                    const prevLegType = previousLeg === null || previousLeg === void 0 ? void 0 : previousLeg.leg.type;
                    if (prevLegType && prevLegType !== msfssdk.LegType.IF && prevLegType !== msfssdk.LegType.CA && prevLegType !== msfssdk.LegType.FA) {
                        scale = 1.0;
                        scaleLabel = exports.CDIScaleLabel.Terminal;
                    }
                }
                //We are not in the departure segment any longer
                if (this.originFacility !== undefined && activeSegment.segmentType !== msfssdk.FlightPlanSegmentType.Departure) {
                    const distance = msfssdk.UnitType.GA_RADIAN.convertTo(this.planePos.distance(this.originFacility), msfssdk.UnitType.NMILE);
                    scale = 2.0 - msfssdk.NavMath.clamp(31 - distance, 0, 1);
                    if (distance <= 30) {
                        scaleLabel = exports.CDIScaleLabel.Terminal;
                    }
                }
                //Check for distance to destination
                if (this.destinationFacility !== undefined && activeSegment.segmentType !== msfssdk.FlightPlanSegmentType.Departure) {
                    const distance = msfssdk.UnitType.GA_RADIAN.convertTo(this.planePos.distance(this.destinationFacility), msfssdk.UnitType.NMILE);
                    scale = 2.0 - msfssdk.NavMath.clamp(31 - distance, 0, 1);
                    if (distance <= 30) {
                        scaleLabel = exports.CDIScaleLabel.Terminal;
                    }
                }
                //Check for distance from arrival start
                if (activeSegment.segmentType === msfssdk.FlightPlanSegmentType.Arrival && activeSegment.legs.length > 1) {
                    const firstArrivalLeg = activeSegment.legs[1];
                    //If we're going from the start of the arrival (i.e. the second leg)
                    if (flightPlan.activeLateralLeg === activeSegment.offset + 1
                        && ((_a = firstArrivalLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) !== undefined
                        && ((_b = firstArrivalLeg.calculated) === null || _b === void 0 ? void 0 : _b.startLon) !== undefined
                        && ((_c = firstArrivalLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) !== undefined
                        && ((_d = firstArrivalLeg.calculated) === null || _d === void 0 ? void 0 : _d.endLon) !== undefined) {
                        const start = this.geoPointCache[1].set(firstArrivalLeg.calculated.startLat, firstArrivalLeg.calculated.startLon);
                        const end = this.geoPointCache[2].set(firstArrivalLeg.calculated.endLat, firstArrivalLeg.calculated.endLon);
                        const distance = msfssdk.NavMath.alongTrack(start, end, this.planePos);
                        scale = 2.0 - msfssdk.NavMath.clamp(distance, 0, 1);
                        if (distance >= 1) {
                            scaleLabel = exports.CDIScaleLabel.Terminal;
                        }
                    }
                    else if (flightPlan.activeLateralLeg > activeSegment.offset + 1) {
                        scale = 1.0;
                        scaleLabel = exports.CDIScaleLabel.Terminal;
                    }
                }
                //We are in the approach
                if (activeSegment.segmentType === msfssdk.FlightPlanSegmentType.Approach) {
                    scale = 1.0;
                    scaleLabel = exports.CDIScaleLabel.Terminal;
                    const fafIndex = this.getFafIndex(activeSegment);
                    const currentLeg = flightPlan.activeLateralLeg >= 0 && flightPlan.activeLateralLeg < flightPlan.length ? flightPlan.getLeg(flightPlan.activeLateralLeg) : undefined;
                    if (fafIndex !== undefined && flightPlan.activeLateralLeg === fafIndex) {
                        const fafCalc = flightPlan.getLeg(fafIndex).calculated;
                        if ((fafCalc === null || fafCalc === void 0 ? void 0 : fafCalc.endLat) !== undefined && (fafCalc === null || fafCalc === void 0 ? void 0 : fafCalc.endLon) !== undefined) {
                            const distance = msfssdk.UnitType.GA_RADIAN.convertTo(this.planePos.distance(fafCalc.endLat, fafCalc.endLon), msfssdk.UnitType.NMILE);
                            scale = 1.0 - (0.7 * (msfssdk.NavMath.clamp(2 - distance, 0, 2) / 2));
                            if (distance <= 2) {
                                scaleLabel = this.getApproachCdiScale();
                            }
                        }
                    }
                    else if (((_e = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.endLat) && ((_f = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _f === void 0 ? void 0 : _f.endLon) && fafIndex !== undefined && flightPlan.activeLateralLeg > fafIndex) {
                        if (currentLeg && msfssdk.BitFlags.isAll(currentLeg.flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                            scale = 1.0;
                            scaleLabel = exports.CDIScaleLabel.MissedApproach;
                        }
                        else {
                            const legLength = currentLeg.calculated.distance;
                            const distance = msfssdk.UnitType.GA_RADIAN.convertTo(this.planePos.distance(currentLeg.calculated.endLat, currentLeg.calculated.endLon), msfssdk.UnitType.NMILE);
                            scale = 0.3 - (0.112 * (msfssdk.NavMath.clamp(legLength - distance, 0, legLength) / legLength));
                            scaleLabel = this.getApproachCdiScale();
                        }
                    }
                }
            }
            this.lnavData.set('cdiScale', scale);
            this.lnavData.set('cdiScaleLabel', scaleLabel);
        }
        /**
         * Gets the index of the FAF in a segment.
         * @param segment The segment to search.
         * @returns The index of the FAF if found.
         */
        getFafIndex(segment) {
            let fafLeg = segment.legs[segment.legs.length - 2];
            let fafIndex = segment.legs.length - 2;
            for (let i = 0; i < segment.legs.length; i++) {
                const leg = segment.legs[i];
                if (leg.leg.fixTypeFlags & msfssdk.FixTypeFlags.FAF) {
                    fafLeg = leg;
                    fafIndex = i;
                    break;
                }
            }
            if (fafLeg !== undefined) {
                return segment.offset + fafIndex;
            }
        }
        /**
         * Gets the initial desired track of a flight plan leg in degrees true and magnetic.
         * @param leg A flight plan leg.
         * @param out The object to which to write the result.
         * @param out.true The desired track, in degrees true.
         * @param out.mag The desired track, in degrees magnetic.
         * @returns The initial desired track of a flight plan leg in degrees true and magnetic.
         */
        // eslint-disable-next-line jsdoc/require-jsdoc
        getInitialDtk(leg, out) {
            out.true = 0;
            out.mag = 0;
            if (leg.calculated) {
                switch (leg.leg.type) {
                    case msfssdk.LegType.DF: {
                        const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
                        if (vector) {
                            const circle = msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                            const point = circle.isGreatCircle()
                                ? this.geoPointCache[0].set(vector.startLat, vector.startLon)
                                : this.geoPointCache[0].set(vector.endLat, vector.endLon);
                            out.true = circle.bearingAt(point, Math.PI);
                            out.mag = msfssdk.MagVar.trueToMagnetic(out.true, point);
                        }
                        break;
                    }
                    default:
                        if (leg.calculated.initialDtk) {
                            out.mag = leg.calculated.initialDtk;
                            out.true = leg.calculated.startLat !== undefined && leg.calculated.startLon !== undefined
                                ? msfssdk.MagVar.magneticToTrue(out.mag, leg.calculated.startLat, leg.calculated.startLon)
                                : out.mag;
                        }
                }
            }
            return out;
        }
        /**
         * Gets the geo circle describing the nominal path tracked by LNAV.
         * @param leg The flight plan leg currently tracked by LNAV.
         * @param vectorIndex The index of the vector currently tracked by LNAV.
         * @param transitionMode The current LNAV transition mode.
         * @param out The geo circle to which to write the result.
         * @returns The geo circle describing the initial path of a flight plan leg, or undefined if one could not be
         * determined.
         */
        getNominalPathCircle(leg, vectorIndex, transitionMode, out) {
            if (!leg.calculated) {
                return undefined;
            }
            const legCalc = leg.calculated;
            switch (leg.leg.type) {
                case msfssdk.LegType.DF: {
                    const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
                    if (!vector) {
                        return undefined;
                    }
                    if (msfssdk.FlightPathUtils.isVectorGreatCircle(vector)) {
                        return msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, out);
                    }
                    else {
                        const turn = msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, out);
                        const turnEnd = this.geoPointCache[0].set(vector.endLat, vector.endLon);
                        const bearingAtEnd = turn.bearingAt(turnEnd);
                        return isNaN(bearingAtEnd) ? undefined : out.setAsGreatCircle(turnEnd, bearingAtEnd);
                    }
                }
                case msfssdk.LegType.HM:
                case msfssdk.LegType.HF:
                case msfssdk.LegType.HA: {
                    const vectors = transitionMode === msfssdk.LNavTransitionMode.None
                        ? msfssdk.LNavDirector.getVectorsForTransitionMode(legCalc, transitionMode, this.lnavIsSuspended.get())
                        : legCalc.flightPath;
                    const searchStartIndex = transitionMode === msfssdk.LNavTransitionMode.None
                        ? vectorIndex
                        : transitionMode === msfssdk.LNavTransitionMode.Ingress
                            ? 0
                            : 3;
                    let vector;
                    for (let i = searchStartIndex; i < vectors.length; i++) {
                        const holdVector = vectors[i];
                        if (msfssdk.BitFlags.isAny(holdVector.flags, msfssdk.FlightPathVectorFlags.HoldOutboundLeg | msfssdk.FlightPathVectorFlags.HoldInboundLeg)) {
                            vector = holdVector;
                            break;
                        }
                    }
                    return vector ? msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, out) : undefined;
                }
                default: {
                    const vector = legCalc.flightPath[transitionMode === msfssdk.LNavTransitionMode.None
                        ? vectorIndex
                        : transitionMode === msfssdk.LNavTransitionMode.Ingress
                            ? 0
                            : legCalc.flightPath.length - 1];
                    return vector ? msfssdk.FlightPathUtils.setGeoCircleFromVector(vector, out) : undefined;
                }
            }
        }
        /**
         * Gets the active distance from the plane position to the leg end.
         * @param leg The leg to get the distance for.
         * @param pos The current plane position.
         * @returns The distance, in nautical miles.
         */
        getActiveDistance(leg, pos) {
            var _a;
            const finalVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[leg.calculated.flightPath.length - 1];
            if (finalVector !== undefined) {
                return msfssdk.UnitType.GA_RADIAN.convertTo(pos.distance(finalVector.endLat, finalVector.endLon), msfssdk.UnitType.NMILE);
            }
            return 0;
        }
        /**
         * Gets the total distance from the plane position to the destination leg.
         * @param activeLegIndex The global leg index of the active flight plan leg.
         * @param activeLegDistance The distance from the present position to the end of the active leg, in nautical miles.
         * @returns The distance, in nautical miles.
         */
        getTotalDistance(activeLegIndex, activeLegDistance) {
            var _a, _b, _c, _d, _e, _f;
            const plan = this.flightPlanner.getActiveFlightPlan();
            const activeLegCumulativeDistance = (_c = (_b = (_a = plan.tryGetLeg(activeLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            let lastLegIndex = plan.length - 1;
            for (const leg of plan.legs(true)) {
                if (!msfssdk.BitFlags.isAll(leg.flags, msfssdk.LegDefinitionFlags.MissedApproach)) {
                    break;
                }
                lastLegIndex--;
            }
            const destinationLegCumulativeDistance = (_f = (_e = (_d = plan.tryGetLeg(lastLegIndex)) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            return msfssdk.UnitType.METER.convertTo(destinationLegCumulativeDistance - activeLegCumulativeDistance, msfssdk.UnitType.NMILE) + activeLegDistance;
        }
        /**
         * Gets the active distance from the plane position to the next leg turn.
         * @param leg The leg to get the distance for.
         * @param pos The current plane position.
         * @param anticipation The vector anticipation to apply, in nautical miles.
         * @returns The distance, in nautical miles.
         */
        getDistanceToTurn(leg, pos, anticipation) {
            var _a;
            let turnStart;
            if (leg.calculated !== undefined) {
                const firstEgressVector = leg.calculated.egress[0];
                const prevVector = (_a = leg.calculated.ingressToEgress[leg.calculated.ingressToEgress.length - 1]) !== null && _a !== void 0 ? _a : leg.calculated.ingress[leg.calculated.ingress.length - 1];
                if (anticipation !== 0 && prevVector !== undefined) {
                    if (prevVector.distance > msfssdk.UnitType.NMILE.convertTo(anticipation, msfssdk.UnitType.METER)) {
                        const vectorCircle = msfssdk.FlightPathUtils.setGeoCircleFromVector(prevVector, this.geoCircleCache[1]);
                        turnStart = vectorCircle.offsetDistanceAlong(this.geoPointCache[0].set(prevVector.endLat, prevVector.endLon), msfssdk.UnitType.NMILE.convertTo(-anticipation, msfssdk.UnitType.GA_RADIAN), this.geoPointCache[0]);
                    }
                    else {
                        turnStart = this.geoPointCache[0].set(prevVector.startLat, prevVector.startLon);
                    }
                }
                if (turnStart === undefined) {
                    if (firstEgressVector) {
                        turnStart = this.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                    }
                    else if (leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                        turnStart = this.geoPointCache[0].set(leg.calculated.endLat, leg.calculated.endLon);
                    }
                }
            }
            return turnStart === undefined ? 0 : msfssdk.UnitType.GA_RADIAN.convertTo(pos.distance(turnStart), msfssdk.UnitType.NMILE);
        }
        /**
         * Updates whether OBS is available based on the current active flight plan leg, and sends a control event if OBS
         * availability has changed since the last update.
         * @param activeLeg The active flight plan leg, or `null` if none exists.
         */
        updateObsAvailable(activeLeg) {
            let newObsAvailable = false;
            if (activeLeg) {
                switch (activeLeg.leg.type) {
                    case msfssdk.LegType.AF:
                    case msfssdk.LegType.CD:
                    case msfssdk.LegType.CF:
                    case msfssdk.LegType.CR:
                    case msfssdk.LegType.DF:
                    case msfssdk.LegType.IF:
                    case msfssdk.LegType.RF:
                    case msfssdk.LegType.TF:
                        newObsAvailable = true;
                        break;
                }
            }
            this.obsAvailable.set(newObsAvailable);
        }
        /**
         * Checks and returns the CDI Scale when in an approach.
         * @returns The CDIScaleLabel appropriate for the approach.
         */
        getApproachCdiScale() {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                    switch (this.approachDetails.approachRnavType) {
                        case msfssdk.RnavTypeFlags.LPV:
                            return exports.CDIScaleLabel.LPV;
                        case msfssdk.RnavTypeFlags.LP:
                            return this.approachDetails.approachIsCircling ? exports.CDIScaleLabel.LP : exports.CDIScaleLabel.LPPlusV;
                        case msfssdk.RnavTypeFlags.LNAVVNAV:
                            return exports.CDIScaleLabel.LNavVNav;
                    }
                    return this.approachDetails.approachIsCircling ? exports.CDIScaleLabel.LNav : exports.CDIScaleLabel.LNavPlusV;
                case msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    return exports.CDIScaleLabel.Visual;
                default:
                    return exports.CDIScaleLabel.Terminal;
            }
        }
    }

    exports.NavSensitivity = void 0;
    (function (NavSensitivity) {
        NavSensitivity["DPRT"] = "DPRT";
        NavSensitivity["TERM"] = "TERM";
        NavSensitivity["ENR"] = "ENR";
        NavSensitivity["OCN"] = "OCN";
        NavSensitivity["LNAV"] = "LNAV";
        NavSensitivity["LNAVplusV"] = "LNAV+V";
        NavSensitivity["VIS"] = "VISUAL";
        NavSensitivity["LVNAV"] = "L/VNAV";
        NavSensitivity["LPV"] = "LPV";
        NavSensitivity["LP"] = "LP";
        NavSensitivity["LPplusV"] = "LP+V";
        NavSensitivity["MAPR"] = "MAPR";
        NavSensitivity["VOR"] = "VOR";
        NavSensitivity["ILS"] = "ILS";
    })(exports.NavSensitivity || (exports.NavSensitivity = {}));
    exports.ObsSuspModes = void 0;
    (function (ObsSuspModes) {
        ObsSuspModes[ObsSuspModes["NONE"] = 0] = "NONE";
        ObsSuspModes[ObsSuspModes["SUSP"] = 1] = "SUSP";
        ObsSuspModes[ObsSuspModes["OBS"] = 2] = "OBS";
    })(exports.ObsSuspModes || (exports.ObsSuspModes = {}));
    exports.VNavDisplayMode = void 0;
    (function (VNavDisplayMode) {
        VNavDisplayMode[VNavDisplayMode["NONE"] = 0] = "NONE";
        VNavDisplayMode[VNavDisplayMode["PATH"] = 1] = "PATH";
    })(exports.VNavDisplayMode || (exports.VNavDisplayMode = {}));
    exports.GPDisplayMode = void 0;
    (function (GPDisplayMode) {
        GPDisplayMode[GPDisplayMode["NONE"] = 0] = "NONE";
        GPDisplayMode[GPDisplayMode["PREVIEW"] = 1] = "PREVIEW";
        GPDisplayMode[GPDisplayMode["ACTIVE"] = 2] = "ACTIVE";
    })(exports.GPDisplayMode || (exports.GPDisplayMode = {}));
    /**
     * Encapsulation of the logic for an nav source.
     */
    class HsiSource {
        /**
         * Create an HSI Source
         * @param id The navsourceid.
         */
        constructor(id) {
            this.valid = false;
            this.bearing = null;
            this.distance = null;
            this.deviation = null;
            this.deviationScale = 1.0;
            this.deviationScaleLabel = null;
            this.toFrom = msfssdk.VorToFrom.OFF;
            this.dtk_obs = null;
            this.isLocalizer = false;
            this.hasSignal = false;
            this.hasLocalizer = false;
            this.localizerCourse = null;
            this.hasGlideslope = false;
            this.gsDeviation = null;
            this.altDeviation = null;
            this.hasDme = false;
            this.frequency = null;
            this.source = id;
            if (this.source.type === msfssdk.NavSourceType.Nav) {
                this.dtk_obs = 0;
            }
        }
    }
    /**
     * A NavIndicatorController to control what nav sources are being indicated on the panel.
     */
    class NavIndicatorController {
        /**
         * Initialize an instance of the NavIndicatorController.
         * @param bus is the event bus
         * @param fms is the fms
         */
        constructor(bus, fms) {
            this.fms = fms;
            this.navStates = [];
            this.activeSensitivity = exports.NavSensitivity.VOR;
            this.activeSourceIndex = 0;
            this.hsiMapActive = false;
            this.courseNeedleRefs = { hsiRose: undefined, hsiMap: undefined };
            this.hsiRefs = { hsiRose: undefined, hsiMap: undefined };
            this.hsiMapDeviationRef = undefined;
            this.vdi = undefined;
            this.bearingPointerStatus = [false, false];
            this.bearingPointerAdf = [false, false];
            this.bearingPointerDirection = [null, null];
            this.bearingPointerSourceIdxs = [-1, -1];
            this.bearingValidity = [false, false];
            this.firstRun = true;
            this.obsSuspMode = exports.ObsSuspModes.NONE;
            this.missedApproachActive = false;
            this.lnavLegType = msfssdk.LegType.Discontinuity;
            this.currentSpeed = 30;
            this.currentHeading = 0;
            this.currentAltitude = 0;
            this.currentVNavTodDistance = -1;
            this.currentVNavBodDistance = -1;
            this.vnavPathInRange = false;
            this.currentVNavTargetAltitude = -1;
            this.currentVNavConstraintAltitude = -1;
            this.currentVNavFpa = 0;
            this.vnavState = msfssdk.VNavState.Enabled_Inactive;
            this.currentVNavPathMode = msfssdk.VNavPathMode.None;
            this.vnavDisplayMode = msfssdk.Subject.create(exports.VNavDisplayMode.NONE);
            this.gpDisplayMode = msfssdk.Subject.create(exports.GPDisplayMode.NONE);
            this.currentVnavApproachMode = msfssdk.ApproachGuidanceMode.None;
            this.currentLpvDeviation = Number.POSITIVE_INFINITY;
            this.currentLpvDistance = Number.POSITIVE_INFINITY;
            this.dmeSourceIndex = msfssdk.Subject.create(0);
            this.dmeDistanceSubject = msfssdk.Subject.create(-1);
            this.isLnavCalculating = msfssdk.Subject.create(false);
            this.shouldDisplayPathMode = msfssdk.Subject.create(false);
            /**
             * A callback called when the CDI Source Changes.
             * @param source The current selected CDI Source.
             */
            this.onUpdateCdiSelect = (source) => {
                if (source.type !== this.navStates[this.activeSourceIndex].source.type
                    || source.index !== this.navStates[this.activeSourceIndex].source.index) {
                    switch (source.type) {
                        case msfssdk.NavSourceType.Nav:
                            if (source.index == 1) {
                                this.activeSourceIndex = 0;
                            }
                            else {
                                this.activeSourceIndex = 1;
                            }
                            if (this.navStates[this.activeSourceIndex].isLocalizer && this.navStates[this.activeSourceIndex].hasLocalizer) {
                                this.slewObs();
                            }
                            break;
                        case msfssdk.NavSourceType.Gps:
                            this.activeSourceIndex = 2;
                            break;
                    }
                    this.updateSensitivity();
                    this.updateVNavDisplayMode();
                }
            };
            /**
             * A callback called when the obs updates from the event bus.
             * @param obs The current obs/dtk value.
             */
            this.onUpdateDtk = (obs) => {
                if (obs.source.type === msfssdk.NavSourceType.Nav) {
                    switch (obs.source.index) {
                        case 1:
                            this.navStates[0].dtk_obs = obs.heading;
                            break;
                        case 2:
                            this.navStates[1].dtk_obs = obs.heading;
                            break;
                    }
                    this.updateComponentsData(obs.source);
                }
            };
            /**
             * A callback called when the lnav dtk updates from the event bus.
             * @param dtk The current lnav dtk value.
             */
            this.onUpdateLnavDtk = (dtk) => {
                if (!this.isLnavCalculating.get()) {
                    this.navStates[2].dtk_obs = this.currentHeading;
                }
                else if (dtk !== this.navStates[2].dtk_obs) {
                    this.navStates[2].dtk_obs = dtk;
                }
                if (this.activeSourceIndex == 2) {
                    this.setLnavToFrom();
                    this.updateComponentsData(this.navStates[2].source);
                }
            };
            /**
             * A callback called when the lnav xtk updates from the event bus.
             * @param xtk The current lnav xtk value.
             */
            this.onUpdateLnavXtk = (xtk) => {
                // Check for both a full or direct to flight plan.
                if (!this.isLnavCalculating.get()) {
                    if (this.navStates[2].toFrom !== msfssdk.VorToFrom.OFF) {
                        this.navStates[2].toFrom = msfssdk.VorToFrom.OFF;
                        this.updateComponentsDisplay(this.navStates[2].source);
                    }
                }
                else if (this.navStates[2].deviation === null || -xtk !== (this.navStates[2].deviation * this.navStates[2].deviationScale)) {
                    this.navStates[2].deviation = (-xtk / this.navStates[2].deviationScale);
                    if (this.navStates[2].toFrom === msfssdk.VorToFrom.OFF) {
                        this.setLnavToFrom();
                        this.updateComponentsDisplay(this.navStates[2].source);
                    }
                }
                if (this.activeSourceIndex == 2) {
                    this.updateComponentsData();
                }
            };
            /**
             * A callback called when the bearing to an lnav fix updates across the event bus to set the to/from flag for GPS.
             * @param brg The current bearing to the current fix.
             */
            this.onUpdateLnavBrg = (brg) => {
                this.navStates[2].bearing = brg;
                this.setLnavToFrom() && this.updateComponentsDisplay(this.navStates[2].source);
            };
            /**
             * A callback called when the cdi deviation updates from the event bus.
             * @param deviation The current deviation value.
             */
            this.onUpdateCdiDeviation = (deviation) => {
                if (deviation.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (deviation.source.index) {
                    case this.navStates[0].source.index:
                        this.navStates[0].deviation = deviation.deviation !== null ? deviation.deviation / 127 : -100;
                        break;
                    case this.navStates[1].source.index:
                        this.navStates[1].deviation = deviation.deviation !== null ? deviation.deviation / 127 : -100;
                        break;
                }
                this.updateComponentsData(deviation.source);
            };
            /**
             * A callback called when the vor to/from updates from the event bus.
             * @param toFrom The current to/from value.
             */
            this.onUpdateToFrom = (toFrom) => {
                if (toFrom.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (toFrom.source.index) {
                    case this.navStates[0].source.index:
                        this.navStates[0].toFrom = toFrom.toFrom;
                        break;
                    case this.navStates[1].source.index:
                        this.navStates[1].toFrom = toFrom.toFrom;
                        break;
                }
                this.updateComponentsDisplay(toFrom.source);
            };
            /**
             * A callback called when the dme updates from the event bus.
             * @param dme The current deviation value.
             */
            this.onUpdateDme = (dme) => {
                if (dme.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (dme.source.index) {
                    case this.navStates[0].source.index:
                        this.navStates[0].hasDme = dme.hasDme;
                        this.navStates[0].distance = dme.dmeDistance;
                        break;
                    case this.navStates[1].source.index:
                        this.navStates[1].hasDme = dme.hasDme;
                        this.navStates[1].distance = dme.dmeDistance;
                        break;
                }
                const dmeSource = this.dmeSourceIndex.get();
                const dmeDistance = this.navStates[dmeSource].distance;
                if (this.navStates[dmeSource].hasDme && dmeDistance !== null && dmeDistance > 0) {
                    this.dmeDistanceSubject.set(dmeDistance);
                }
                else {
                    this.dmeDistanceSubject.set(-1);
                }
            };
            /**
             * A callback called when the localizer data updates from the event bus.
             * @param localizer The current localizer data.
             */
            this.onUpdateLocalizer = (localizer) => {
                if (localizer.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (localizer.source.index) {
                    case this.navStates[0].source.index:
                        this.navStates[0].hasLocalizer = localizer.isValid;
                        if (localizer.isValid) {
                            this.navStates[0].localizerCourse = localizer.course;
                        }
                        break;
                    case this.navStates[1].source.index:
                        this.navStates[1].hasLocalizer = localizer.isValid;
                        if (localizer.isValid) {
                            this.navStates[1].localizerCourse = localizer.course;
                        }
                        break;
                }
                this.slewObs();
                this.updateSensitivity(localizer.source);
                this.updateVNavDisplayMode();
            };
            /**
             * A callback called when the glideslope data updates from the event bus.
             * @param glideslope The current glideslope data.
             */
            this.onUpdateGlideslope = (glideslope) => {
                var _a, _b;
                if (glideslope.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (glideslope.source.index) {
                    case this.navStates[0].source.index:
                        if (glideslope.isValid == this.navStates[0].hasGlideslope && glideslope.isValid) {
                            this.navStates[0].gsDeviation = glideslope.deviation;
                            (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
                            return;
                        }
                        else {
                            this.navStates[0].hasGlideslope = glideslope.isValid;
                            if (glideslope.isValid) {
                                this.navStates[0].gsDeviation = glideslope.deviation;
                            }
                            this.updateVNavDisplayMode();
                        }
                        break;
                    case this.navStates[1].source.index:
                        if (glideslope.isValid == this.navStates[1].hasGlideslope && glideslope.isValid) {
                            this.navStates[1].gsDeviation = glideslope.deviation;
                            (_b = this.vdi) === null || _b === void 0 ? void 0 : _b.updateDeviation();
                            return;
                        }
                        else {
                            this.navStates[1].hasGlideslope = glideslope.isValid;
                            if (glideslope.isValid) {
                                this.navStates[1].gsDeviation = glideslope.deviation;
                            }
                            this.updateVNavDisplayMode();
                        }
                        break;
                }
            };
            /**
             * A callback called when isLoc value updates from the event bus.
             * @param isLoc The current isLoc value.
             */
            this.onUpdateIsLocFreq = (isLoc) => {
                if (isLoc.source.type !== msfssdk.NavSourceType.Nav) {
                    return;
                }
                switch (isLoc.source.index) {
                    case this.navStates[0].source.index:
                        this.navStates[0].isLocalizer = isLoc.isLocalizer;
                        break;
                    case this.navStates[1].source.index:
                        this.navStates[1].isLocalizer = isLoc.isLocalizer;
                        break;
                }
                this.updateComponentsDisplay(isLoc.source);
            };
            /**
             * Update the source of a bearing pointer.
             * @param data The new bearing source info.
             */
            this.updateBearingSrc = (data) => {
                var _a;
                if (data.source === null || ((_a = data.source) === null || _a === void 0 ? void 0 : _a.type) === undefined) {
                    this.bearingPointerStatus[data.index] = false;
                    this.bearingPointerAdf[data.index] = false;
                    this.bearingPointerSourceIdxs[data.index] = -1;
                }
                else {
                    this.bearingPointerSourceIdxs[data.index] = this.getNavSourceIndex(data.source);
                    this.bearingPointerStatus[data.index] = true;
                    if (data.source.type === msfssdk.NavSourceType.Adf) {
                        this.bearingPointerAdf[data.index] = true;
                    }
                    else {
                        this.bearingPointerAdf[data.index] = false;
                    }
                }
                if (this.bearingPointerDirection[data.index] !== null) {
                    this.updateBearingDir({ index: data.index, direction: this.bearingPointerDirection[data.index] });
                }
                if (this.bearingPointerStatus[0] == true || this.bearingPointerStatus[1] == true) {
                    this.hsiRefs.hsiRose.instance.compassRoseComponent.instance.setCircleVisible(true);
                }
                else {
                    this.hsiRefs.hsiRose.instance.compassRoseComponent.instance.setCircleVisible(false);
                }
                this.updateBearingPointers(data.index, (element) => {
                    if (element !== null && element.instance !== null) {
                        if (data.source === null) {
                            element.instance.style.display = 'none';
                            return;
                        }
                        const source = data.source;
                        if (source.type !== msfssdk.NavSourceType.Nav && source.type !== msfssdk.NavSourceType.Gps && source.type !== msfssdk.NavSourceType.Adf) {
                            element.instance.style.display = 'none';
                            this.bearingPointerStatus[data.index] = false;
                        }
                        else if (!this.bearingValidity[data.index] || (source.type == msfssdk.NavSourceType.Nav && this.navStates[source.index - 1].isLocalizer)) {
                            element.instance.style.display = 'none';
                        }
                        else {
                            element.instance.style.display = '';
                        }
                    }
                });
            };
            /**
             * Update the validity of a bearing source.
             * @param data The validity event.
             */
            this.updateBearingValidity = (data) => {
                this.bearingValidity[data.index] = data.valid;
                this.updateBearingPointers(data.index, (element) => {
                    if (element !== null && element.instance !== null) {
                        if (data.valid && !this.navStates[this.bearingPointerSourceIdxs[data.index]].isLocalizer) {
                            element.instance.style.display = '';
                        }
                        else {
                            element.instance.style.display = 'none';
                        }
                    }
                });
            };
            /**
             * Update the heading of a bearing pointer.
             * @param data The BearingDirection message.
             */
            this.updateBearingDir = (data) => {
                let direction = data.direction;
                this.bearingPointerDirection[data.index] = direction;
                if (this.bearingPointerAdf[data.index] && data.direction !== null) {
                    direction = msfssdk.NavMath.normalizeHeading(data.direction + this.currentHeading);
                }
                this.updateBearingPointers(data.index, (element) => {
                    if (element !== null && element.instance !== null && direction !== null) {
                        const newDirection = Math.round(direction * 100) / 100;
                        element.instance.style.transform = `rotate3d(0, 0, 1, ${newDirection}deg)`;
                    }
                    // We had previously hidden the pointer if the direction was null, but that causes initialization
                    // issues which can cause the pointer to stay masked at startup, and there should always be a
                    // direction if the signal is valid.  Pointer hiding is taken care of by the invalid-signal
                    // handling and doesn't need to be done here.
                });
            };
            this.bus = bus;
            for (let i = 0; i < 3; i++) {
                const type = i < 2 ? msfssdk.NavSourceType.Nav : msfssdk.NavSourceType.Gps;
                const index = i == 1 ? 2 : 1;
                const sourceId = { type: type, index: index };
                const source = new HsiSource(sourceId);
                source.toFrom = msfssdk.VorToFrom.OFF;
                this.navStates.push(source);
            }
            this.monitorEvents();
            this.shouldDisplayPathMode.sub((v) => {
                this.bus.getPublisher().pub('vnav_path_display', v, true);
            });
        }
        /**
         * Method to monitor nav processor events to keep track of HSI-related data.
         */
        monitorEvents() {
            const control = this.bus.getSubscriber();
            control.on('approach_details_set').handle(() => {
                this.updateSensitivity();
                this.onUpdateLpv(this.currentLpvDeviation, this.currentLpvDistance);
            });
            this.bus.getSubscriber().on('ground_speed').handle(speed => this.currentSpeed = speed);
            const adahrs = this.bus.getSubscriber();
            adahrs.on('hdg_deg').withPrecision(1).handle(hdg => this.currentHeading = hdg);
            adahrs.on('indicated_alt').atFrequency(1).handle(alt => this.currentAltitude = alt);
            const navcom = this.bus.getSubscriber();
            navcom.on('set_frequency').handle((setFrequency) => {
                if (setFrequency.radio.radioType === msfssdk.RadioType.Nav && setFrequency.bank == msfssdk.FrequencyBank.Active) {
                    this.navStates[setFrequency.radio.index - 1].frequency = setFrequency.frequency;
                    if (this.getNavSourceIndex({ type: msfssdk.NavSourceType.Nav, index: setFrequency.radio.index }) === this.activeSourceIndex) {
                        this.updateSensitivity();
                    }
                }
            });
            const nav = this.bus.getSubscriber();
            nav.on('cdi_select').handle(this.onUpdateCdiSelect);
            nav.on('obs_set').handle(this.onUpdateDtk);
            nav.on('cdi_deviation').handle(this.onUpdateCdiDeviation);
            nav.on('vor_to_from').handle(this.onUpdateToFrom);
            nav.on('localizer').handle(this.onUpdateLocalizer);
            nav.on('glideslope').handle(this.onUpdateGlideslope);
            nav.on('is_localizer_frequency').handle(this.onUpdateIsLocFreq);
            nav.on('brg_source').handle(this.updateBearingSrc);
            nav.on('brg_direction').handle(this.updateBearingDir);
            nav.on('dme_state').handle(this.onUpdateDme);
            nav.on('brg_validity').handle(this.updateBearingValidity);
            nav.on('gps_obs_active').handle(obsActive => {
                if (obsActive) {
                    this.obsSuspMode = exports.ObsSuspModes.OBS;
                }
                else {
                    this.obsSuspMode = exports.ObsSuspModes.NONE;
                }
                if (this.onUpdateDtkBox !== undefined) {
                    this.onUpdateDtkBox();
                }
                this.updateSensitivity();
            });
            const lnavEvents = this.bus.getSubscriber();
            lnavEvents.on('lnavdata_dtk_mag').handle(this.onUpdateLnavDtk);
            lnavEvents.on('lnavdata_xtk').handle(this.onUpdateLnavXtk);
            lnavEvents.on('lnavdata_waypoint_bearing_mag').whenChangedBy(5).handle(this.onUpdateLnavBrg);
            lnavEvents.on('lnavdata_cdi_scale').handle(scale => {
                this.navStates[2].deviationScale = scale;
            });
            lnavEvents.on('lnavdata_cdi_scale_label').handle(label => {
                this.navStates[2].deviationScaleLabel = label;
                this.updateSensitivity();
            });
            lnavEvents.on('lnav_is_suspended').whenChanged().handle(isSuspended => {
                if (isSuspended) {
                    this.obsSuspMode = exports.ObsSuspModes.SUSP;
                }
                else {
                    this.obsSuspMode = exports.ObsSuspModes.NONE;
                }
                this.updateSensitivity();
            });
            lnavEvents.on('lnav_tracked_leg_index').whenChanged().handle(this.getActiveLegType.bind(this));
            const vnav = this.bus.getSubscriber();
            vnav.on('vnav_vertical_deviation').withPrecision(0).handle(deviation => this.onUpdateVnav(deviation));
            vnav.on('gp_vertical_deviation').withPrecision(0).handle(deviation => this.onUpdateLpv(deviation, this.currentLpvDistance));
            vnav.on('gp_distance').withPrecision(0).handle(distance => this.onUpdateLpv(this.currentLpvDeviation, distance));
            vnav.on('gp_approach_mode').whenChanged().handle((mode) => {
                this.currentVnavApproachMode = mode;
                this.updateVNavDisplayMode();
            });
            vnav.on('vnav_path_mode').whenChanged().handle(mode => {
                this.currentVNavPathMode = mode;
                this.updateVNavDisplayMode();
            });
            vnav.on('vnav_tod_distance').atFrequency(1).handle(distance => {
                this.currentVNavTodDistance = distance;
            });
            vnav.on('vnav_bod_distance').atFrequency(1).handle(distance => {
                this.currentVNavBodDistance = distance;
                this.checkIfVnavPathInRange();
            });
            vnav.on('vnav_target_altitude').whenChanged().handle(alt => {
                if (alt > 45000 || alt <= 0) {
                    this.currentVNavTargetAltitude = -1;
                }
                else {
                    this.currentVNavTargetAltitude = alt;
                }
                this.updateVNavDisplayMode();
            });
            vnav.on('vnav_constraint_altitude').whenChanged().handle(alt => {
                if (alt > 45000 || alt <= 0) {
                    this.currentVNavConstraintAltitude = -1;
                }
                else {
                    this.currentVNavConstraintAltitude = alt;
                }
                this.updateVNavDisplayMode();
            });
            vnav.on('vnav_fpa').whenChanged().handle(fpa => {
                this.currentVNavFpa = fpa;
                this.updateVNavDisplayMode();
            });
            vnav.on('vnav_state').whenChanged().handle(state => {
                this.vnavState = state;
                this.updateVNavDisplayMode();
            });
            const fpl = this.bus.getSubscriber();
            fpl.on('fplLegChange').handle((e) => {
                if (e.planIndex === this.fms.flightPlanner.activePlanIndex) {
                    this.onFplChange();
                }
            });
            fpl.on('fplIndexChanged').handle(() => this.onFplChange());
            fpl.on('fplLoaded').handle(() => this.onFplChange());
            this.dmeSourceIndex.sub((v) => {
                const dmeSource = v;
                const dmeDistance = this.navStates[dmeSource].distance;
                if (this.navStates[dmeSource].hasDme && dmeDistance !== null && dmeDistance > 0) {
                    this.dmeDistanceSubject.set(dmeDistance);
                }
                else {
                    this.dmeDistanceSubject.set(-1);
                }
            });
            this.isLnavCalculating.sub((v) => {
                if (!v) {
                    this.onUpdateLnavXtk(0);
                }
                else {
                    this.updateComponentsDisplay(this.navStates[2].source);
                }
            });
        }
        /**
         * A method to check if the VNAV Path is in a displayable range.
         */
        checkIfVnavPathInRange() {
            let vnavPathInRange = false;
            if (this.currentVNavBodDistance > 0
                && this.currentSpeed > 30
                && this.navStates[2].altDeviation !== null
                && this.currentVNavTargetAltitude > 0
                && this.currentVNavConstraintAltitude > 0
                && this.currentVNavConstraintAltitude < this.currentAltitude
                && Math.abs(this.currentVNavFpa) > 0) {
                const todNM = msfssdk.UnitType.METER.convertTo(this.currentVNavTodDistance, msfssdk.UnitType.NMILE);
                const bodNM = msfssdk.UnitType.METER.convertTo(this.currentVNavBodDistance, msfssdk.UnitType.NMILE);
                if (todNM < this.currentSpeed / 60 && bodNM > 0) {
                    vnavPathInRange = true;
                }
            }
            if (vnavPathInRange !== this.vnavPathInRange) {
                this.vnavPathInRange = vnavPathInRange;
                this.updateVNavDisplayMode();
            }
        }
        /**
         * A method to update the VNAV Display Mode Subject.
         */
        updateVNavDisplayMode() {
            var _a;
            const activeSource = this.navStates[this.activeSourceIndex];
            let vnavMode = exports.VNavDisplayMode.NONE;
            let gpMode = exports.GPDisplayMode.NONE;
            if (this.currentVNavPathMode === msfssdk.VNavPathMode.PathActive) {
                vnavMode = exports.VNavDisplayMode.PATH;
                if (activeSource.source.type === msfssdk.NavSourceType.Gps && activeSource.hasGlideslope && !this.missedApproachActive) {
                    gpMode = exports.GPDisplayMode.PREVIEW;
                }
            }
            else if (this.currentVnavApproachMode === msfssdk.ApproachGuidanceMode.GPActive) {
                vnavMode = exports.VNavDisplayMode.NONE;
                gpMode = exports.GPDisplayMode.ACTIVE;
            }
            else if (activeSource.source.type === msfssdk.NavSourceType.Gps) {
                const vtfActive = this.fms.approachDetails.approachIsActive && this.fms.isApproachVtf();
                if (this.vnavPathInRange && this.vnavState !== msfssdk.VNavState.Disabled && !vtfActive) {
                    vnavMode = exports.VNavDisplayMode.PATH;
                }
                if (activeSource.hasGlideslope && !this.missedApproachActive) {
                    switch (this.activeSensitivity) {
                        case exports.NavSensitivity.VIS:
                        case exports.NavSensitivity.LNAVplusV:
                        case exports.NavSensitivity.LPplusV:
                        case exports.NavSensitivity.LPV:
                        case exports.NavSensitivity.LVNAV:
                            gpMode = exports.GPDisplayMode.ACTIVE;
                            break;
                        default:
                            gpMode = exports.GPDisplayMode.PREVIEW;
                    }
                }
            }
            this.vnavDisplayMode.set(vnavMode);
            this.gpDisplayMode.set(gpMode);
            (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateSourceSensitivity();
            this.shouldDisplayPathMode.set(vnavMode === exports.VNavDisplayMode.PATH);
        }
        /**
         * A method called on flight plan changes to set whether lnav has a valid plan.
         */
        onFplChange() {
            const length = this.fms.flightPlanner.hasActiveFlightPlan() ? this.fms.flightPlanner.getActiveFlightPlan().length : 0;
            if (length < 2) {
                this.isLnavCalculating.set(false);
                this.lnavLegType = msfssdk.LegType.Discontinuity;
            }
            else {
                this.isLnavCalculating.set(true);
                const plan = this.fms.flightPlanner.getActiveFlightPlan();
                this.getActiveLegType(plan.activeLateralLeg);
            }
        }
        /**
         * Checks the leg type of the active lateral leg.
         * @param index The Global Leg Index.
         */
        getActiveLegType(index) {
            let legType = msfssdk.LegType.Discontinuity;
            const length = this.fms.flightPlanner.hasActiveFlightPlan() ? this.fms.flightPlanner.getActiveFlightPlan().length : 0;
            if (index > 0 && index < length) {
                const lateralPlan = this.fms.flightPlanner.getActiveFlightPlan();
                const leg = lateralPlan.getLeg(index);
                legType = leg.leg.type;
            }
            this.lnavLegType = legType;
        }
        /**
         * A method called from hsimap when the HSI format is changed.
         * @param hsiMap a bool set to true when the hsiMap should be displayed and false when the rose should be displayed.
         */
        onFormatChange(hsiMap) {
            switch (hsiMap) {
                case true:
                    this.hsiMapActive = true;
                    this.hsiRefs.hsiRose.instance.setVisible(false);
                    this.hsiRefs.hsiMap.instance.setVisible(true);
                    break;
                case false:
                    this.hsiMapActive = false;
                    this.hsiRefs.hsiMap.instance.setVisible(false);
                    this.hsiRefs.hsiRose.instance.setVisible(true);
            }
            this.updateComponentsDisplay();
        }
        /**
         * A method to compare the incoming NavSourceId with the Active Nav Source.
         * @param source The current selected CDI Source.
         * @returns a bool of whether the incoming NavSourceId is the active nav source.
         */
        checkIfActive(source) {
            const type = source.type;
            const index = source.index;
            if (type === this.navStates[this.activeSourceIndex].source.type && index === this.navStates[this.activeSourceIndex].source.index) {
                return true;
            }
            else {
                return false;
            }
        }
        /**
         * A callback called to update the nav sensitivity.
         * @param updatedSource is the source that was updated
         */
        updateSensitivity(updatedSource = undefined) {
            const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
            if (update) {
                switch (this.navStates[this.activeSourceIndex].source.type) {
                    case msfssdk.NavSourceType.Nav:
                        if (this.navStates[this.activeSourceIndex].isLocalizer) {
                            this.activeSensitivity = exports.NavSensitivity.ILS;
                        }
                        else {
                            this.activeSensitivity = exports.NavSensitivity.VOR;
                        }
                        break;
                    case msfssdk.NavSourceType.Gps:
                        this.setGpsSensitivity();
                        break;
                }
                this.updateComponentsDisplay();
            }
        }
        /**
         * Sets the GPS nav sentitivity value.
         */
        setGpsSensitivity() {
            const nav = this.navStates[this.activeSourceIndex];
            let missedApproachActive = false;
            switch (nav.deviationScaleLabel) {
                case exports.CDIScaleLabel.Departure:
                    this.activeSensitivity = exports.NavSensitivity.DPRT;
                    break;
                case exports.CDIScaleLabel.Terminal:
                    this.activeSensitivity = exports.NavSensitivity.TERM;
                    break;
                case exports.CDIScaleLabel.LNav:
                    this.activeSensitivity = exports.NavSensitivity.LNAV;
                    break;
                case exports.CDIScaleLabel.LNavPlusV:
                    this.activeSensitivity = exports.NavSensitivity.LNAVplusV;
                    break;
                case exports.CDIScaleLabel.LNavVNav:
                    this.activeSensitivity = exports.NavSensitivity.LVNAV;
                    break;
                case exports.CDIScaleLabel.LP:
                    this.activeSensitivity = exports.NavSensitivity.LP;
                    break;
                case exports.CDIScaleLabel.LPPlusV:
                    this.activeSensitivity = exports.NavSensitivity.LPplusV;
                    break;
                case exports.CDIScaleLabel.LPV:
                    this.activeSensitivity = exports.NavSensitivity.LPV;
                    break;
                case exports.CDIScaleLabel.Visual:
                    this.activeSensitivity = exports.NavSensitivity.VIS;
                    break;
                case exports.CDIScaleLabel.MissedApproach:
                    this.activeSensitivity = exports.NavSensitivity.MAPR;
                    missedApproachActive = true;
                    break;
                default:
                    this.activeSensitivity = exports.NavSensitivity.ENR;
            }
            if (missedApproachActive !== this.missedApproachActive) {
                this.missedApproachActive = missedApproachActive;
            }
        }
        /**
         * A method called when the bearing or dtk to/from an lnav fix updates to set the to/from flag for GPS.
         * @returns Whether the toFrom value has changed.
         */
        setLnavToFrom() {
            if (this.isLnavCalculating.get()) {
                let toFrom = msfssdk.VorToFrom.TO;
                const dtk = this.navStates[2].dtk_obs;
                const bearing = this.navStates[2].bearing;
                if (bearing !== null && dtk !== null) {
                    if ((this.lnavLegType === msfssdk.LegType.VM || this.lnavLegType === msfssdk.LegType.FM) && Math.abs(msfssdk.NavMath.diffAngle(this.currentHeading, dtk)) > 100) {
                        toFrom = msfssdk.VorToFrom.FROM;
                    }
                    else if (!(this.lnavLegType === msfssdk.LegType.VM || this.lnavLegType === msfssdk.LegType.FM) && Math.abs(msfssdk.NavMath.diffAngle(bearing, dtk)) > 120) {
                        toFrom = msfssdk.VorToFrom.FROM;
                    }
                }
                if (toFrom !== this.navStates[2].toFrom) {
                    this.navStates[2].toFrom = toFrom;
                    return true;
                }
            }
            return false;
        }
        /**
         * A callback called when the LPV data is updated.
         * @param deviation The LPV vertical deviation.
         * @param distance The LPV lateral distance.
         */
        onUpdateLpv(deviation, distance) {
            var _a;
            this.currentLpvDeviation = deviation;
            const hasGlideslope = this.navStates[2].hasGlideslope;
            if (distance !== this.currentLpvDistance) {
                this.currentLpvDistance = distance;
                const approachType = this.fms.approachDetails.approachType;
                if (this.fms.approachDetails.approachIsActive && !this.fms.approachDetails.approachIsCircling && Math.abs(distance) < 30000 &&
                    (approachType === ApproachType.APPROACH_TYPE_GPS || approachType === ApproachType.APPROACH_TYPE_RNAV || approachType === msfssdk.AdditionalApproachType.APPROACH_TYPE_VISUAL)) {
                    if (!hasGlideslope) {
                        this.navStates[2].hasGlideslope = true;
                        this.updateVNavDisplayMode();
                    }
                }
                else if (hasGlideslope) {
                    this.navStates[2].hasGlideslope = false;
                    this.updateVNavDisplayMode();
                }
            }
            else if (distance <= 0 && hasGlideslope) {
                this.navStates[2].hasGlideslope = false;
                this.updateVNavDisplayMode();
            }
            if (isFinite(deviation) && isFinite(distance) && this.navStates[2].hasGlideslope) {
                const scale = Math.tan(msfssdk.UnitType.DEGREE.convertTo(2.0, msfssdk.UnitType.RADIAN)) * distance;
                const scaleClamped = msfssdk.NavMath.clamp(scale, 200, 1000) * -1;
                this.navStates[2].gsDeviation = deviation / scaleClamped;
                (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
            }
        }
        /**
         * A callback called when the VNAV data is updated.
         * @param deviation The vnav vertical deviation.
         */
        onUpdateVnav(deviation) {
            var _a;
            this.navStates[2].altDeviation = deviation / -750;
            (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
        }
        /**
         * A callback called to slew the obs to the ILS inbound course when an loc becomes valid.
         */
        slewObs() {
            const course = this.navStates[this.activeSourceIndex].localizerCourse;
            if (this.activeSourceIndex < 2 && this.navStates[this.activeSourceIndex].isLocalizer &&
                this.navStates[this.activeSourceIndex].hasLocalizer && course !== null) {
                SimVar.SetSimVarValue(`K:VOR${this.activeSourceIndex + 1}_SET`, 'number', Math.round(course));
            }
        }
        /**
         * A method called when xtk/dtk data updates.
         * @param updatedSource is the source that was updated
         */
        updateComponentsData(updatedSource = undefined) {
            const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
            if (update || this.firstRun) {
                if (this.onUpdateDtkBox !== undefined) {
                    this.onUpdateDtkBox();
                }
                if (this.hsiMapActive) {
                    this.courseNeedleRefs.hsiMap.instance.updateData();
                    this.hsiMapDeviationRef.instance.updateData();
                }
                else {
                    this.courseNeedleRefs.hsiRose.instance.updateData();
                }
                if (this.firstRun) {
                    this.firstRun = false;
                }
            }
        }
        /**
         * A method called when any value updates that needs to trigger a component update.
         * @param updatedSource is the source that was updated
         */
        updateComponentsDisplay(updatedSource = undefined) {
            const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
            if (update || this.firstRun) {
                if (this.hsiMapActive) {
                    this.courseNeedleRefs.hsiMap.instance.updateSourceSensitivity();
                    this.hsiMapDeviationRef.instance.updateSourceSensitivity();
                }
                else {
                    this.courseNeedleRefs.hsiRose.instance.updateSourceSensitivity();
                    this.hsiRefs.hsiRose.instance.updateSourceSensitivity();
                }
                this.updateComponentsData(updatedSource);
            }
        }
        /**
         * Utility function to update a given bearing pointer in both the rose and map.
         * @param index The index of the bearing pointer to update.
         * @param func A function to execute on the pointer instances.
         */
        updateBearingPointers(index, func) {
            const elements = [
                index === 0 ? this.hsiRefs.hsiRose.instance.bearingPointer1Element :
                    index === 1 ? this.hsiRefs.hsiRose.instance.bearingPointer2Element : null,
                index === 0 ? this.hsiRefs.hsiMap.instance.bearingPointer1Element :
                    index === 1 ? this.hsiRefs.hsiMap.instance.bearingPointer2Element : null
            ];
            for (const element of elements) {
                func(element);
            }
        }
        /**
         * Get the index in navStates for a given nav source.  This is a bit of a hack to
         * tie together two distinct data models, but it will do the job for now.
         * @param source The NavSourceId of the desired source.
         * @returns The index of that source in navStates or -1 if not found.
         */
        getNavSourceIndex(source) {
            for (let i = 0; i < this.navStates.length; i++) {
                if (this.navStates[i].source.type == source.type && this.navStates[i].source.index == source.index) {
                    return i;
                }
            }
            return -1;
        }
    }

    /**
     * Utility class for working with ICAO region codes in a Garmin context.
     */
    class Regions {
        /**
         * Gets the Garmin display name of the region associated with a specified ICAO region code.
         * @param code - the 2 character ICAO region code.
         * @returns the Garmin display name of the region.
         */
        static getName(code) {
            const name = Regions.NAME_TABLE[code.toUpperCase()];
            return name !== null && name !== void 0 ? name : '';
        }
    }
    Regions.NAME_TABLE = {
        'AG': 'SOLOMON IS',
        'AN': 'NAURU',
        'AY': 'PAPUA N GN',
        'BG': 'GREENLAND',
        'BI': 'ICELAND',
        'BK': 'KOSOVO',
        'CY': 'CANADA',
        'DA': 'ALGERIA',
        'DB': 'BENIN',
        'DF': 'BURKINA',
        'DG': 'GHANA',
        'DI': 'IVRY COAST',
        'DN': 'NIGERIA',
        'DR': 'NIGER',
        'DT': 'TUNISIA',
        'DX': 'TOGO',
        'EB': 'BELGIUM',
        'ED': 'GERMANY',
        'EE': 'ESTONIA',
        'EF': 'FINLAND',
        'EG': 'U KINGDOM',
        'EH': 'NETHERLNDS',
        'EI': 'IRELAND',
        'EK': 'DENMARK',
        'EL': 'LUXEMBOURG',
        'EN': 'NORWAY',
        'EP': 'POLAND',
        'ES': 'SWEDEN',
        'ET': 'GERMANY',
        'EV': 'LATVIA',
        'EY': 'LITHUANIA',
        'FA': 'S AFRICA',
        'FB': 'BOTSWANA',
        'FC': 'CONGO',
        'FD': 'ESWATINI',
        'FE': 'CENTRL AFR',
        'FG': 'EQU GUINEA',
        'FH': 'ASCN/ST HL',
        'FI': 'MAURITIUS',
        'FJ': 'IND OCN TR',
        'FK': 'CAMEROON',
        'FL': 'ZAMBIA',
        'FM': 'MADAGASCAR',
        'FN': 'ANGOLA',
        'FO': 'GABON',
        'FP': 'SAO TOME',
        'FQ': 'MOZAMBIQUE',
        'FS': 'SEYCHELLES',
        'FT': 'CHAD',
        'FV': 'ZIMBABWE',
        'FW': 'MALAWI',
        'FX': 'LESOTHO',
        'FY': 'NAMIBIA',
        'FZ': 'DEM CONGO',
        'GA': 'MALI',
        'GB': 'GAMBIA',
        'GC': 'CANARY IS',
        'GE': 'MELILLA',
        'GF': 'SIER LEONE',
        'GG': 'GUIN-BSSAU',
        'GL': 'LIBERIA',
        'GM': 'MOROCCO',
        'GO': 'SENEGAL',
        'GQ': 'MAURITANIA',
        'GS': 'W SAHARA',
        'GU': 'GUINEA',
        'GV': 'CAPE VERDE',
        'HA': 'ETHIOPIA',
        'HB': 'BURUNDI',
        'HD': 'DJIBOUTI',
        'HE': 'EGYPT',
        'HH': 'ERITREA',
        'HK': 'KENYRA',
        'HL': 'LIBYA',
        'HR': 'RWANDA',
        'HS': 'SUDAN',
        'HT': 'TANZANIA',
        'HU': 'UGANDA',
        'K1': 'NW USA',
        'K2': 'SW USA',
        'K3': 'N CEN USA',
        'K4': 'S CEN USA',
        'K5': 'GR LKS USA',
        'K6': 'NE USA',
        'K7': 'SE USA',
        'LA': 'ALBANIA',
        'LB': 'BULGARIA',
        'LC': 'CYPRUS',
        'LD': 'CROATIA',
        'LE': 'SPAIN',
        'LF': 'FRANCE',
        'LG': 'GREECE',
        'LH': 'HUNGARY',
        'LI': 'ITALY',
        'LJ': 'SLOVENIA',
        'LK': 'CZECH',
        'LL': 'ISRAEL',
        'LM': 'MALTA',
        'LO': 'AUSTRIA',
        'LP': 'PORTUGAL',
        'LQ': 'BOSNIA-HRZ',
        'LR': 'ROMANIA',
        'LS': 'SWITZRLAND',
        'LT': 'TURKEY',
        'LU': 'MOLDOVA',
        'LV': 'PALESTINE',
        'LW': 'MACEDONIA',
        'LX': 'GIBRALTAR',
        'LY': 'SERB/MONTG',
        'LZ': 'SLOVAKIA',
        'MB': 'TURKS/CAIC',
        'MD': 'DOM REPBLC',
        'MG': 'GUATEMALA',
        'MH': 'HONDURAS',
        'MK': 'JAMAICA',
        'MM': 'MEXICO',
        'MN': 'NICARAGUA',
        'MP': 'PANAMA',
        'MR': 'COSTA RICA',
        'MS': 'EL SALVDOR',
        'MT': 'HAITI',
        'MU': 'CUBA',
        'MW': 'CAYMAN IS',
        'MY': 'BAHAMAS',
        'MZ': 'BELIZE',
        'NC': 'COOK IS',
        'NF': 'FIJI/TONGA',
        'NG': 'KIRI/TUVLU',
        'NI': 'NIUE',
        'NL': 'FUTNA/WALS',
        'NS': 'AM/W SAMOA',
        'NT': 'FRNCH POLY',
        'NV': 'VANUATU',
        'NW': 'N CALEDNIA',
        'NZ': 'NEW ZEALND',
        'OA': 'AFGHNISTAN',
        'OB': 'BAHRAIN',
        'OE': 'SAUDI ARAB',
        'OI': 'IRAN',
        'OJ': 'JORDAN',
        'OK': 'KUWAIT',
        'OL': 'LEBANON',
        'OM': 'ARAB EMIRA',
        'OO': 'OMAN',
        'OP': 'PAKISTAN',
        'OR': 'IRAQ',
        'OS': 'SYRIA',
        'OT': 'QATAR',
        'OY': 'YEMEN',
        'PA': 'ALASKA',
        'PG': 'GUAM',
        'PH': 'HAWAII',
        'PJ': 'JOHNSTON ATOLL',
        'PK': 'MARSHLL IS',
        'PL': 'KIRIBATI',
        'PM': 'MIDWAY IS',
        'PO': 'ALASKA',
        'PP': 'ALASKA',
        'PT': 'MICRONESIA',
        'PW': 'WAKE IS',
        'RC': 'TAIWAN',
        'RJ': 'JAPAN',
        'RK': 'S KOREA',
        'RO': 'OKINAWA',
        'RP': 'PHILIPPINS',
        'SA': 'ARGENTINA',
        'SB': 'BRAZIL',
        'SC': 'CHILE',
        'SD': 'BRAZIL',
        'SE': 'EQUADOR',
        'SG': 'PARAGUAY',
        'SI': 'BRAZIL',
        'SJ': 'BRAZIL',
        'SK': 'COLOMBIA',
        'SL': 'BOLIVIA',
        'SM': 'SURINAME',
        'SO': 'FRN GUIANA',
        'SP': 'PERU',
        'SS': 'BRAZIL',
        'SU': 'URUGUAY',
        'SV': 'VENEZUELA',
        'SW': 'BRAZIL',
        'SY': 'GUYANA',
        'TA': 'ANTIGUA',
        'TB': 'BARBADOS',
        'TD': 'ANTIGUA',
        'TF': 'GUAD/MRTNQ',
        'TG': 'GRENADA',
        'TI': 'US VRGN IS',
        'TJ': 'PUERTO RIC',
        'TK': 'ST KTS/NEV',
        'TL': 'ST LUCIA',
        'TN': 'ARUBA',
        'TQ': 'ANGUILLA',
        'TT': 'MONTSERRAT',
        'TU': 'TRIN/TOBAG',
        'TV': 'BR VRGN IS',
        'TX': 'BERMUDA',
        'UA': 'KZKHSTN',
        'UB': 'AZERBAIJAN',
        'UC': 'KYRGYZSTAN',
        'UD': 'ARMENIA',
        'UE': 'RUSSIA',
        'UG': 'GEORGIA',
        'UH': 'RUSSIA',
        'UI': 'RUSSIA',
        'UK': 'UKRAINE',
        'UL': 'RUSSIA',
        'UM': 'RUSS/BELRS',
        'UN': 'RUSSIA',
        'UO': 'RUSSIA',
        'UR': 'RUSS/KZKST',
        'US': 'RUSSIA',
        'UT': 'UZBEK/TADZ',
        'UU': 'RUSSIA',
        'UW': 'RUSSIA',
        'VA': 'INDIA',
        'VC': 'SRI LANKA',
        'VD': 'CAMBODIA',
        'VE': 'INDIA',
        'VG': 'BANGLADESH',
        'VH': 'HONG KONG',
        'VI': 'INDIA',
        'VL': 'LAOS',
        'VM': 'MACAU',
        'VN': 'NEPAL',
        'VO': 'INDIA',
        'VR': 'MALDIVES',
        'VT': 'THAILAND',
        'VV': 'VIETNAM',
        'VY': 'MYANMAR',
        'WA': 'INDONESIA',
        'WB': 'BRUNEI',
        'WI': 'INDONESIA',
        'WM': 'MALAYSIA',
        'WR': 'INDONESIA',
        'WS': 'SINGAPORE',
        'YB': 'AUSTRALIA',
        'YM': 'AUSTRALIA',
        'ZB': 'CHINA',
        'ZG': 'CHINA',
        'ZH': 'CHINA',
        'ZK': 'N KOREA',
        'ZL': 'CHINA',
        'ZM': 'MONGOLIA',
        'ZP': 'CHINA',
        'ZS': 'CHINA',
        'ZU': 'CHINA',
        'ZW': 'CHINA',
        'ZY': 'CHINA',
    };

    /**
     * Controls the target and range of a waypoint map based on a highlighted waypoint.
     */
    class WaypointMapRTRController extends msfssdk.MapSystemController {
        /**
         * Constructor.
         * @param context This controller's map context.
         * @param defaultNoTargetRangeIndex A subscribable which provides the default map range index to apply when
         * not targeting a waypoint, or `null` if no range index should be applied.
         * @param defaultTargetRangeIndex A subscribable which provides the default map range index to apply when
         * targeting a waypoint, or `null` if no range index should be applied.
         * @param supportAirportAutoRange Whether this controller automatically adjusts the map range when an airport is
         * the highlighted waypoint to give an appropriate view of all runways.
         * @param boundsOffset The offset of the boundaries of this controller's enforced display area relative to the
         * boundaries of the map's projected window, *excluding* the dead zone, as `[left, top, right, bottom]` in pixels.
         * Positive offsets are directed toward the center of the map. When this controller selects a map range when
         * targeting an airport, it will attempt to keep all runways within the display area. Defaults to `[0, 0, 0, 0]`.
         * Ignored if `supportAirportAutoRange` is `false`.
         */
        constructor(context, defaultNoTargetRangeIndex, defaultTargetRangeIndex, supportAirportAutoRange, boundsOffset) {
            super(context);
            this.defaultNoTargetRangeIndex = defaultNoTargetRangeIndex;
            this.defaultTargetRangeIndex = defaultTargetRangeIndex;
            this.supportAirportAutoRange = supportAirportAutoRange;
            this.rangeModule = this.context.model.getModule(GarminMapKeys.Range);
            this.waypointHighlightModule = this.context.model.getModule(GarminMapKeys.WaypointHighlight);
            this.targetParams = {
                target: new msfssdk.GeoPoint(0, 0)
            };
            this.targetControl = this.context[msfssdk.MapSystemKeys.TargetControl];
            this.hasTargetControl = msfssdk.Subject.create(this.targetControl === undefined);
            this.targetControlConsumer = {
                priority: MapResourcePriority.WAYPOINT_HIGHLIGHT,
                onAcquired: () => { this.hasTargetControl.set(true); },
                onCeded: () => { this.hasTargetControl.set(false); }
            };
            this.rangeControl = this.context[msfssdk.MapSystemKeys.RangeControl];
            this.hasRangeControl = msfssdk.Subject.create(this.rangeControl === undefined);
            this.rangeControlConsumer = {
                priority: MapResourcePriority.WAYPOINT_HIGHLIGHT,
                onAcquired: () => { this.hasRangeControl.set(true); },
                onCeded: () => { this.hasRangeControl.set(false); }
            };
            this.canTargetWaypoint = msfssdk.MappedSubject.create(([hasTargetControl, hasRangeControl]) => {
                return hasTargetControl && hasRangeControl;
            }, this.hasTargetControl, this.hasRangeControl);
            this.virtualProjection = new msfssdk.MapProjection(100, 100);
            this.bounds = msfssdk.VecNMath.create(4);
            this.boundsOffset = supportAirportAutoRange ? boundsOffset !== null && boundsOffset !== void 0 ? boundsOffset : msfssdk.Subject.create(msfssdk.VecNMath.create(4)) : undefined;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            this.boundsOffsetSub = (_a = this.boundsOffset) === null || _a === void 0 ? void 0 : _a.sub(this.updateBounds.bind(this), true);
            this.canTargetWaypoint.sub((canTarget) => {
                if (canTarget) {
                    this.tryTargetWaypoint(this.waypointHighlightModule.waypoint.get());
                }
            });
            this.waypointSub = this.waypointHighlightModule.waypoint.sub(waypoint => {
                var _a, _b, _c, _d, _e;
                (_a = this.waypointLocationSub) === null || _a === void 0 ? void 0 : _a.destroy();
                this.waypointLocationSub = undefined;
                if (waypoint === null) {
                    (_b = this.targetControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.targetControlConsumer);
                    (_c = this.rangeControl) === null || _c === void 0 ? void 0 : _c.forfeit(this.rangeControlConsumer);
                }
                else {
                    (_d = this.targetControl) === null || _d === void 0 ? void 0 : _d.claim(this.targetControlConsumer);
                    (_e = this.rangeControl) === null || _e === void 0 ? void 0 : _e.claim(this.rangeControlConsumer);
                    this.waypointLocationSub = waypoint.location.sub(() => { this.tryTargetWaypoint(waypoint); });
                }
                this.tryTargetWaypoint(waypoint);
            }, true);
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize) && this.supportAirportAutoRange) {
                this.updateBounds();
            }
        }
        /**
         * Updates the boundaries of this controller's enforced display area.
         */
        updateBounds() {
            const projectedSize = this.context.projection.getProjectedSize();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const offset = this.boundsOffset.get();
            this.bounds[0] = offset[0];
            this.bounds[1] = offset[1];
            this.bounds[2] = projectedSize[0] - offset[2];
            this.bounds[3] = projectedSize[1] - offset[3];
        }
        /**
         * Targets the map to a waypoint.
         * @param waypoint The waypoint to target.
         */
        tryTargetWaypoint(waypoint) {
            if (!this.canTargetWaypoint.get()) {
                return;
            }
            if (waypoint !== null) {
                this.targetParams.target.set(waypoint.location.get());
                this.context.projection.setQueued(this.targetParams);
            }
            this.trySetRangeForWaypoint(waypoint);
        }
        /**
         * Attempts to set the map's range for a specified waypoint.
         * @param waypoint The waypoint for which to set the range.
         */
        trySetRangeForWaypoint(waypoint) {
            if (waypoint === null) {
                if (this.defaultNoTargetRangeIndex !== null) {
                    this.context.getController(GarminMapKeys.Range).setRangeIndex(this.defaultNoTargetRangeIndex.get());
                }
            }
            else {
                let rangeIndex = NaN;
                if (this.supportAirportAutoRange && waypoint instanceof AirportWaypoint) {
                    rangeIndex = this.calculateRangeIndexForAirport(waypoint);
                }
                if (!isNaN(rangeIndex)) {
                    this.context.getController(GarminMapKeys.Range).setRangeIndex(rangeIndex);
                }
                else if (this.defaultTargetRangeIndex !== null) {
                    this.context.getController(GarminMapKeys.Range).setRangeIndex(this.defaultTargetRangeIndex.get());
                }
            }
        }
        /**
         * Calculates the smallest map range index which will keep all runways of an airport in view when the map is
         * targeted to the airport. If the airport has no runways, `NaN` will be returned.
         * @param airport The airport for which to calculate the range index.
         * @returns The smallest map range index which will keep all runways of an airport in view when the map is targeted
         * to the airport, or `NaN` if the airport has no runways.
         */
        calculateRangeIndexForAirport(airport) {
            const runways = airport.facility.get().runways;
            if (runways.length === 0) {
                return NaN;
            }
            this.virtualProjection.set({
                projectedSize: this.context.projection.getProjectedSize(),
                rotation: this.context.projection.getRotation(),
                target: airport.location.get(),
                range: WaypointMapRTRController.NMILE_TO_RADIAN,
                rangeEndpoints: this.context.projection.getRangeEndpoints()
            });
            // Our strategy here is to find the most displaced runway end from the lat/lon of the airport in either the x or
            // y direction, weighted by the distance from the airport lat/lon to the map boundary in that direction. If this
            // point is in bounds, then all other runway ends must be in bounds. Therefore, once we have found this point it
            // will suffice to find the smallest map range at which the point is in bounds.
            const projectedSize = this.virtualProjection.getProjectedSize();
            const targetProjected = this.virtualProjection.getTargetProjected();
            const bounds = this.bounds;
            const negXRef = Math.max(targetProjected[0] - bounds[0], 0);
            const posXRef = Math.max(bounds[2] - targetProjected[0], 0);
            const negYRef = Math.max(targetProjected[1] - bounds[1], 0);
            const posYRef = Math.max(bounds[3] - targetProjected[1], 0);
            const negXBias = negXRef / targetProjected[0];
            const posXBias = posXRef / (projectedSize[0] - targetProjected[0]);
            const negYBias = negYRef / targetProjected[1];
            const posYBias = negXRef / (projectedSize[1] - targetProjected[1]);
            const maxXFactorPoint = WaypointMapRTRController.geoPointCache[0];
            const maxYFactorPoint = WaypointMapRTRController.geoPointCache[1];
            const currentPoint = WaypointMapRTRController.geoPointCache[2];
            let maxXFactor = 0;
            let maxYFactor = 0;
            let maxXBias = 0;
            let maxYBias = 0;
            for (let i = 0; i < runways.length; i++) {
                const runway = runways[i];
                currentPoint.set(runway.latitude, runway.longitude);
                const runwayLengthRad = msfssdk.UnitType.METER.convertTo(runway.length, msfssdk.UnitType.GA_RADIAN);
                currentPoint.offset(runway.direction, -runwayLengthRad / 2);
                const primaryProjected = this.virtualProjection.project(currentPoint, WaypointMapRTRController.vec2Cache[0]);
                const primaryDeltaX = primaryProjected[0] - targetProjected[0];
                const primaryDeltaY = primaryProjected[1] - targetProjected[1];
                const primaryXFactor = primaryDeltaX < 0 ? -primaryDeltaX / negXRef : primaryDeltaX / posXRef;
                const primaryYFactor = primaryDeltaY < 0 ? -primaryDeltaY / negYRef : primaryDeltaY / posYRef;
                if (primaryXFactor > maxXFactor) {
                    maxXFactorPoint.set(currentPoint);
                    maxXFactor = primaryXFactor;
                    maxXBias = primaryDeltaX < 0 ? negXBias : posXBias;
                }
                if (primaryYFactor > maxYFactor) {
                    maxYFactorPoint.set(currentPoint);
                    maxYFactor = primaryYFactor;
                    maxYBias = primaryDeltaY < 0 ? negYBias : posYBias;
                }
                currentPoint.offset(runway.direction, runwayLengthRad / 2);
                const secondaryProjected = this.virtualProjection.project(currentPoint, WaypointMapRTRController.vec2Cache[0]);
                const secondaryDeltaX = secondaryProjected[0] - targetProjected[0];
                const secondaryDeltaY = secondaryProjected[1] - targetProjected[1];
                const secondaryXFactor = secondaryDeltaX < 0 ? -secondaryDeltaX / negXRef : secondaryDeltaX / posXRef;
                const secondaryYFactor = secondaryDeltaY < 0 ? -secondaryDeltaY / negYRef : secondaryDeltaY / posYRef;
                if (secondaryXFactor > maxXFactor) {
                    maxXFactorPoint.set(currentPoint);
                    maxXFactor = secondaryXFactor;
                    maxXBias = secondaryDeltaX < 0 ? negXBias : posXBias;
                }
                if (secondaryYFactor > maxYFactor) {
                    maxYFactorPoint.set(currentPoint);
                    maxYFactor = secondaryYFactor;
                    maxYBias = secondaryDeltaY < 0 ? negYBias : posYBias;
                }
            }
            if (!isFinite(maxXFactor) || !isFinite(maxYFactor) || (maxXFactor === 0 && maxYFactor === 0)) {
                return NaN;
            }
            // We take advantage of the fact that at the scale of airport runways, the Mercator projection has effectively no
            // local distortion, so we can assume a linear relationship between projected distance and spherical distance
            let forecastRangeNM;
            let maxFactorPoint;
            if (maxXFactor > maxYFactor) {
                forecastRangeNM = maxXFactor * maxXBias + (1 - maxXBias);
                maxFactorPoint = maxXFactorPoint;
            }
            else {
                forecastRangeNM = maxYFactor * maxYBias + (1 - maxYBias);
                maxFactorPoint = maxYFactorPoint;
            }
            const ranges = this.rangeModule.nominalRanges.get();
            const forecastRangeIndex = ranges.findIndex(range => range.compare(forecastRangeNM, msfssdk.UnitType.NMILE) >= 0);
            if (forecastRangeIndex < 0) {
                return ranges.length - 1;
            }
            this.virtualProjection.set({ range: ranges[forecastRangeIndex].asUnit(msfssdk.UnitType.GA_RADIAN) });
            // Just in case, we will do one check if the most displaced point is in bounds at our predicted range, and if it
            // isn't, we increment the range index by one.
            if (this.virtualProjection.isInProjectedBounds(maxFactorPoint, bounds)) {
                return forecastRangeIndex;
            }
            else {
                return Math.min(forecastRangeIndex + 1, ranges.length - 1);
            }
        }
        /** @inheritdoc */
        onMapDestroyed() {
            this.destroy();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e;
            super.destroy();
            (_a = this.targetControl) === null || _a === void 0 ? void 0 : _a.forfeit(this.targetControlConsumer);
            (_b = this.rangeControl) === null || _b === void 0 ? void 0 : _b.forfeit(this.rangeControlConsumer);
            (_c = this.waypointSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.waypointLocationSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.boundsOffsetSub) === null || _e === void 0 ? void 0 : _e.destroy();
        }
    }
    WaypointMapRTRController.NMILE_TO_RADIAN = msfssdk.UnitType.NMILE.convertTo(1, msfssdk.UnitType.GA_RADIAN);
    WaypointMapRTRController.vec2Cache = [msfssdk.Vec2Math.create()];
    WaypointMapRTRController.geoPointCache = [new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0), new msfssdk.GeoPoint(0, 0)];

    /**
     * A map layer which displays an altitude intercept arc.
     */
    class MapAltitudeArcLayer extends msfssdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f;
            super(...arguments);
            this.canvasLayerRef = msfssdk.FSComponent.createRef();
            this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
            this.arcHalfAngularWidth = this.arcAngularWidth / 2;
            this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
            this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
            this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
            this.outlineWidth = (_e = this.props.outlineWidth) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
            this.outlineStyle = (_f = this.props.outlineStyle) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
            this.ownAirplanePropsModule = this.props.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
            this.autopilotModule = this.props.model.getModule(msfssdk.MapSystemKeys.AutopilotProps);
            this.altitudeArcModule = this.props.model.getModule(GarminMapKeys.AltitudeArc);
            this.vsPrecisionFpm = ('isSubscribable' in this.props.verticalSpeedPrecision)
                ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map(v => v.asUnit(msfssdk.UnitType.FPM))
                : msfssdk.Subject.create(this.props.verticalSpeedPrecision.asUnit(msfssdk.UnitType.FPM));
            this.vsThresholdFpm = ('isSubscribable' in this.props.verticalSpeedThreshold)
                ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map(v => v.asUnit(msfssdk.UnitType.FPM))
                : msfssdk.Subject.create(this.props.verticalSpeedThreshold.asUnit(msfssdk.UnitType.FPM));
            this.altDevThresholdFeet = ('isSubscribable' in this.props.altitudeDeviationThreshold)
                ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map(v => v.asUnit(msfssdk.UnitType.FOOT))
                : msfssdk.Subject.create(this.props.altitudeDeviationThreshold.asUnit(msfssdk.UnitType.FOOT));
            this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map(vs => vs.asUnit(msfssdk.UnitType.FPM));
            this.vsFpmQuantized = msfssdk.MappedSubject.create(([vsFpm, precision]) => {
                return Math.round(vsFpm / precision) * precision;
            }, this.vsFpm, this.vsPrecisionFpm);
            this.projectedPlanePosition = msfssdk.Vec2Subject.createFromVector(new Float64Array(2));
            this.projectPlanePositionHandler = () => {
                const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
                this.projectedPlanePosition.set(projected);
            };
            this.needUpdate = false;
            this.subscriptions = [];
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.needUpdate = true;
            }
            else {
                (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
            }
        }
        /** @inheritdoc */
        onAttached() {
            this.canvasLayerRef.instance.onAttached();
            this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
            const scheduleUpdate = () => { this.needUpdate = true; };
            this.isArcVisible = msfssdk.MappedSubject.create(([show, vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
                if (!show || Math.abs(vsFpm) < vsThreshold) {
                    return false;
                }
                const altDevFeet = selectedAlt.asUnit(msfssdk.UnitType.FOOT) - alt.asUnit(msfssdk.UnitType.FOOT);
                return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
            }, this.altitudeArcModule.show, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet);
            this.isArcVisible.sub(isVisible => { this.setVisible(isVisible); }, true);
            this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
            this.vsFpmQuantized.sub(scheduleUpdate);
            this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.projectPlanePositionHandler();
            this.needUpdate = true;
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const display = this.canvasLayerRef.instance.display;
            display.clear();
            const track = this.ownAirplanePropsModule.trackTrue.get();
            const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
            const altitude = this.ownAirplanePropsModule.altitude.get();
            const selectedAltitude = this.autopilotModule.selectedAltitude.get();
            const vsFpm = this.vsFpmQuantized.get();
            const timeToAltitudeMinute = (selectedAltitude.asUnit(msfssdk.UnitType.FOOT) - altitude.asUnit(msfssdk.UnitType.FOOT)) / vsFpm;
            const distanceToAltitudeFeet = groundSpeed.asUnit(msfssdk.UnitType.FPM) * timeToAltitudeMinute;
            const distancePx = msfssdk.UnitType.FOOT.convertTo(distanceToAltitudeFeet, msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - Math.PI / 2;
            const projectedPlanePos = this.projectedPlanePosition.get();
            display.context.beginPath();
            const center = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(distancePx - this.arcRadius, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
            const arcStart = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(this.arcRadius, projectedTrackAngle - this.arcHalfAngularWidth, MapAltitudeArcLayer.vec2Cache[1]), center, MapAltitudeArcLayer.vec2Cache[1]);
            display.context.moveTo(arcStart[0], arcStart[1]);
            display.context.arc(center[0], center[1], this.arcRadius, projectedTrackAngle - this.arcHalfAngularWidth, projectedTrackAngle + this.arcHalfAngularWidth);
            display.context.lineWidth = this.strokeWidth + this.outlineWidth * 2;
            display.context.strokeStyle = this.outlineStyle;
            display.context.stroke();
            display.context.lineWidth = this.strokeWidth;
            display.context.strokeStyle = this.strokeStyle;
            display.context.stroke();
            this.needUpdate = false;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.vsPrecisionMap) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.vsThresholdMap) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.altDevThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
            this.vsFpm.destroy();
            (_d = this.isArcVisible) === null || _d === void 0 ? void 0 : _d.destroy();
            this.subscriptions.forEach(sub => sub.destroy());
        }
    }
    MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60; // degrees
    MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64; // px
    MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2; // px
    MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = 'cyan';
    MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
    MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = '#505050';
    MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];

    /**
     * A map layer which displays a crosshair at the projected position of the map target.
     */
    class MapCrosshairLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.crosshairRef = msfssdk.FSComponent.createRef();
            this.needReposition = true;
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onVisibilityChanged(isVisible) {
            this.crosshairRef.getOrDefault() && this.updateFromVisibility();
        }
        /**
         * Updates this layer according to its current visibility.
         */
        updateFromVisibility() {
            this.crosshairRef.instance.style.display = this.isVisible() ? '' : 'none';
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.model.getModule(GarminMapKeys.Crosshair).show.sub(show => { this.setVisible(show); }, true);
            this.updateFromVisibility();
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.needReposition || (this.needReposition = msfssdk.BitFlags.isAny(changeFlags, msfssdk.MapProjectionChangeType.TargetProjected));
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onUpdated(time, elapsed) {
            if (!this.needReposition || !this.isVisible()) {
                return;
            }
            this.repositionCrosshair();
            this.needReposition = false;
        }
        /**
         * Repositions this layer's crosshair.
         */
        repositionCrosshair() {
            const position = this.props.mapProjection.getTargetProjected();
            this.crosshairRef.instance.style.transform = `translate(-50%, -50%) translate3d(${position[0]}px, ${position[1]}px, 0)`;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { ref: this.crosshairRef, class: 'map-crosshair', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate(-50%, -50%) translate3d(0, 0, 0);' },
                msfssdk.FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '50', y1: '0', x2: '50', y2: '100' }),
                msfssdk.FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '0', y1: '50', x2: '100', y2: '50' }),
                msfssdk.FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '50', y1: '0', x2: '50', y2: '100' }),
                msfssdk.FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '0', y1: '50', x2: '100', y2: '50' })));
        }
    }

    /**
     * Render roles for MapWaypointRenderer.
     */
    exports.MapWaypointRenderRole = void 0;
    (function (MapWaypointRenderRole) {
        /** A highlighted waypoint. */
        MapWaypointRenderRole[MapWaypointRenderRole["Highlight"] = 1] = "Highlight";
        /** A waypoint which is the active waypoint in a flight plan. */
        MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanActive"] = 2] = "FlightPlanActive";
        /** A waypoint in a flight plan which is not the active waypoint. */
        MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanInactive"] = 4] = "FlightPlanInactive";
        /** A normally displayed waypoint. */
        MapWaypointRenderRole[MapWaypointRenderRole["Normal"] = 8] = "Normal";
        /** A waypoint in an airway. */
        MapWaypointRenderRole[MapWaypointRenderRole["Airway"] = 16] = "Airway";
        /** A VNAV waypoint. */
        MapWaypointRenderRole[MapWaypointRenderRole["VNav"] = 32] = "VNav";
        /** A waypoint in a procedure preview plan. */
        MapWaypointRenderRole[MapWaypointRenderRole["ProcedurePreview"] = 64] = "ProcedurePreview";
        /** A waypoint in a procedure transition preview plan. */
        MapWaypointRenderRole[MapWaypointRenderRole["ProcedureTransitionPreview"] = 128] = "ProcedureTransitionPreview";
    })(exports.MapWaypointRenderRole || (exports.MapWaypointRenderRole = {}));
    /**
     * A renderer which draws waypoints to a Garmin-style map.
     */
    class MapWaypointRenderer extends msfssdk.MapWaypointRenderer {
        /**
         * Constructor.
         * @param textManager The text manager to use for waypoint labels.
         */
        constructor(textManager) {
            super(textManager);
            this.addRenderRole(exports.MapWaypointRenderRole.Highlight);
            this.addRenderRole(exports.MapWaypointRenderRole.FlightPlanActive);
            this.addRenderRole(exports.MapWaypointRenderRole.FlightPlanInactive);
            this.addRenderRole(exports.MapWaypointRenderRole.ProcedurePreview);
            this.addRenderRole(exports.MapWaypointRenderRole.ProcedureTransitionPreview);
            this.addRenderRole(exports.MapWaypointRenderRole.Normal);
            this.addRenderRole(exports.MapWaypointRenderRole.Airway);
            this.addRenderRole(exports.MapWaypointRenderRole.VNav);
        }
    }

    /**
     * A map layer which displays a flight plan.
     */
    class MapFlightPlanLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.flightPathLayerRef = msfssdk.FSComponent.createRef();
            this.resampler = new msfssdk.GeoCircleResampler(Math.PI / 12, 0.25, 8);
            this.facLoader = new msfssdk.FacilityLoader(msfssdk.FacilityRepository.getRepository(this.props.bus));
            this.facWaypointCache = GarminFacilityWaypointCache.getCache(this.props.bus);
            this.waypointRecordManager = new MapFlightPlanWaypointRecordManager(this.facLoader, this.facWaypointCache, this.props.waypointRenderer, exports.MapWaypointRenderRole.FlightPlanInactive, exports.MapWaypointRenderRole.FlightPlanActive);
            this.clipBoundsSub = msfssdk.VecNSubject.createFromVector(new Float64Array(4));
            this.clippedPathStream = new msfssdk.ClippedPathStream(msfssdk.NullPathStream.INSTANCE, this.clipBoundsSub);
            this.pathStreamStack = new msfssdk.GeoProjectionPathStreamStack(msfssdk.NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), this.resampler);
            this.isObsActive = false;
            this.obsCourse = 0;
            this.needDrawRoute = false;
            this.needRefreshWaypoints = false;
            this.needRepickWaypoints = false;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.flightPathLayerRef.instance.onAttached();
            this.pathStreamStack.pushPostProjected(this.clippedPathStream);
            this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
            this.initFlightPlanHandlers();
            this.onTodBodChanged();
        }
        /**
         * Initializes handlers to respond to flight plan events.
         */
        initFlightPlanHandlers() {
            this.props.drawEntirePlan.sub(() => { this.scheduleUpdates(true, true, true); });
            this.props.dataProvider.plan.sub(() => { this.scheduleUpdates(true, true, true); }, true);
            this.props.dataProvider.planModified.on(() => { this.scheduleUpdates(false, true, true); });
            this.props.dataProvider.planCalculated.on(() => {
                this.scheduleUpdates(true, true, false);
                this.onTodBodChanged();
            });
            this.props.dataProvider.activeLateralLegIndex.sub(() => { this.scheduleUpdates(true, true, true); });
            this.props.dataProvider.lnavData.sub(() => { this.scheduleUpdates(true, false, false); });
            this.props.dataProvider.vnavState.sub(() => { this.onTodBodChanged(); });
            this.props.dataProvider.vnavPathMode.sub(() => { this.onTodBodChanged(); });
            this.props.dataProvider.vnavTodLegIndex.sub(() => { this.onTodBodChanged(); });
            this.props.dataProvider.vnavBodLegIndex.sub(() => { this.onTodBodChanged(); });
            this.props.dataProvider.vnavTodLegDistance.sub(() => { this.todWaypoint && this.onTodBodChanged(); });
            this.props.dataProvider.vnavDistanceToTod.sub(distance => {
                const comparison = distance.compare(MapFlightPlanLayer.TOD_DISTANCE_THRESHOLD);
                if ((comparison < 0 && this.todWaypoint) || (comparison >= 0 && !this.todWaypoint)) {
                    this.onTodBodChanged();
                }
            });
            this.props.dataProvider.obsCourse.sub((course) => {
                const isActive = course !== undefined;
                const needFullUpdate = isActive !== this.isObsActive;
                this.isObsActive = isActive;
                this.obsCourse = course !== null && course !== void 0 ? course : this.obsCourse;
                this.scheduleUpdates(needFullUpdate || this.isObsActive, needFullUpdate, needFullUpdate);
            });
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.updateClipBounds();
        }
        /**
         * Updates this layer's canvas clipping bounds.
         */
        updateClipBounds() {
            const size = this.flightPathLayerRef.instance.getSize();
            this.clipBoundsSub.set(-MapFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapFlightPlanLayer.CLIP_BOUNDS_BUFFER);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            this.flightPathLayerRef.instance.onUpdated(time, elapsed);
            this.updateFromFlightPathLayerInvalidation();
            this.updateRedrawRoute();
            this.updateRefreshWaypoints();
        }
        /**
         * Checks if the flight path layer's display canvas has been invalidated, and if so, clears it and schedules a redraw.
         */
        updateFromFlightPathLayerInvalidation() {
            const display = this.flightPathLayerRef.instance.display;
            this.needDrawRoute || (this.needDrawRoute = display.isInvalid);
            if (display.isInvalid) {
                display.clear();
                display.syncWithMapProjection(this.props.mapProjection);
            }
        }
        /**
         * Redraws the flight path if a redraw is scheduled.
         */
        updateRedrawRoute() {
            if (this.needDrawRoute) {
                this.drawRoute();
                this.needDrawRoute = false;
            }
        }
        /**
         * Draws the flight path route.
         */
        drawRoute() {
            const display = this.flightPathLayerRef.instance.display;
            const context = display.context;
            display.clear();
            const plan = this.props.dataProvider.plan.get();
            if (plan) {
                this.pathStreamStack.setProjection(display.geoProjection);
                this.props.pathRenderer.render(plan, context, this.pathStreamStack, this.props.drawEntirePlan.get(), this.props.dataProvider.activeLateralLegIndex.get(), this.props.dataProvider.lnavData.get(), this.isObsActive ? this.obsCourse : undefined);
            }
        }
        /**
         * Refreshes this layer's flight plan leg waypoint records if a refresh is scheduled.
         */
        updateRefreshWaypoints() {
            if (this.needRefreshWaypoints && !this.waypointRecordManager.isBusy()) {
                const plan = this.props.dataProvider.plan.get();
                const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
                const startIndex = plan ? this.getPickWaypointsStartIndex(plan, activeLegIndex, this.props.drawEntirePlan.get(), this.isObsActive) : undefined;
                this.waypointRecordManager.refreshWaypoints(plan, activeLegIndex, this.needRepickWaypoints, startIndex);
                this.needRefreshWaypoints = false;
                this.needRepickWaypoints = false;
            }
        }
        /**
         * Gets the global index of the first leg in a flight plan for which to display waypoints.
         * @param plan A flight plan.
         * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
         * @param drawEntirePlan Whether to display the entire flight plan.
         * @param isObsActive Whether OBS is active.
         * @returns The global index of the first leg in a flight plan for which to display waypoints.
         */
        getPickWaypointsStartIndex(plan, activeLegIndex, drawEntirePlan, isObsActive) {
            if (drawEntirePlan) {
                return 0;
            }
            if (activeLegIndex < 0) {
                return plan.length;
            }
            if (isObsActive) {
                return activeLegIndex;
            }
            return Math.max(0, this.getActiveFromLegIndex(plan, activeLegIndex) - 1);
        }
        /**
         * Gets the global leg index of the leg from which the active leg of a flight plan originates.
         * @param plan A flight plan.
         * @param activeLegIndex The global leg index of the active leg.
         * @returns The global leg index of the leg from which the active leg originates, or -1 if one could not be found.
         */
        getActiveFromLegIndex(plan, activeLegIndex) {
            const activeLeg = plan.tryGetLeg(activeLegIndex);
            if (!activeLeg) {
                return -1;
            }
            const segmentIndex = plan.getSegmentIndex(activeLegIndex);
            const segmentLegIndex = activeLegIndex - plan.getSegment(segmentIndex).offset;
            return FmsUtils.getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex);
        }
        /**
         * Schedules flight plan drawing updates.
         * @param scheduleRedrawRoute Whether to schedule a redraw of the flight path.
         * @param scheduleRefreshWaypoints Whether to schedule a refresh of waypoints records.
         * @param scheduleRepickWaypoints Whether to schedule a repick of waypoints records.
         */
        scheduleUpdates(scheduleRedrawRoute, scheduleRefreshWaypoints, scheduleRepickWaypoints) {
            this.needDrawRoute || (this.needDrawRoute = scheduleRedrawRoute);
            this.needRefreshWaypoints || (this.needRefreshWaypoints = scheduleRefreshWaypoints);
            this.needRepickWaypoints || (this.needRepickWaypoints = scheduleRepickWaypoints);
        }
        /**
         * Recreates the TOD and BOD leg indexes when any values change.
         */
        onTodBodChanged() {
            this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, exports.MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, exports.MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.todWaypoint = undefined;
            this.bodWaypoint = undefined;
            const plan = this.props.dataProvider.plan.get();
            if (!plan || plan.segmentCount < 1 || plan.getSegment(0).segmentType === msfssdk.FlightPlanSegmentType.RandomDirectTo) {
                return;
            }
            const vnavState = this.props.dataProvider.vnavState.get();
            if (vnavState === msfssdk.VNavState.Disabled) {
                return;
            }
            const vnavPathMode = this.props.dataProvider.vnavPathMode.get();
            const todLegIndex = this.props.dataProvider.vnavTodLegIndex.get();
            const bodLegIndex = this.props.dataProvider.vnavBodLegIndex.get();
            const todLegEndDistance = this.props.dataProvider.vnavTodLegDistance.get();
            const distanceToTod = this.props.dataProvider.vnavDistanceToTod.get();
            if (todLegIndex >= 0 && distanceToTod.compare(MapFlightPlanLayer.TOD_DISTANCE_THRESHOLD) >= 0 && vnavPathMode !== msfssdk.VNavPathMode.PathActive) {
                if (isFinite(todLegEndDistance.number) && plan.length > 0) {
                    try {
                        const leg = plan.getLeg(todLegIndex);
                        this.todWaypoint = new msfssdk.VNavWaypoint(leg, todLegEndDistance.asUnit(msfssdk.UnitType.METER), 'tod');
                        this.props.waypointRenderer.register(this.todWaypoint, exports.MapWaypointRenderRole.VNav, 'flightplan-layer');
                    }
                    catch (_a) {
                        console.warn(`Invalid tod leg at: ${todLegIndex}`);
                    }
                }
                else if (!isFinite(todLegEndDistance.number)) {
                    console.warn(`Invalid TOD leg end distance: ${todLegEndDistance}`);
                }
            }
            else if (bodLegIndex >= 0) {
                try {
                    const leg = plan.getLeg(bodLegIndex);
                    this.bodWaypoint = new msfssdk.VNavWaypoint(leg, 0, 'bod');
                    this.props.waypointRenderer.register(this.bodWaypoint, exports.MapWaypointRenderRole.VNav, 'flightplan-layer');
                }
                catch (_b) {
                    console.warn(`Invalid bod leg at: ${bodLegIndex}`);
                }
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
                msfssdk.FSComponent.buildComponent(msfssdk.MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 })));
        }
    }
    MapFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10; // number of pixels from edge of canvas to extend the clipping bounds, in pixels
    MapFlightPlanLayer.TOD_DISTANCE_THRESHOLD = msfssdk.UnitType.METER.createNumber(100); // minimum distance from TOD for which to display TOD waypoint

    /**
     * The map layer showing a rotating compass arrow pointing to true north.
     */
    class MapMiniCompassLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
            this.imgRef = msfssdk.FSComponent.createRef();
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            const root = this.rootRef.getOrDefault();
            if (root !== null) {
                root.style.display = isVisible ? '' : 'none';
            }
        }
        /** @inheritdoc */
        onAttached() {
            this.needUpdate = true;
            this.onVisibilityChanged(this.isVisible());
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.needUpdate = msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.Rotation);
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            this.updateRotation();
            this.needUpdate = false;
        }
        /**
         * Updates the rotation of the arrow.
         */
        updateRotation() {
            const rotation = this.props.mapProjection.getRotation();
            this.imgRef.instance.style.transform = `rotate3d(0,0,1,${rotation}rad)`;
        }
        /** @inheritdoc */
        render() {
            var _a;
            let cssClass;
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(cssClass = msfssdk.SetSubject.create(['map-minicompass']), this.props.class, ['map-minicompass']);
            }
            else {
                cssClass = `map-minicompass ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
            }
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, class: cssClass, style: 'position: relative; width: var(--minicompass-size, 4em); height: var(--minicompass-size, 4em);' },
                msfssdk.FSComponent.buildComponent("img", { ref: this.imgRef, src: this.props.imgSrc, style: 'width: 100%; height: 100%;' }),
                msfssdk.FSComponent.buildComponent("div", { style: 'position: absolute; top: 50%; width: 100%; transform: translateY(-50%); text-align: center; color: black;' }, "N")));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Map pointer information box size.
     */
    exports.MapPointerInfoLayerSize = void 0;
    (function (MapPointerInfoLayerSize) {
        MapPointerInfoLayerSize[MapPointerInfoLayerSize["Full"] = 0] = "Full";
        MapPointerInfoLayerSize[MapPointerInfoLayerSize["Medium"] = 1] = "Medium";
        MapPointerInfoLayerSize[MapPointerInfoLayerSize["Small"] = 2] = "Small";
    })(exports.MapPointerInfoLayerSize || (exports.MapPointerInfoLayerSize = {}));
    /**
     * A map layer which displays a pointer information box.
     */
    class MapPointerInfoLayer extends msfssdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f;
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
            this.ownAirplanePropsModule = this.props.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
            this.pointerModule = this.props.model.getModule(GarminMapKeys.Pointer);
            this.unitsModule = this.props.model.getModule(GarminMapKeys.Units);
            this.distanceLargeUnits = (_b = (_a = this.unitsModule) === null || _a === void 0 ? void 0 : _a.distanceLarge) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            this.distanceSmallUnits = (_d = (_c = this.unitsModule) === null || _c === void 0 ? void 0 : _c.distanceSmall) !== null && _d !== void 0 ? _d : msfssdk.Subject.create(msfssdk.UnitType.FOOT);
            this.navAngleUnits = (_f = (_e = this.unitsModule) === null || _e === void 0 ? void 0 : _e.navAngle) !== null && _f !== void 0 ? _f : msfssdk.Subject.create(msfssdk.NavAngleUnit.create(true));
            this.distance = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(NaN));
            this.distanceUnit = msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            this.bearing = msfssdk.NavAngleSubject.createFromNavAngle(new msfssdk.NavAngleUnit(msfssdk.NavAngleUnitReferenceNorth.True, 0, 0).createNumber(NaN));
            this.latLon = msfssdk.GeoPointSubject.createFromGeoPoint(new msfssdk.GeoPoint(0, 0));
            this.scheduleUpdateHandler = () => { this.needUpdate = true; };
            this.needUpdate = false;
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onVisibilityChanged(isVisible) {
            this.rootRef.getOrDefault() && this.updateFromVisibility();
        }
        /**
         * Updates this layer according to its current visibility.
         */
        updateFromVisibility() {
            if (this.isVisible()) {
                this.rootRef.instance.style.display = '';
                this.ownAirplanePropsModule.position.sub(this.scheduleUpdateHandler);
                this.pointerModule.position.sub(this.scheduleUpdateHandler, true);
            }
            else {
                this.rootRef.instance.style.display = 'none';
                this.ownAirplanePropsModule.position.unsub(this.scheduleUpdateHandler);
                this.pointerModule.position.unsub(this.scheduleUpdateHandler);
            }
        }
        /** @inheritdoc */
        onAfterRender() {
            this.updateFromVisibility();
            this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
            this.distanceLargeUnits.sub(this.updateDistanceUnit.bind(this));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.needUpdate || (this.needUpdate = this.isVisible() && msfssdk.BitFlags.isAny(changeFlags, msfssdk.MapProjectionChangeType.Center | msfssdk.MapProjectionChangeType.Rotation | msfssdk.MapProjectionChangeType.ProjectedResolution));
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onUpdated(time, elapsed) {
            if (!this.needUpdate) {
                return;
            }
            this.updateInfo();
            this.needUpdate = false;
        }
        /**
         * Updates this layer's displayed information.
         */
        updateInfo() {
            const latLon = this.props.mapProjection.invert(this.pointerModule.position.get(), MapPointerInfoLayer.geoPointCache[0]);
            this.latLon.set(latLon);
            const airplanePos = this.ownAirplanePropsModule.position.get();
            this.distance.set(airplanePos.distance(latLon), msfssdk.UnitType.GA_RADIAN);
            this.updateDistanceUnit();
            this.bearing.set(airplanePos.bearingTo(latLon), airplanePos.lat, airplanePos.lon);
        }
        /**
         * Updates the displayed distance unit type.
         */
        updateDistanceUnit() {
            const distance = this.distance.get();
            if (!distance.isNaN() && distance.asUnit(this.distanceLargeUnits.get()) < 0.1) {
                this.distanceUnit.set(this.distanceSmallUnits.get());
            }
            else {
                this.distanceUnit.set(this.distanceLargeUnits.get());
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-pointerinfolayer-box' },
                msfssdk.FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-dis' },
                    msfssdk.FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title', style: this.props.size === exports.MapPointerInfoLayerSize.Small ? 'display: none;' : '' }, "DIS"),
                    msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.distance, displayUnit: this.distanceUnit, formatter: msfssdk.NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: 'map-pointerinfolayer-box-title-value' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-brg', style: this.props.size === exports.MapPointerInfoLayerSize.Small ? 'display: none;' : '' },
                    msfssdk.FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title' }, "BRG"),
                    msfssdk.FSComponent.buildComponent(BearingDisplay, { value: this.bearing, displayUnit: this.navAngleUnits, formatter: msfssdk.NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: 'map-pointerinfolayer-box-title-value' })),
                this.props.size === exports.MapPointerInfoLayerSize.Full
                    ? msfssdk.FSComponent.buildComponent(msfssdk.LatLonDisplay, { location: this.latLon, class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-title-value' })
                    : null));
        }
    }
    MapPointerInfoLayer.geoPointCache = [new msfssdk.GeoPoint(0, 0)];

    /**
     * A map layer which displays a pointer.
     */
    class MapPointerLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.pointerRef = msfssdk.FSComponent.createRef();
            this.pointerModule = this.props.model.getModule(GarminMapKeys.Pointer);
            this.needRepositionPointer = false;
        }
        /** @inheritdoc */
        onVisibilityChanged() {
            this.pointerRef.getOrDefault() && this.updateFromVisibility();
        }
        /**
         * Updates this layer according to its current visibility.
         */
        updateFromVisibility() {
            var _a, _b;
            const isVisible = this.isVisible();
            this.pointerRef.instance.style.display = isVisible ? '' : 'none';
            if (isVisible) {
                (_a = this.positionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            }
            else {
                (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
        }
        /** @inheritdoc */
        onAttached() {
            this.positionSub = this.pointerModule.position.sub(() => { this.needRepositionPointer = true; }, false, true);
            this.updateFromVisibility();
            this.isActiveSub = this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needRepositionPointer) {
                return;
            }
            this.repositionPointer();
            this.needRepositionPointer = false;
        }
        /**
         * Repositions this layer's pointer.
         */
        repositionPointer() {
            const position = this.pointerModule.position.get();
            this.pointerRef.instance.style.transform = `translate3d(${position[0]}px, ${position[1]}px, 0)`;
        }
        /** @inheritdoc */
        render() {
            var _a, _b;
            return ((_b = (_a = this.props.children) === null || _a === void 0 ? void 0 : _a.some(child => child !== undefined)) !== null && _b !== void 0 ? _b : false) ? this.renderCustom() : this.renderDefault();
        }
        /**
         * Renders the default pointer icon.
         * @returns The default pointer icon, as a VNode.
         */
        renderDefault() {
            return (msfssdk.FSComponent.buildComponent("svg", { ref: this.pointerRef, class: 'map-pointer', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate3d(0, 0, 0);' },
                msfssdk.FSComponent.buildComponent("polygon", { points: '78.93 95.46 49.48 66.01 41.18 84.57 4.54 4.54 84.57 41.18 66.01 49.48 95.46 78.93 78.93 95.46' })));
        }
        /**
         * Renders a custom pointer icon.
         * @returns The custom pointer icon, as a VNode.
         */
        renderCustom() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.pointerRef, style: 'position: absolute; left: 0; top: 0; transform: translate3d(0, 0, 0);', class: 'map-pointer' }, this.props.children));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.positionSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.isActiveSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * A map layer which displays a procedure preview.
     */
    class MapProcedurePreviewLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.flightPathLayerRef = msfssdk.FSComponent.createRef();
            this.waypointLayerRef = msfssdk.FSComponent.createRef();
            this.procPreviewModule = this.props.model.getModule(GarminMapKeys.ProcedurePreview);
            this.resampler = new msfssdk.GeoCircleResampler(Math.PI / 12, 0.25, 8);
            this.facLoader = new msfssdk.FacilityLoader(msfssdk.FacilityRepository.getRepository(this.props.bus));
            this.waypointCache = GarminFacilityWaypointCache.getCache(this.props.bus);
            this.clipBoundsSub = msfssdk.VecNSubject.createFromVector(new Float64Array(4));
            this.clippedPathStream = new msfssdk.ClippedPathStream(msfssdk.NullPathStream.INSTANCE, this.clipBoundsSub);
            this.pathStreamStack = new msfssdk.GeoProjectionPathStreamStack(msfssdk.NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), this.resampler);
            this.procedureWaypointRecordManager = new MapFlightPlanWaypointRecordManager(this.facLoader, this.waypointCache, this.props.waypointRenderer, exports.MapWaypointRenderRole.ProcedurePreview, exports.MapWaypointRenderRole.ProcedurePreview);
            this.transitionWaypointRecordManager = new ProcMapTransitionWaypointRecordManager(this.facLoader, this.waypointCache, this.props.waypointRenderer, exports.MapWaypointRenderRole.ProcedureTransitionPreview);
            this.needDrawRoute = false;
            this.needRefreshProcedureWaypoints = false;
            this.needRepickProcedureWaypoints = false;
            this.needRefreshTransitionWaypoints = false;
            this.needRepickTransitionWaypoints = false;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.flightPathLayerRef.instance.onAttached();
            this.waypointLayerRef.instance.onAttached();
            this.pathStreamStack.pushPostProjected(this.clippedPathStream);
            this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
            this.initWaypointRenderer();
            this.initFlightPlanHandlers();
        }
        /**
         * Initializes the waypoint renderer.
         */
        initWaypointRenderer() {
            this.props.waypointRenderer.setCanvasContext(exports.MapWaypointRenderRole.ProcedureTransitionPreview, this.waypointLayerRef.instance.display.context);
            this.props.waypointRenderer.setCanvasContext(exports.MapWaypointRenderRole.ProcedurePreview, this.waypointLayerRef.instance.display.context);
        }
        /**
         * Initializes handlers to respond to flight plan events.
         */
        initFlightPlanHandlers() {
            this.procPreviewModule.procedurePlan.sub(() => { this.scheduleUpdates(true, true, true, false, false); }, true);
            this.procPreviewModule.transitionPlan.sub(() => { this.scheduleUpdates(true, false, false, true, true); }, true);
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.updateClipBounds();
        }
        /**
         * Updates this layer's canvas clipping bounds.
         */
        updateClipBounds() {
            const size = this.flightPathLayerRef.instance.getSize();
            this.clipBoundsSub.set(-MapProcedurePreviewLayer.CLIP_BOUNDS_BUFFER, -MapProcedurePreviewLayer.CLIP_BOUNDS_BUFFER, size + MapProcedurePreviewLayer.CLIP_BOUNDS_BUFFER, size + MapProcedurePreviewLayer.CLIP_BOUNDS_BUFFER);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            this.flightPathLayerRef.instance.onUpdated(time, elapsed);
            this.updateFromFlightPathLayerInvalidation();
            this.updateRedrawRoute();
            this.updateRefreshWaypoints();
        }
        /**
         * Checks if the flight path layer's display canvas has been invalidated, and if so, clears it and schedules a redraw.
         */
        updateFromFlightPathLayerInvalidation() {
            const display = this.flightPathLayerRef.instance.display;
            this.needDrawRoute || (this.needDrawRoute = display.isInvalid);
            if (display.isInvalid) {
                display.clear();
                display.syncWithMapProjection(this.props.mapProjection);
            }
        }
        /**
         * Redraws the flight path if a redraw is scheduled.
         */
        updateRedrawRoute() {
            if (this.needDrawRoute) {
                this.drawRoute();
                this.needDrawRoute = false;
            }
        }
        /**
         * Draws the flight path route.
         */
        drawRoute() {
            const display = this.flightPathLayerRef.instance.display;
            const context = display.context;
            display.clear();
            const procedurePlan = this.procPreviewModule.procedurePlan.get();
            const transitionPlan = this.procPreviewModule.transitionPlan.get();
            this.pathStreamStack.setProjection(display.geoProjection);
            if (transitionPlan) {
                this.props.pathRenderer.render(transitionPlan, context, this.pathStreamStack, true);
            }
            if (procedurePlan) {
                this.props.pathRenderer.render(procedurePlan, context, this.pathStreamStack, false);
            }
        }
        /**
         * Refreshes this layer's flight plan leg waypoint records if a refresh is scheduled.
         */
        updateRefreshWaypoints() {
            if (this.needRefreshProcedureWaypoints && !this.procedureWaypointRecordManager.isBusy()) {
                const plan = this.procPreviewModule.procedurePlan.get();
                this.procedureWaypointRecordManager.refreshWaypoints(plan, -1, this.needRepickProcedureWaypoints);
                this.needRefreshProcedureWaypoints = false;
                this.needRepickProcedureWaypoints = false;
            }
            if (this.needRefreshTransitionWaypoints && !this.transitionWaypointRecordManager.isBusy()) {
                const plan = this.procPreviewModule.transitionPlan.get();
                const pickPosition = this.procPreviewModule.procedureType.get() === exports.ProcedureType.DEPARTURE ? 'last' : 'first';
                this.transitionWaypointRecordManager.refreshWaypoints(plan, this.needRepickTransitionWaypoints, pickPosition);
                this.needRefreshTransitionWaypoints = false;
                this.needRepickTransitionWaypoints = false;
            }
        }
        /**
         * Schedules flight plan drawing updates.
         * @param scheduleRedrawRoute Whether to schedule a redraw of the flight path.
         * @param scheduleRefreshProcedureWaypoints Whether to schedule a refresh of procedure waypoint records.
         * @param scheduleRepickProcedureWaypoints Whether to schedule a repick of procedure waypoint records.
         * @param scheduleRefreshTransitionWaypoints Whether to schedule a refresh of transition waypoint records.
         * @param scheduleRepickTransitionWaypoints Whether to schedule a repick of transition waypoint records.
         */
        scheduleUpdates(scheduleRedrawRoute, scheduleRefreshProcedureWaypoints, scheduleRepickProcedureWaypoints, scheduleRefreshTransitionWaypoints, scheduleRepickTransitionWaypoints) {
            this.needDrawRoute || (this.needDrawRoute = scheduleRedrawRoute);
            this.needRefreshProcedureWaypoints || (this.needRefreshProcedureWaypoints = scheduleRefreshProcedureWaypoints);
            this.needRepickProcedureWaypoints || (this.needRepickProcedureWaypoints = scheduleRepickProcedureWaypoints);
            this.needRefreshTransitionWaypoints || (this.needRefreshTransitionWaypoints = scheduleRefreshTransitionWaypoints);
            this.needRepickTransitionWaypoints || (this.needRepickTransitionWaypoints = scheduleRepickTransitionWaypoints);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.FSComponent.Fragment, null,
                msfssdk.FSComponent.buildComponent(msfssdk.MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }),
                msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
        }
    }
    MapProcedurePreviewLayer.CLIP_BOUNDS_BUFFER = 10; // number of pixels from edge of canvas to extend the clipping bounds, in pixels

    /**
     * The map layer showing the range display.
     */
    class MapRangeDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.displayUnitSub = msfssdk.Subject.create(null);
            this.autoSubject = msfssdk.Subject.create('false');
            this.autoOverrideSubject = msfssdk.Subject.create('false');
            this.displayUnitHandler = this.updateDisplayUnit.bind(this);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.range.sub(this.displayUnitHandler);
            this.props.displayUnit.sub(this.displayUnitHandler, true);
        }
        /**
         * Updates this component's display unit.
         */
        updateDisplayUnit() {
            const nominalDisplayUnit = this.props.displayUnit.get();
            const range = this.props.range.get();
            let displayUnit;
            if (nominalDisplayUnit && nominalDisplayUnit.equals(msfssdk.UnitType.NMILE)) {
                if (range.asUnit(msfssdk.UnitType.FOOT) <= 2501) {
                    displayUnit = msfssdk.UnitType.FOOT;
                }
                else {
                    displayUnit = msfssdk.UnitType.NMILE;
                }
            }
            else if (nominalDisplayUnit && nominalDisplayUnit.equals(msfssdk.UnitType.KILOMETER)) {
                if (range.asUnit(msfssdk.UnitType.METER) < 999) {
                    displayUnit = msfssdk.UnitType.METER;
                }
                else {
                    displayUnit = msfssdk.UnitType.KILOMETER;
                }
            }
            else {
                displayUnit = nominalDisplayUnit;
            }
            this.displayUnitSub.set(displayUnit);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: `map-range-display${this.props.class ? ` ${this.props.class}` : ''}`, auto: this.autoSubject, "auto-override": this.autoOverrideSubject, style: 'display: flex; flex-flow: column nowrap; align-items: center;' },
                msfssdk.FSComponent.buildComponent("div", { class: 'map-range-display-auto', style: 'display: none;' }, "AUTO"),
                msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.props.range, displayUnit: this.displayUnitSub, formatter: msfssdk.NumberFormatter.create({ precision: 0.01, forceDecimalZeroes: false, maxDigits: 3 }) })));
        }
    }

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * A map layer which draws a range compass in front of the map target.
     */
    class MapRangeCompassLayer extends msfssdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
            this.arcLayerRef = msfssdk.FSComponent.createRef();
            this.roseLayerContainerRef = msfssdk.FSComponent.createRef();
            this.roseLayerRef = msfssdk.FSComponent.createRef();
            this.referenceMarkerContainerRef = msfssdk.FSComponent.createRef();
            this.roseLabelsLayerRef = msfssdk.FSComponent.createRef();
            this.headingIndicatorRef = msfssdk.FSComponent.createRef();
            this.rangeDisplayContainerRef = msfssdk.FSComponent.createRef();
            this.arcStrokeWidth = (_a = this.props.arcStrokeWidth) !== null && _a !== void 0 ? _a : MapRangeCompassLayer.DEFAULT_ARC_STROKE_WIDTH;
            this.arcStrokeColor = (_b = this.props.arcStrokeColor) !== null && _b !== void 0 ? _b : MapRangeCompassLayer.DEFAULT_ARC_STROKE_COLOR;
            this.arcEndTickLength = (_c = this.props.arcEndTickLength) !== null && _c !== void 0 ? _c : this.props.bearingTickMajorLength;
            this.bearingLabelFontColor = (_d = this.props.bearingLabelFontColor) !== null && _d !== void 0 ? _d : this.arcStrokeColor;
            this.bearingLabelOutlineWidth = (_e = this.props.bearingLabelOutlineWidth) !== null && _e !== void 0 ? _e : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_WIDTH;
            this.bearingLabelOutlineColor = (_f = this.props.bearingLabelOutlineColor) !== null && _f !== void 0 ? _f : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_COLOR;
            this.bearingLabelRadialOffset = (_g = this.props.bearingLabelRadialOffset) !== null && _g !== void 0 ? _g : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_RADIAL_OFFSET;
            this.referenceTickWidth = (_h = this.props.referenceTickWidth) !== null && _h !== void 0 ? _h : this.arcStrokeWidth;
            this.referenceTickHeight = (_j = this.props.referenceTickHeight) !== null && _j !== void 0 ? _j : this.props.bearingTickMinorLength;
            this.headingBugWidth = (_k = this.props.headingBugWidth) !== null && _k !== void 0 ? _k : MapRangeCompassLayer.DEFAULT_HEADING_BUG_WIDTH;
            this.headingBugHeight = (_l = this.props.headingBugHeight) !== null && _l !== void 0 ? _l : MapRangeCompassLayer.DEFAULT_HEADING_BUG_HEIGHT;
            this.headingLineWidth = (_m = this.props.headingLineWidth) !== null && _m !== void 0 ? _m : this.arcStrokeWidth;
            this.headingLineStyle = (_o = this.props.headingLineStyle) !== null && _o !== void 0 ? _o : MapRangeCompassLayer.DEFAULT_HEADING_LINE_STYLE;
            this.headingLineDash = (_p = this.props.headingLineDash) !== null && _p !== void 0 ? _p : [3 * this.headingLineWidth, 3 * this.headingLineWidth];
            this.referenceArrowWidth = (_q = this.props.referenceArrowWidth) !== null && _q !== void 0 ? _q : MapRangeCompassLayer.DEFAULT_REF_ARROW_WIDTH;
            this.referenceArrowHeight = (_r = this.props.referenceArrowHeight) !== null && _r !== void 0 ? _r : MapRangeCompassLayer.DEFAULT_REF_ARROW_HEIGHT;
            this.unitsModule = this.props.model.getModule(GarminMapKeys.Units);
            this.rangeModule = this.props.model.getModule(GarminMapKeys.Range);
            this.orientationModule = this.props.model.getModule(GarminMapKeys.Orientation);
            this.rangeRingModule = this.props.model.getModule(GarminMapKeys.RangeCompass);
            this.isFollowingAirplane = this.props.model.getModule(msfssdk.MapSystemKeys.FollowAirplane).isFollowing;
            this.centerSubject = msfssdk.Vec2Subject.createFromVector(new Float64Array(2));
            this.radiusSubject = msfssdk.Subject.create(0);
            this.rotationSubject = msfssdk.Subject.create(0);
            this.magVarCorrectionSubject = msfssdk.MappedSubject.create(([navAngle, magVar]) => navAngle.isMagnetic() ? magVar : 0, (_t = (_s = this.unitsModule) === null || _s === void 0 ? void 0 : _s.navAngle) !== null && _t !== void 0 ? _t : msfssdk.Subject.create(msfssdk.NavAngleUnit.create(true)), this.props.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps).magVar);
            this.referenceMarkerTypeSub = msfssdk.Subject.create(MapRangeCompassReferenceMarkerType.TICK);
            this.needUpdateRootVisibility = false;
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needRotateBearingTicks = true;
            this.needRechooseReferenceMarker = true;
            this.needRepositionReferenceMarker = true;
            this.needReclipTicks = true;
            this.needUpdateHeadingIndicatorVisibility = true;
            this.needRepositionLabel = true;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.needUpdateRootVisibility = true;
            if (isVisible) {
                this.needRechooseReferenceMarker = true;
                this.updateParameters();
            }
        }
        /** @inheritdoc */
        onAttached() {
            var _a;
            super.onAttached();
            this.arcLayerRef.instance.onAttached();
            this.roseLayerRef.instance.onAttached();
            this.roseLabelsLayerRef.instance.onAttached();
            this.referenceMarkerContainerRef.instance.onAttached();
            (_a = this.headingIndicatorRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.onAttached();
            this.initListeners();
            this.updateVisibility();
            this.updateParameters();
        }
        /**
         * Initializes listeners.
         */
        initListeners() {
            this.initParameterListeners();
            this.initModuleListeners();
            this.isFollowingAirplane.sub(() => {
                this.needRechooseReferenceMarker = true;
                this.needUpdateHeadingIndicatorVisibility = true;
            });
        }
        /**
         * Initializes parameter listeners.
         */
        initParameterListeners() {
            this.centerSubject.sub(this.onCenterChanged.bind(this));
            this.radiusSubject.sub(this.onRadiusChanged.bind(this));
            this.rotationSubject.sub(this.onRotationChanged.bind(this));
            this.magVarCorrectionSubject.sub(this.onMagVarCorrectionChanged.bind(this));
        }
        /**
         * Initializes modules listeners.
         */
        initModuleListeners() {
            this.rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
            this.orientationModule.orientation.sub(this.onOrientationChanged.bind(this));
            this.rangeRingModule.show.sub(this.onRangeCompassShowChanged.bind(this));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.arcLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.roseLabelsLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            if (this.props.showHeadingBug) {
                this.headingIndicatorRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            }
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize)) {
                // resizing the map will cause synced canvas layers to clear themselves, so we need to force a redraw on these
                // layers.
                this.needRedrawArc = true;
                this.needRedrawBearings = true;
            }
            if (!this.isVisible()) {
                return;
            }
            this.updateParameters();
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            if (this.needUpdateRootVisibility) {
                this.updateRootVisibility();
                this.needUpdateRootVisibility = false;
            }
            if (!this.isVisible()) {
                return;
            }
            this.redraw();
            this.updateSubLayers(time, elapsed);
        }
        /**
         * Updates the visibility of this layer's root.
         */
        updateRootVisibility() {
            this.rootRef.instance.style.display = this.isVisible() ? 'block' : 'none';
        }
        /**
         * Redraws the compass.
         */
        redraw() {
            this.redrawArc();
            this.redrawBearings();
            this.updateReferenceMarker();
            this.updateHeadingIndicator();
            if (this.props.showLabel) {
                this.updateLabel();
            }
        }
        /**
         * Redraws the arc of the compass.
         */
        redrawArc() {
            if (!this.needRedrawArc) {
                return;
            }
            const arcLayerDisplay = this.arcLayerRef.instance.display;
            arcLayerDisplay.clear();
            const center = this.centerSubject.get();
            const radius = this.radiusSubject.get();
            const angularWidthRad = MapRangeCompassLayer.ARC_ANGULAR_WIDTH * Avionics.Utils.DEG2RAD;
            const startAngle = -Math.PI / 2 - angularWidthRad / 2;
            const endAngle = -Math.PI / 2 + angularWidthRad / 2;
            const leftTickStart = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius + this.arcEndTickLength, startAngle, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
            const leftTickEnd = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius, startAngle, MapRangeCompassLayer.vec2Cache[1]), center, MapRangeCompassLayer.vec2Cache[1]);
            const rightTickStart = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius, endAngle, MapRangeCompassLayer.vec2Cache[2]), center, MapRangeCompassLayer.vec2Cache[2]);
            const rightTickEnd = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius + this.arcEndTickLength, endAngle, MapRangeCompassLayer.vec2Cache[3]), center, MapRangeCompassLayer.vec2Cache[3]);
            this.composeArcPath(center, radius, angularWidthRad, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd);
            arcLayerDisplay.context.lineWidth = this.arcStrokeWidth;
            arcLayerDisplay.context.strokeStyle = this.arcStrokeColor;
            arcLayerDisplay.context.stroke();
            this.needRedrawArc = false;
        }
        /**
         * Composes the path of the compass arc.
         * @param center The center of the compass, in pixels.
         * @param radius The radius of the compass, in pixels.
         * @param angularWidth The angular width of the arc, in radians.
         * @param leftTickStart The position of the start of the left end tick, in pixels.
         * @param leftTickEnd The position of the end of the left end tick, in pixels.
         * @param rightTickStart The position of the start of the right end tick, in pixels.
         * @param rightTickEnd The position of the end of the right end tick, in pixels.
         */
        composeArcPath(center, radius, angularWidth, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd) {
            const arcLayerDisplay = this.arcLayerRef.instance.display;
            arcLayerDisplay.context.beginPath();
            arcLayerDisplay.context.moveTo(leftTickStart[0], leftTickStart[1]);
            arcLayerDisplay.context.lineTo(leftTickEnd[0], leftTickEnd[1]);
            arcLayerDisplay.context.arc(center[0], center[1], radius, (-angularWidth - Math.PI) / 2, (angularWidth - Math.PI) / 2);
            arcLayerDisplay.context.lineTo(rightTickEnd[0], rightTickEnd[1]);
        }
        /**
         * Redraws the bearing tick and labels.
         */
        redrawBearings() {
            if (!this.needRedrawBearings && !this.needRotateBearingTicks) {
                return;
            }
            this.roseLabelsLayerRef.instance.redraw();
            this.roseLayerRef.instance.updateRotation();
            this.needRotateBearingTicks = false;
            if (!this.needRedrawBearings && !this.needReclipTicks) {
                return;
            }
            if (this.needReclipTicks) {
                this.updateBearingTickClip();
            }
            this.roseLayerRef.instance.redraw();
            this.needRedrawBearings = false;
        }
        /**
         * Updates the bearing tick clip mask.
         */
        updateBearingTickClip() {
            const center = this.centerSubject.get();
            const radius = this.radiusSubject.get();
            const thick = this.arcStrokeWidth / 2;
            const innerToOuterLength = this.arcEndTickLength + thick + 5;
            const totalRadius = radius + this.arcEndTickLength + thick / 2 + 5;
            const leftAngle = -MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2 * Avionics.Utils.DEG2RAD - Math.PI / 2;
            const leftInner1 = msfssdk.Vec2Math.setFromPolar(radius - thick / 2, leftAngle, MapRangeCompassLayer.vec2Cache[0]);
            const leftInner2 = msfssdk.Vec2Math.setFromPolar(thick / 2, leftAngle - Math.PI / 2, MapRangeCompassLayer.vec2Cache[1]);
            const leftOuter = msfssdk.Vec2Math.setFromPolar(innerToOuterLength, leftAngle, MapRangeCompassLayer.vec2Cache[2]);
            const outerWidth = Math.abs(leftInner1[0] + leftInner2[0] + leftOuter[0]) * 2;
            this.roseLayerContainerRef.instance.style.webkitClipPath // the cast is to avoid typescript complaining webkitCliPath doesn't exist
                = `path('M${center[0]},${center[1]} l${leftInner1[0]},${leftInner1[1]} l${leftInner2[0]},${leftInner2[1]} l${leftOuter[0]},${leftOuter[1]} a${totalRadius},${totalRadius},0,0,1,${outerWidth},0 l${leftInner2[0]},${-leftInner2[1]} l${leftInner1[0]},${-leftInner1[1]} Z')`;
            this.needReclipTicks = false;
        }
        /**
         * Redraws the reference marker.
         */
        updateReferenceMarker() {
            if (!this.needRechooseReferenceMarker && !this.needRepositionReferenceMarker) {
                return;
            }
            if (this.needRechooseReferenceMarker) {
                const orientation = this.orientationModule.orientation.get();
                const type = (this.props.showHeadingBug && this.isFollowingAirplane.get() && orientation === exports.MapOrientation.HeadingUp)
                    ? MapRangeCompassReferenceMarkerType.ARROW
                    : MapRangeCompassReferenceMarkerType.TICK;
                this.referenceMarkerTypeSub.set(type);
                this.needRechooseReferenceMarker = false;
            }
            if (!this.needRepositionReferenceMarker) {
                return;
            }
            this.referenceMarkerContainerRef.instance.reposition();
            this.needRepositionReferenceMarker = false;
        }
        /**
         * Updates the selected heading indicator.
         */
        updateHeadingIndicator() {
            var _a;
            if (!this.needUpdateHeadingIndicatorVisibility) {
                return;
            }
            const orientation = this.orientationModule.orientation.get();
            (_a = this.headingIndicatorRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(this.isFollowingAirplane.get() && orientation === exports.MapOrientation.HeadingUp);
            this.needUpdateHeadingIndicatorVisibility = false;
        }
        /**
         * Updates the range display label.
         */
        updateLabel() {
            if (!this.needRepositionLabel) {
                return;
            }
            const center = this.centerSubject.get();
            const radius = this.radiusSubject.get();
            const pos = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius, MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE * Avionics.Utils.DEG2RAD, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
            this.rangeDisplayContainerRef.instance.style.left = `${pos[0]}px`;
            this.rangeDisplayContainerRef.instance.style.top = `${pos[1]}px`;
            this.needRepositionLabel = false;
        }
        /**
         * Updates this layer's sublayers.
         * @param time The current time as a UNIX timestamp.
         * @param elapsed The elapsed time, in milliseconds, since the last update.
         */
        updateSubLayers(time, elapsed) {
            this.arcLayerRef.instance.onUpdated(time, elapsed);
            this.roseLayerRef.instance.onUpdated(time, elapsed);
            this.roseLabelsLayerRef.instance.onUpdated(time, elapsed);
            this.referenceMarkerContainerRef.instance.onUpdated(time, elapsed);
            if (this.props.showHeadingBug) {
                this.headingIndicatorRef.instance.onUpdated(time, elapsed);
            }
        }
        /**
         * Updates this layer's visibility.
         */
        updateVisibility() {
            this.setVisible(this.props.model.getModule('rangeCompass').show.get());
        }
        /**
         * Updates the ring.
         */
        updateParameters() {
            const center = this.props.mapProjection.getTargetProjected();
            const radius = this.rangeModule.nominalRange.get().asUnit(msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const rotation = Math.round((this.props.mapProjection.getRotation() + this.magVarCorrectionSubject.get() * Avionics.Utils.DEG2RAD) * 1e4) / 1e4;
            this.centerSubject.set(center);
            this.radiusSubject.set(radius);
            this.rotationSubject.set(rotation);
        }
        /**
         * Responds to changes in the location of the center of the compass.
         */
        onCenterChanged() {
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needRepositionReferenceMarker = true;
            this.needReclipTicks = true;
            this.needRepositionLabel = true;
        }
        /**
         * Responds to changes in the radius of the compass.
         */
        onRadiusChanged() {
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needRepositionReferenceMarker = true;
            this.needReclipTicks = true;
            this.needRepositionLabel = true;
        }
        /**
         * Responds to changes in the rotation of the compass.
         */
        onRotationChanged() {
            this.needRotateBearingTicks = true;
        }
        /**
         * Responds to changes in the magnetic variation correction for the compass.
         */
        onMagVarCorrectionChanged() {
            if (this.isVisible()) {
                this.updateParameters();
            }
        }
        /**
         * Responds to changes in the nominal map range.
         */
        onRangeChanged() {
            if (this.isVisible()) {
                this.updateParameters();
            }
        }
        /**
         * Responds to changes in the map orientation.
         */
        onOrientationChanged() {
            this.needRechooseReferenceMarker = true;
            this.needUpdateHeadingIndicatorVisibility = true;
        }
        /**
         * Responds to changes in whether to show the range ring.
         */
        onRangeCompassShowChanged() {
            this.updateVisibility();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
                msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { ref: this.arcLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
                msfssdk.FSComponent.buildComponent("div", { ref: this.roseLayerContainerRef, style: 'position: absolute; width: 100%; height: 100%;' },
                    msfssdk.FSComponent.buildComponent(MapRangeCompassRose, { ref: this.roseLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, tickMajorInterval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, tickMinorMultiplier: MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR, tickMajorLength: this.props.bearingTickMajorLength, tickMinorLength: this.props.bearingTickMinorLength, tickStrokeWidth: this.arcStrokeWidth, tickStrokeColor: this.arcStrokeColor })),
                msfssdk.FSComponent.buildComponent(MapRangeCompassReferenceMarkerContainer, { ref: this.referenceMarkerContainerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, activeType: this.referenceMarkerTypeSub, tickWidth: this.referenceTickWidth, tickHeight: this.referenceTickHeight, arrowWidth: this.referenceArrowWidth, arrowHeight: this.referenceArrowHeight, color: this.arcStrokeColor }),
                this.renderSelectedHeadingIndicator(),
                msfssdk.FSComponent.buildComponent(MapRangeCompassRoseLabels, { ref: this.roseLabelsLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, angularWidth: MapRangeCompassLayer.ARC_ANGULAR_WIDTH, interval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, font: this.props.bearingLabelFont, fontSize: this.props.bearingLabelFontSize, fontColor: this.bearingLabelFontColor, outlineWidth: this.bearingLabelOutlineWidth, outlineColor: this.bearingLabelOutlineColor, radialOffset: this.props.bearingTickMajorLength + this.bearingLabelRadialOffset }),
                this.renderRangeDisplay()));
        }
        /**
         * Renders the selected heading indicator.
         * @returns a VNode representing the range display label.
         */
        renderSelectedHeadingIndicator() {
            return this.props.showHeadingBug
                ? (msfssdk.FSComponent.buildComponent(MapRangeCompassSelectedHeading, { ref: this.headingIndicatorRef, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, bugWidth: this.headingBugWidth, bugHeight: this.headingBugHeight, bugNotchHeight: this.referenceArrowHeight / 3, bugNotchWidth: this.referenceArrowWidth / 3, outlineWidth: 1, lineWidth: this.headingLineWidth, lineStyle: this.headingLineStyle, lineDash: this.headingLineDash }))
                : (msfssdk.FSComponent.buildComponent("div", { style: 'display: none;' }));
        }
        /**
         * Renders the range display label.
         * @returns a VNode representing the range display label.
         */
        renderRangeDisplay() {
            var _a, _b;
            const rangeModule = this.rangeModule;
            const displayUnit = (_b = (_a = this.unitsModule) === null || _a === void 0 ? void 0 : _a.distanceLarge) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            return this.props.showLabel
                ? (msfssdk.FSComponent.buildComponent("div", { ref: this.rangeDisplayContainerRef, style: 'position: absolute; transform: translate(-50%, -50%);' }, this.props.renderLabel !== undefined
                    ? this.props.renderLabel(rangeModule.nominalRange, displayUnit)
                    : (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: displayUnit }))))
                : null;
        }
    }
    /** The angular width of the compass arc, in degrees. */
    MapRangeCompassLayer.ARC_ANGULAR_WIDTH = 120;
    /** The angular interval, in degrees, between major bearing ticks. */
    MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL = 30;
    /** The number of minor bearing ticks per major bearing tick. */
    MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR = 3;
    /** The radial on which the range label is positioned, in degrees. */
    MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE = -135;
    MapRangeCompassLayer.DEFAULT_ARC_STROKE_WIDTH = 2; // px
    MapRangeCompassLayer.DEFAULT_ARC_STROKE_COLOR = 'white';
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_WIDTH = 6; // px
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_COLOR = 'black';
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_RADIAL_OFFSET = 0; // px
    MapRangeCompassLayer.DEFAULT_HEADING_BUG_WIDTH = 20; // px
    MapRangeCompassLayer.DEFAULT_HEADING_BUG_HEIGHT = 10; // px
    MapRangeCompassLayer.DEFAULT_HEADING_LINE_STYLE = 'cyan';
    MapRangeCompassLayer.DEFAULT_REF_ARROW_WIDTH = 15; // px
    MapRangeCompassLayer.DEFAULT_REF_ARROW_HEIGHT = 20; // px
    MapRangeCompassLayer.vec2Cache = Array.from({ length: 4 }, () => new Float64Array(2));
    /**
     * A rotating compass rose with unlabeled graduated bearing ticks.
     */
    class MapRangeCompassRose extends msfssdk.MapCanvasLayer {
        constructor() {
            super(...arguments);
            this.bearingStep = this.props.tickMajorInterval / this.props.tickMinorMultiplier * Avionics.Utils.DEG2RAD;
            this.numMinorBearingTicks = Math.floor(2 * Math.PI / this.bearingStep);
        }
        /**
         * Redraws the canvas.
         */
        redraw() {
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const canvasSize = Math.ceil(radius) * 2;
            this.setWidth(canvasSize);
            this.setHeight(canvasSize);
            this.display.canvas.style.left = `${center[0] - canvasSize / 2}px`;
            this.display.canvas.style.top = `${center[1] - canvasSize / 2}px`;
            this.display.clear();
            this.composeBearingTicksPath(radius);
            this.display.context.lineWidth = this.props.tickStrokeWidth;
            this.display.context.strokeStyle = this.props.tickStrokeColor;
            this.display.context.stroke();
        }
        /**
         * Composes the path of the bearing ticks.
         * @param radius The radius of the compass, in pixels.
         */
        composeBearingTicksPath(radius) {
            const canvasSize = this.getWidth();
            const center = msfssdk.Vec2Math.set(canvasSize / 2, canvasSize / 2, MapRangeCompassRose.vec2Cache[0]);
            this.display.context.beginPath();
            for (let i = 0; i < this.numMinorBearingTicks; i++) {
                const bearing = i * this.bearingStep;
                const angle = bearing - Math.PI / 2;
                let start;
                if (i % MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR === 0) {
                    // major tick
                    start = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius - this.props.tickMajorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
                }
                else {
                    // minor tick
                    start = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius - this.props.tickMinorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
                }
                const end = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius, angle, MapRangeCompassRose.vec2Cache[2]), center, MapRangeCompassRose.vec2Cache[2]);
                this.display.context.moveTo(start[0], start[1]);
                this.display.context.lineTo(end[0], end[1]);
            }
        }
        /**
         * Updates the rotation of this rose.
         */
        updateRotation() {
            this.display.canvas.style.transform = `rotate(${this.props.compassRotationSubject.get()}rad)`;
        }
    }
    MapRangeCompassRose.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
    /**
     * Bearing labels for a rotating range compass rose.
     */
    class MapRangeCompassRoseLabels extends msfssdk.MapSyncedCanvasLayer {
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.initStyles();
        }
        /**
         * Initializes styles on this layer's canvas context.
         */
        initStyles() {
            this.display.context.lineWidth = this.props.outlineWidth * 2;
            this.display.context.strokeStyle = this.props.outlineColor;
            this.display.context.font = `${this.props.fontSize}px ${this.props.font}`;
            this.display.context.fillStyle = this.props.fontColor;
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            super.onMapProjectionChanged(mapProjection, changeFlags);
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize)) {
                this.initStyles();
            }
        }
        /**
         * Redraws the bearing labels.
         */
        redraw() {
            this.display.clear();
            const PI2 = Math.PI * 2;
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const rotation = this.props.compassRotationSubject.get();
            const halfAngularWidth = this.props.angularWidth / 2 * Avionics.Utils.DEG2RAD;
            const centerBearing = (-rotation + PI2) % PI2;
            const intervalRad = this.props.interval * Avionics.Utils.DEG2RAD;
            for (let bearing = 0; bearing < PI2; bearing += intervalRad) {
                if (Math.min(Math.abs(bearing - centerBearing), PI2 - Math.abs(bearing - centerBearing)) > halfAngularWidth) {
                    continue;
                }
                this.drawBearingLabel(center, radius, rotation, bearing);
            }
        }
        /**
         * Draws a bearing label.
         * @param center The center of the compass, in pixels.
         * @param radius The radius of the compass, in pixels.
         * @param rotation The rotation of the compass, in radians.
         * @param bearing The label's bearing, in radians.
         */
        drawBearingLabel(center, radius, rotation, bearing) {
            // TODO: support the T superscript for true bearings.
            const text = (360 - (360 - (bearing * Avionics.Utils.RAD2DEG)) % 360).toFixed(0).padStart(3, '0');
            const angle = bearing - Math.PI / 2 + rotation;
            const textWidth = this.display.context.measureText(text).width;
            const textHeight = this.props.fontSize;
            const textOffset = Math.hypot(textWidth, textHeight) / 2 + this.props.radialOffset;
            const textRadius = radius - textOffset;
            const labelPos = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(textRadius, angle, MapRangeCompassRoseLabels.vec2Cache[0]), msfssdk.Vec2Math.set(center[0] - textWidth / 2, center[1] + textHeight / 2, MapRangeCompassRoseLabels.vec2Cache[1]), MapRangeCompassRoseLabels.vec2Cache[0]);
            if (this.props.outlineWidth > 0) {
                this.display.context.strokeText(text, labelPos[0], labelPos[1]);
            }
            this.display.context.fillText(text, labelPos[0], labelPos[1]);
        }
    }
    MapRangeCompassRoseLabels.vec2Cache = [new Float64Array(2), new Float64Array(2)];
    /**
     * A reference arrow for MapRangeCompassLayer.
     */
    class MapRangeCompassReferenceArrow extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.svgRef = msfssdk.FSComponent.createRef();
        }
        /**
         * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
         * @param val Whether this marker should be visible.
         */
        setVisible(val) {
            if (!this.svgRef.instance) {
                return;
            }
            this.svgRef.instance.style.display = val ? 'block' : 'none';
        }
        /**
         * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
         * This method has no effect if this marker has not been rendered.
         * @param pos The new position, in pixels.
         */
        setPosition(pos) {
            if (!this.svgRef.instance) {
                return;
            }
            const svg = this.svgRef.instance;
            svg.style.left = `${pos[0]}px`;
            svg.style.top = `${pos[1]}px`;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -66.7%);` },
                msfssdk.FSComponent.buildComponent("path", { d: 'M 0 0 L 100 0 L 50 100 Z', fill: this.props.color })));
        }
    }
    /**
     * A reference tick for MapRangeCompassLayer.
     */
    class MapRangeCompassReferenceTick extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.svgRef = msfssdk.FSComponent.createRef();
        }
        /**
         * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
         * @param val Whether this marker should be visible.
         */
        setVisible(val) {
            if (!this.svgRef.instance) {
                return;
            }
            this.svgRef.instance.style.display = val ? 'block' : 'none';
        }
        /**
         * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
         * This method has no effect if this marker has not been rendered.
         * @param pos The new position, in pixels.
         */
        setPosition(pos) {
            if (!this.svgRef.instance) {
                return;
            }
            const svg = this.svgRef.instance;
            svg.style.left = `${pos[0]}px`;
            svg.style.top = `${pos[1]}px`;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -100%);` },
                msfssdk.FSComponent.buildComponent("rect", { x: '0', y: '0', width: '100', height: '100', fill: this.props.color })));
        }
    }
    /**
     *
     */
    var MapRangeCompassReferenceMarkerType;
    (function (MapRangeCompassReferenceMarkerType) {
        MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["TICK"] = 0] = "TICK";
        MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["ARROW"] = 1] = "ARROW";
    })(MapRangeCompassReferenceMarkerType || (MapRangeCompassReferenceMarkerType = {}));
    /**
     * A container for range compass reference markers.
     */
    class MapRangeCompassReferenceMarkerContainer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.containerRef = msfssdk.FSComponent.createRef();
            this.referenceTickRef = msfssdk.FSComponent.createRef();
            this.referenceArrowRef = msfssdk.FSComponent.createRef();
            this.activeReferenceMarker = null;
        }
        /** @inheritdoc */
        onAttached() {
            this.props.activeType.sub(this.onActiveTypeChanged.bind(this), true);
        }
        /**
         * Responds to active marker type changes.
         * @param type The active marker type.
         */
        onActiveTypeChanged(type) {
            const selectedReferenceMarker = type === MapRangeCompassReferenceMarkerType.TICK
                ? this.referenceTickRef.instance
                : this.referenceArrowRef.instance;
            const oldActiveMarker = this.activeReferenceMarker;
            if (oldActiveMarker !== selectedReferenceMarker) {
                this.activeReferenceMarker = selectedReferenceMarker;
                oldActiveMarker === null || oldActiveMarker === void 0 ? void 0 : oldActiveMarker.setVisible(false);
                this.activeReferenceMarker.setVisible(true);
                this.reposition();
            }
        }
        /**
         * Repositions the reference marker.
         */
        reposition() {
            var _a;
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const pos = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(radius, -Math.PI / 2, MapRangeCompassReferenceMarkerContainer.tempVec2), center, MapRangeCompassReferenceMarkerContainer.tempVec2);
            (_a = this.activeReferenceMarker) === null || _a === void 0 ? void 0 : _a.setPosition(pos);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.containerRef, style: 'position: absolute; width: 100%; height: 100%;' },
                msfssdk.FSComponent.buildComponent(MapRangeCompassReferenceTick, { ref: this.referenceTickRef, width: this.props.tickWidth, height: this.props.tickHeight, color: this.props.color }),
                msfssdk.FSComponent.buildComponent(MapRangeCompassReferenceArrow, { ref: this.referenceArrowRef, width: this.props.arrowWidth, height: this.props.arrowHeight, color: this.props.color })));
        }
    }
    MapRangeCompassReferenceMarkerContainer.tempVec2 = new Float64Array(2);
    /**
     * The selected heading bug and heading line for the map range compass layer.
     */
    class MapRangeCompassSelectedHeading extends msfssdk.MapLayer {
        /** @inheritdoc */
        constructor(props) {
            super(props);
            this.canvasLayerRef = msfssdk.FSComponent.createRef();
            this.selectedHeading = 0;
            this.isInit = false;
            this.isSuppressedSubject = msfssdk.Subject.create(true);
            this.suppressTimer = null;
            this.centerSubject = msfssdk.Vec2Subject.createFromVector(new Float64Array(2));
            this.radiusSubject = msfssdk.Subject.create(0);
            this.rotationSubject = msfssdk.Subject.create(0);
            this.isOOBSubject = msfssdk.Subject.create(true);
            this.needRedraw = true;
            this.needReposition = true;
            this.needRotate = true;
            /**
             * A callback which is called when the suppress timer fires.
             */
            this.suppressCallback = () => {
                this.suppressTimer = null;
                this.isSuppressedSubject.set(true);
            };
            /**
             * A callback which is called when the selected heading changes.
             * @param heading The new selected heading, in degrees.
             */
            this.onSelectedHeadingChanged = (heading) => {
                this.selectedHeading = heading;
                this.unsuppress(MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION);
                this.updateParameters();
            };
            this.selectedHeadingConsumer = this.props.bus.getSubscriber().on('ap_heading_selected').whenChanged();
        }
        // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
        onVisibilityChanged(isVisible) {
            if (this.isInit) {
                this.updateFromVisibility();
            }
        }
        /**
         * Updates this layer according to its current visibility.
         */
        updateFromVisibility() {
            const isVisible = this.isVisible();
            if (isVisible) {
                this.selectedHeadingConsumer.handle(this.onSelectedHeadingChanged);
            }
            else {
                this.selectedHeadingConsumer.off(this.onSelectedHeadingChanged);
                this.suppress();
            }
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.canvasLayerRef.instance.onAttached();
            this.initCanvas();
            this.isInit = true;
            this.initSubjectListeners();
            this.updateFromVisibility();
        }
        /**
         * Initializes canvas width.
         */
        initCanvas() {
            const width = Math.max(this.props.lineWidth, this.props.bugWidth + this.props.outlineWidth * 2);
            this.canvasLayerRef.instance.setWidth(width);
            const canvasLayerDisplay = this.canvasLayerRef.instance.display;
            canvasLayerDisplay.canvas.style.width = `${width}px`;
            canvasLayerDisplay.canvas.style.transformOrigin = '50% 100%';
        }
        /**
         * Initializes subject listeners.
         */
        initSubjectListeners() {
            this.props.compassCenterSubject.sub(this.updateParameters.bind(this));
            this.props.compassRadiusSubject.sub(this.updateParameters.bind(this));
            this.props.compassRotationSubject.sub(this.updateParameters.bind(this));
            this.centerSubject.sub(this.onCenterChanged.bind(this));
            this.radiusSubject.sub(this.onRadiusChanged.bind(this));
            this.rotationSubject.sub(this.onRotationChanged.bind(this));
            this.isSuppressedSubject.sub(this.onIsSuppressedChanged.bind(this));
            this.isOOBSubject.sub(this.onIsOOBChanged.bind(this));
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        onMapProjectionChanged(mapProjection, changeFlags) {
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize)) {
                this.needReposition = true;
                this.needRedraw = true;
            }
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        onUpdated(time, elapsed) {
            this.canvasLayerRef.instance.onUpdated(time, elapsed);
            if (this.needReposition) {
                this.reposition();
            }
            else if (this.needRedraw) {
                this.redraw();
            }
            if (this.needRotate) {
                this.rotate();
            }
        }
        /**
         * Repositions the canvas.
         */
        reposition() {
            const center = this.props.compassCenterSubject.get();
            const projectedWidth = this.props.mapProjection.getProjectedSize()[0];
            const projectedHeight = this.props.mapProjection.getProjectedSize()[1];
            // find the distance to the farthest corner.
            const isLeft = center[0] > projectedWidth / 2;
            const isTop = center[1] > projectedHeight / 2;
            const height = Math.hypot(center[0] - (isLeft ? 0 : projectedWidth), center[1] - (isTop ? 0 : projectedHeight));
            this.canvasLayerRef.instance.setHeight(height);
            const canvasLayerDisplay = this.canvasLayerRef.instance.display;
            canvasLayerDisplay.canvas.style.height = `${height}px`;
            canvasLayerDisplay.canvas.style.left = `${center[0] - this.canvasLayerRef.instance.getWidth() / 2}px`;
            canvasLayerDisplay.canvas.style.bottom = `${projectedHeight - center[1]}px`;
            this.needReposition = false;
            this.redraw();
        }
        /**
         * Redraws the canvas.
         */
        redraw() {
            const canvasWidth = this.canvasLayerRef.instance.getWidth();
            const canvasHeight = this.canvasLayerRef.instance.getHeight();
            const radius = this.props.compassRadiusSubject.get();
            const canvasLayerDisplay = this.canvasLayerRef.instance.display;
            canvasLayerDisplay.clear();
            this.redrawLine(canvasWidth, canvasHeight);
            this.redrawBug(canvasWidth, canvasHeight, radius);
            this.needRedraw = false;
        }
        /**
         * Redraws the heading line.
         * @param canvasWidth The width of the canvas, in pixels.
         * @param canvasHeight The height of the canvas, in pixels.
         */
        redrawLine(canvasWidth, canvasHeight) {
            const canvasLayerDisplay = this.canvasLayerRef.instance.display;
            canvasLayerDisplay.context.beginPath();
            canvasLayerDisplay.context.moveTo(canvasWidth / 2, canvasHeight);
            canvasLayerDisplay.context.lineTo(canvasWidth / 2, 0);
            canvasLayerDisplay.context.lineWidth = this.props.lineWidth;
            canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.COLOR;
            canvasLayerDisplay.context.setLineDash(this.props.lineDash);
            canvasLayerDisplay.context.stroke();
        }
        /**
         * Redraws the heading bug.
         * @param canvasWidth The width of the canvas, in pixels.
         * @param canvasHeight The height of the canvas, in pixels.
         * @param radius The radius of the compass, in pixels.
         */
        redrawBug(canvasWidth, canvasHeight, radius) {
            const canvasLayerDisplay = this.canvasLayerRef.instance.display;
            const left = (canvasWidth - this.props.bugWidth) / 2;
            const top = canvasHeight - radius;
            const middle = canvasWidth / 2;
            const right = left + this.props.bugWidth;
            const bottom = top + this.props.bugHeight;
            canvasLayerDisplay.context.beginPath();
            canvasLayerDisplay.context.moveTo(left, top);
            canvasLayerDisplay.context.lineTo(middle - this.props.bugNotchWidth / 2, top);
            canvasLayerDisplay.context.lineTo(middle, top + this.props.bugNotchHeight);
            canvasLayerDisplay.context.lineTo(middle + this.props.bugNotchWidth / 2, top);
            canvasLayerDisplay.context.lineTo(right, top);
            canvasLayerDisplay.context.lineTo(right, bottom);
            canvasLayerDisplay.context.lineTo(left, bottom);
            canvasLayerDisplay.context.closePath();
            canvasLayerDisplay.context.fillStyle = MapRangeCompassSelectedHeading.COLOR;
            canvasLayerDisplay.context.lineWidth = this.props.outlineWidth * 2;
            canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.OUTLINE_COLOR;
            canvasLayerDisplay.context.setLineDash(MapRangeCompassSelectedHeading.NO_LINE_DASH);
            canvasLayerDisplay.context.stroke();
            canvasLayerDisplay.context.fill();
        }
        /**
         * Rotates the canvas.
         */
        rotate() {
            const compassRotation = this.props.compassRotationSubject.get();
            const rotation = this.selectedHeading * Avionics.Utils.DEG2RAD + compassRotation;
            this.canvasLayerRef.instance.display.canvas.style.transform = `rotate(${rotation}rad)`;
            this.needRotate = false;
        }
        /**
         * Suppresses this indicator, making it invisible. Also kills the suppress timer if it is running.
         */
        suppress() {
            this.killSuppressTimer();
            this.isSuppressedSubject.set(true);
        }
        /**
         * Unsuppresses this indicator, making it visible, for a certain duration. If the suppress timer is currently
         * running, it is killed and replaced with a new one which will fire after the specified duration.
         * @param duration The duration for which to unsuppress, in milliseconds.
         */
        unsuppress(duration) {
            this.killSuppressTimer();
            this.isSuppressedSubject.set(false);
            this.suppressTimer = setTimeout(this.suppressCallback, duration);
        }
        /**
         * Kills the timer to suppress this indicator, if one is currently running.
         */
        killSuppressTimer() {
            if (this.suppressTimer !== null) {
                clearTimeout(this.suppressTimer);
            }
        }
        /**
         * Updates this indicator based on whether it should be suppressed.
         * @param isSuppressed Whether this indicator should be suppressed.
         */
        updateFromIsSuppressed(isSuppressed) {
            this.updateCanvasVisibility(isSuppressed, this.isOOBSubject.get());
        }
        /**
         * Updates this indicator based on whether it is out of the current compass bounds.
         * @param isOOB Whether this indicator is out of the current compass bounds.
         */
        updateFromIsOOB(isOOB) {
            this.updateCanvasVisibility(this.isSuppressedSubject.get(), isOOB);
        }
        /**
         * Updates the visibility of the canvas.
         * @param isSuppressed Whether this indicator is suppressed.
         * @param isOOB Whether this indicator is out of the current compass bounds.
         */
        updateCanvasVisibility(isSuppressed, isOOB) {
            this.canvasLayerRef.instance.setVisible(!isOOB && !isSuppressed);
        }
        /**
         * Updates this indicator's center, radius, and rotation.
         */
        updateParameters() {
            const compassRotation = this.props.compassRotationSubject.get();
            const compassCenter = -compassRotation * Avionics.Utils.RAD2DEG;
            const isOOB = Math.abs(msfssdk.NavMath.diffAngle(this.selectedHeading, compassCenter)) > MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2;
            this.isOOBSubject.set(isOOB);
            if (!this.canvasLayerRef.instance.isVisible()) {
                return;
            }
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const rotation = compassRotation + this.selectedHeading * Avionics.Utils.DEG2RAD;
            this.centerSubject.set(center);
            this.radiusSubject.set(radius);
            this.rotationSubject.set(rotation);
        }
        /**
         * A callback which is called when the center of the compass changes.
         */
        onCenterChanged() {
            this.needReposition = true;
        }
        /**
         * A callback which is called when the center of the compass changes.
         */
        onRadiusChanged() {
            this.needRedraw = true;
        }
        /**
         * A callback which is called when the rotation of the compass changes.
         */
        onRotationChanged() {
            this.needRotate = true;
        }
        /**
         * A callback which is called when whether this indicator is suppressed has changed.
         * @param isSuppressed Whether this indicator is suppressed.
         */
        onIsSuppressedChanged(isSuppressed) {
            this.updateFromIsSuppressed(isSuppressed);
        }
        /**
         * A callback which is called when whether this indicator is out of the current compass bounds has changed.
         * @param isOOB Whether this indicator is out of the current compass bounds.
         */
        onIsOOBChanged(isOOB) {
            this.updateFromIsOOB(isOOB);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.MapCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
        }
    }
    /** The amount of time, in milliseconds, the indicator is unsuppressed when the selected heading is changed. */
    MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION = 3000;
    /** The color of the bug and line. */
    MapRangeCompassSelectedHeading.COLOR = 'cyan';
    /** The outline color of the bug. */
    MapRangeCompassSelectedHeading.OUTLINE_COLOR = 'black';
    MapRangeCompassSelectedHeading.NO_LINE_DASH = [];

    /**
     * A map layer which draws a range ring around the map target.
     */
    class MapRangeRingLayer extends msfssdk.MapLabeledRingLayer {
        constructor() {
            super(...arguments);
            this.rangeModule = this.props.model.getModule(GarminMapKeys.Range);
            this.rangeRingModule = this.props.model.getModule(GarminMapKeys.RangeRing);
            this.label = null;
            this.needUpdateRing = false;
        }
        /** @inheritdoc */
        updateFromVisibility() {
            super.updateFromVisibility();
            if (this.isVisible()) {
                this.needUpdateRing = true;
            }
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.initLabel();
            this.initStyles();
            this.initModuleListeners();
            this.updateVisibility();
            this.needUpdateRing = true;
        }
        /**
         * Initializes the range display label.
         */
        initLabel() {
            var _a, _b, _c;
            if (!this.props.showLabel) {
                return;
            }
            const displayUnit = (_b = (_a = this.props.model.getModule(GarminMapKeys.Units)) === null || _a === void 0 ? void 0 : _a.distanceLarge) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            this.label = this.createLabel(this.props.renderLabel !== undefined
                ? this.props.renderLabel(this.rangeModule.nominalRange, displayUnit)
                : (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { range: this.rangeModule.nominalRange, displayUnit: displayUnit })));
            this.label.setAnchor(new Float64Array([0.5, 0.5]));
            this.label.setRadialAngle(((_c = this.props.labelRadial) !== null && _c !== void 0 ? _c : 225) * Avionics.Utils.DEG2RAD);
        }
        /**
         * Initializes ring styles.
         */
        initStyles() {
            var _a, _b, _c, _d;
            this.setRingStrokeStyles((_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : 2, (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : 'white', this.props.strokeDash);
            this.setRingOutlineStyles((_c = this.props.outlineWidth) !== null && _c !== void 0 ? _c : 0, (_d = this.props.outlineStyle) !== null && _d !== void 0 ? _d : 'black', this.props.outlineDash);
        }
        /**
         * Initializes modules listeners.
         */
        initModuleListeners() {
            this.rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
            this.rangeRingModule.show.sub(this.updateVisibility.bind(this));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            super.onMapProjectionChanged(mapProjection, changeFlags);
            if (!this.isVisible()) {
                return;
            }
            this.needUpdateRing = true;
        }
        /**
         * Updates this layer's visibility.
         */
        updateVisibility() {
            this.setVisible(this.rangeRingModule.show.get());
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            if (this.needUpdateRing) {
                this.updateRing();
                this.needUpdateRing = false;
            }
            super.onUpdated(time, elapsed);
        }
        /**
         * Updates the ring.
         */
        updateRing() {
            const center = this.props.mapProjection.getTargetProjected();
            const radius = this.rangeModule.nominalRange.get().asUnit(msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            this.setRingPosition(center, radius);
        }
        /**
         * A callback which is called when the nominal map range changes.
         */
        onRangeChanged() {
            if (!this.isVisible()) {
                return;
            }
            this.needUpdateRing = true;
        }
    }

    /**
     * A map layer which displays a track vector.
     */
    class MapTrackVectorLayer extends msfssdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d;
            super(...arguments);
            this.canvasLayerRef = msfssdk.FSComponent.createRef();
            this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapTrackVectorLayer.DEFAULT_STROKE_WIDTH;
            this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapTrackVectorLayer.DEFAULT_STROKE_STYLE;
            this.outlineWidth = (_c = this.props.outlineWidth) !== null && _c !== void 0 ? _c : MapTrackVectorLayer.DEFAULT_OUTLINE_WIDTH;
            this.outlineStyle = (_d = this.props.outlineStyle) !== null && _d !== void 0 ? _d : MapTrackVectorLayer.DEFAULT_OUTLINE_STYLE;
            this.ownAirplanePropsModule = this.props.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
            this.trackVectorModule = this.props.model.getModule(GarminMapKeys.TrackVector);
            this.arcTurnRateThreshold = (typeof this.props.arcTurnRateThreshold === 'object')
                ? this.props.arcTurnRateThreshold
                : msfssdk.Subject.create(this.props.arcTurnRateThreshold);
            this.arcMaxLookaheadTime = ('isSubscribable' in this.props.arcMaxLookaheadTime)
                ? this.props.arcMaxLookaheadTime
                : msfssdk.Subject.create(this.props.arcMaxLookaheadTime);
            this.projectedPlanePosition = msfssdk.Vec2Subject.createFromVector(new Float64Array(2));
            this.projectPlanePositionHandler = () => {
                const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapTrackVectorLayer.vec2Cache[0]);
                this.projectedPlanePosition.set(projected);
            };
            this.turnRateSmoother = new msfssdk.ExpSmoother(500 / Math.LN2, undefined, 1000);
            this.needUpdate = false;
            this.subscriptions = [];
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.needUpdate = true;
            }
            else {
                (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
            }
        }
        /** @inheritdoc */
        onAttached() {
            this.canvasLayerRef.instance.onAttached();
            this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
            const scheduleUpdate = () => { this.needUpdate = true; };
            this.isVectorVisible = msfssdk.MappedSubject.create(([show, isOnGround]) => show && !isOnGround, this.trackVectorModule.show, this.ownAirplanePropsModule.isOnGround);
            this.isVectorVisible.sub(isVisible => { this.setVisible(isVisible); }, true);
            this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.turnRate.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate));
            this.subscriptions.push(this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate));
            this.subscriptions.push(this.trackVectorModule.lookaheadTime.sub(scheduleUpdate, true));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.projectPlanePositionHandler();
            this.needUpdate = true;
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const display = this.canvasLayerRef.instance.display;
            display.clear();
            const lookaheadTime = this.trackVectorModule.lookaheadTime.get();
            const track = this.ownAirplanePropsModule.trackTrue.get();
            const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
            const turnRate = this.turnRateSmoother.next(this.ownAirplanePropsModule.turnRate.get(), elapsed);
            const distanceNM = groundSpeed.asUnit(msfssdk.UnitType.KNOT) * lookaheadTime.asUnit(msfssdk.UnitType.HOUR);
            const distancePx = msfssdk.UnitType.NMILE.convertTo(distanceNM, msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - Math.PI / 2;
            const projectedPlanePos = this.projectedPlanePosition.get();
            display.context.beginPath();
            display.context.moveTo(projectedPlanePos[0], projectedPlanePos[1]);
            if (Math.abs(turnRate) < this.arcTurnRateThreshold.get() || lookaheadTime.compare(this.arcMaxLookaheadTime.get()) > 0) {
                // draw a line
                const delta = msfssdk.Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapTrackVectorLayer.vec2Cache[0]);
                display.context.lineTo(projectedPlanePos[0] + delta[0], projectedPlanePos[1] + delta[1]);
            }
            else {
                // draw an arc
                const groundSpeedPxPerSec = msfssdk.UnitType.NMILE.convertTo(groundSpeed.asUnit(msfssdk.UnitType.KNOT) / 3600, msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
                const turnRadius = groundSpeedPxPerSec / (turnRate * Avionics.Utils.DEG2RAD);
                const angularWidthDrawn = Utils.Clamp(distancePx / turnRadius, -Math.PI / 2, Math.PI / 2);
                const circleOffsetAngle = projectedTrackAngle + Math.PI / 2;
                const circleCenter = msfssdk.Vec2Math.add(msfssdk.Vec2Math.setFromPolar(turnRadius, circleOffsetAngle, MapTrackVectorLayer.vec2Cache[0]), projectedPlanePos, MapTrackVectorLayer.vec2Cache[0]);
                const startAngle = circleOffsetAngle + (turnRadius < 0 ? 0 : Math.PI);
                const endAngle = startAngle + angularWidthDrawn;
                display.context.arc(circleCenter[0], circleCenter[1], Math.abs(turnRadius), startAngle, endAngle, turnRadius < 0);
            }
            display.context.lineWidth = this.strokeWidth + this.outlineWidth * 2;
            display.context.strokeStyle = this.outlineStyle;
            display.context.stroke();
            display.context.lineWidth = this.strokeWidth;
            display.context.strokeStyle = this.strokeStyle;
            display.context.stroke();
            this.needUpdate = false;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.isVectorVisible) === null || _a === void 0 ? void 0 : _a.destroy();
            this.subscriptions.forEach(sub => sub.destroy());
        }
    }
    MapTrackVectorLayer.DEFAULT_STROKE_WIDTH = 2; // px
    MapTrackVectorLayer.DEFAULT_STROKE_STYLE = 'cyan';
    MapTrackVectorLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
    MapTrackVectorLayer.DEFAULT_OUTLINE_STYLE = '#505050';
    MapTrackVectorLayer.vec2Cache = [new Float64Array(2)];

    /**
     * The map layer showing highlighted waypoints.
     */
    class MapWaypointHighlightLayer extends msfssdk.MapSyncedCanvasLayer {
        constructor() {
            super(...arguments);
            this.registeredWaypoint = null;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.isInit = false;
            this.initWaypointRenderer();
            this.initModuleListener();
            this.isInit = true;
        }
        /**
         * Initializes the waypoint renderer.
         */
        initWaypointRenderer() {
            this.props.waypointRenderer.setCanvasContext(exports.MapWaypointRenderRole.Highlight, this.display.context);
        }
        /**
         * Initializes the waypoint highlight listener.
         */
        initModuleListener() {
            this.props.model.getModule(GarminMapKeys.WaypointHighlight).waypoint.sub(this.onWaypointChanged.bind(this), true);
        }
        /**
         * A callback which is called when the highlighted waypoint changes.
         * @param waypoint The new highlighted waypoint.
         */
        onWaypointChanged(waypoint) {
            this.registeredWaypoint && this.props.waypointRenderer.deregister(this.registeredWaypoint, exports.MapWaypointRenderRole.Highlight, 'waypoint-highlight-layer');
            waypoint && this.props.waypointRenderer.register(waypoint, exports.MapWaypointRenderRole.Highlight, 'waypoint-highlight-layer');
            this.registeredWaypoint = waypoint;
        }
    }

    /**
     * A map layer which displays waypoints.
     */
    class MapWaypointsLayer extends msfssdk.MapLayer {
        constructor() {
            super(...arguments);
            this.waypointsLayerRef = msfssdk.FSComponent.createRef();
            this.waypointsModule = this.props.model.getModule(msfssdk.MapSystemKeys.NearestWaypoints);
            this.waypointCache = GarminFacilityWaypointCache.getCache(this.props.bus);
            this.isAirportVisible = {
                [exports.AirportSize.Large]: false,
                [exports.AirportSize.Medium]: false,
                [exports.AirportSize.Small]: false
            };
            this.isVorVisible = false;
            this.isNdbVisible = false;
            this.isIntersectionVisible = false;
            this.isUserVisible = false;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.waypointsLayerRef.instance.onAttached();
            this.initVisibilityFlags();
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.waypointsLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            this.waypointsLayerRef.instance.onUpdated(time, elapsed);
        }
        /**
         * Initializes waypoint visibility flags and listeners.
         */
        initVisibilityFlags() {
            this.waypointsModule.airportShow[exports.AirportSize.Large].sub(this.updateAirportVisibility.bind(this, exports.AirportSize.Large), true);
            this.waypointsModule.airportShow[exports.AirportSize.Medium].sub(this.updateAirportVisibility.bind(this, exports.AirportSize.Medium), true);
            this.waypointsModule.airportShow[exports.AirportSize.Small].sub(this.updateAirportVisibility.bind(this, exports.AirportSize.Small), true);
            this.waypointsModule.vorShow.sub(this.updateVorVisibility.bind(this), true);
            this.waypointsModule.ndbShow.sub(this.updateNdbVisibility.bind(this), true);
            this.waypointsModule.intShow.sub(this.updateIntersectionVisibility.bind(this), true);
            this.waypointsModule.userShow.sub(this.updateUserVisibility.bind(this), true);
        }
        /**
         * Updates airport waypoint visibility.
         * @param size The airport size class to update.
         */
        updateAirportVisibility(size) {
            const wasAnyAirportVisible = this.isAirportVisible[exports.AirportSize.Large]
                || this.isAirportVisible[exports.AirportSize.Medium]
                || this.isAirportVisible[exports.AirportSize.Small];
            this.isAirportVisible[size] = this.waypointsModule.airportShow[size].get();
            if (!wasAnyAirportVisible && this.isAirportVisible[size]) {
                this.waypointsLayerRef.instance.tryRefreshSearch(msfssdk.FacilitySearchType.Airport, this.props.mapProjection.getCenter());
            }
        }
        /**
         * Updates VOR waypoint visibility.
         */
        updateVorVisibility() {
            this.isVorVisible = this.waypointsModule.vorShow.get();
            if (this.isVorVisible) {
                this.waypointsLayerRef.instance.tryRefreshSearch(msfssdk.FacilitySearchType.Vor, this.props.mapProjection.getCenter());
            }
        }
        /**
         * Updates NDB waypoint visibility.
         */
        updateNdbVisibility() {
            this.isNdbVisible = this.waypointsModule.ndbShow.get();
            if (this.isNdbVisible) {
                this.waypointsLayerRef.instance.tryRefreshSearch(msfssdk.FacilitySearchType.Ndb, this.props.mapProjection.getCenter());
            }
        }
        /**
         * Updates intersection waypoint visibility.
         */
        updateIntersectionVisibility() {
            this.isIntersectionVisible = this.waypointsModule.intShow.get();
            if (this.isIntersectionVisible) {
                this.waypointsLayerRef.instance.tryRefreshSearch(msfssdk.FacilitySearchType.Intersection, this.props.mapProjection.getCenter());
            }
        }
        /**
         * Updates user waypoint visibility.
         */
        updateUserVisibility() {
            this.isUserVisible = this.waypointsModule.userShow.get();
            if (this.isUserVisible) {
                this.waypointsLayerRef.instance.tryRefreshSearch(msfssdk.FacilitySearchType.User, this.props.mapProjection.getCenter());
            }
        }
        /** @inheritdoc */
        initWaypointRenderer(renderer, canvasLayer) {
            renderer.setCanvasContext(exports.MapWaypointRenderRole.Normal, canvasLayer.display.context);
            renderer.setVisibilityHandler(exports.MapWaypointRenderRole.Normal, this.isWaypointVisible.bind(this));
        }
        /**
         * Checks whether a waypoint is visible.
         * @param waypoint A waypoint.
         * @returns whether the waypoint is visible.
         */
        isWaypointVisible(waypoint) {
            if (waypoint instanceof msfssdk.FacilityWaypoint) {
                switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                    case msfssdk.FacilityType.Airport:
                        return this.isAirportVisible[waypoint.size];
                    case msfssdk.FacilityType.VOR:
                        return this.isVorVisible;
                    case msfssdk.FacilityType.NDB:
                        return this.isNdbVisible;
                    case msfssdk.FacilityType.Intersection:
                        return this.isIntersectionVisible;
                    case msfssdk.FacilityType.USR:
                        return this.isUserVisible;
                }
            }
            return false;
        }
        /** @inheritdoc */
        shouldRefreshSearch(type) {
            switch (type) {
                case msfssdk.FacilitySearchType.Airport:
                    return this.isAirportVisible[exports.AirportSize.Large] || this.isAirportVisible[exports.AirportSize.Medium] || this.isAirportVisible[exports.AirportSize.Small];
                case msfssdk.FacilitySearchType.Vor:
                    return this.isVorVisible;
                case msfssdk.FacilitySearchType.Ndb:
                    return this.isNdbVisible;
                case msfssdk.FacilitySearchType.Intersection:
                    return this.isIntersectionVisible;
                case msfssdk.FacilitySearchType.User:
                    return this.isUserVisible;
            }
        }
        /** @inheritdoc */
        registerWaypointWithRenderer(renderer, facility) {
            const waypoint = this.waypointCache.get(facility);
            renderer.register(waypoint, exports.MapWaypointRenderRole.Normal, 'waypoints-layer');
        }
        /** @inheritdoc */
        deregisterWaypointWithRenderer(renderer, facility) {
            const waypoint = this.waypointCache.get(facility);
            renderer.deregister(waypoint, exports.MapWaypointRenderRole.Normal, 'waypoints-layer');
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.MapNearestWaypointsLayer, { ref: this.waypointsLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: (waypoint, renderer) => { renderer.register(waypoint, exports.MapWaypointRenderRole.Normal, 'waypoints-layer'); }, deregisterWaypoint: (waypoint, renderer) => { renderer.deregister(waypoint, exports.MapWaypointRenderRole.Normal, 'waypoints-layer'); }, searchItemLimit: (type) => MapWaypointsLayer.SEARCH_ITEM_LIMITS[type], shouldRefreshSearch: this.shouldRefreshSearch.bind(this) }));
        }
    }
    MapWaypointsLayer.SEARCH_ITEM_LIMITS = {
        [msfssdk.FacilitySearchType.Airport]: 500,
        [msfssdk.FacilitySearchType.Vor]: 250,
        [msfssdk.FacilitySearchType.Ndb]: 250,
        [msfssdk.FacilitySearchType.Intersection]: 500,
        [msfssdk.FacilitySearchType.User]: 100
    };

    /**
     * A map layer which displays inner and outer range rings for traffic maps.
     */
    class TrafficMapRangeLayer extends msfssdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            super(...arguments);
            this.tickLayerRef = msfssdk.FSComponent.createRef();
            this.innerRangeLayerRef = msfssdk.FSComponent.createRef();
            this.outerRangeLayerRef = msfssdk.FSComponent.createRef();
            this.outerStrokeWidth = (_a = this.props.outerStrokeWidth) !== null && _a !== void 0 ? _a : TrafficMapRangeLayer.DEFAULT_STROKE_WIDTH;
            this.outerStrokeStyle = (_b = this.props.outerStrokeStyle) !== null && _b !== void 0 ? _b : TrafficMapRangeLayer.DEFAULT_STROKE_STYLE;
            this.outerStrokeDash = (_c = this.props.outerStrokeDash) !== null && _c !== void 0 ? _c : TrafficMapRangeLayer.DEFAULT_STROKE_DASH;
            this.innerStrokeWidth = (_d = this.props.innerStrokeWidth) !== null && _d !== void 0 ? _d : TrafficMapRangeLayer.DEFAULT_STROKE_WIDTH;
            this.innerStrokeStyle = (_e = this.props.innerStrokeStyle) !== null && _e !== void 0 ? _e : TrafficMapRangeLayer.DEFAULT_STROKE_STYLE;
            this.innerStrokeDash = (_f = this.props.innerStrokeDash) !== null && _f !== void 0 ? _f : TrafficMapRangeLayer.DEFAULT_STROKE_DASH;
            this.tickColor = (_g = this.props.tickColor) !== null && _g !== void 0 ? _g : TrafficMapRangeLayer.DEFAULT_TICK_COLOR;
            this.outerMajorTickSize = (_h = this.props.outerMajorTickSize) !== null && _h !== void 0 ? _h : TrafficMapRangeLayer.DEFAULT_MAJOR_TICK_SIZE;
            this.outerMinorTickSize = (_j = this.props.outerMinorTickSize) !== null && _j !== void 0 ? _j : TrafficMapRangeLayer.DEFAULT_MINOR_TICK_SIZE;
            this.innerMajorTickSize = (_k = this.props.innerMajorTickSize) !== null && _k !== void 0 ? _k : TrafficMapRangeLayer.DEFAULT_MAJOR_TICK_SIZE;
            this.innerMinorTickSize = (_l = this.props.innerMinorTickSize) !== null && _l !== void 0 ? _l : TrafficMapRangeLayer.DEFAULT_MINOR_TICK_SIZE;
            this.rangeModule = this.props.model.getModule(GarminMapKeys.Range);
            this.trafficModule = this.props.model.getModule(GarminMapKeys.Traffic);
            this.innerRange = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(0));
            this.outerRange = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(0));
            this.innerLabel = null;
            this.outerLabel = null;
            this.needUpdateRings = false;
        }
        /** @inheritdoc */
        onAttached() {
            this.tickLayerRef.instance.onAttached();
            this.innerRangeLayerRef.instance.onAttached();
            this.outerRangeLayerRef.instance.onAttached();
            this.initLabels();
            this.initStyles();
            this.initModuleListeners();
            this.innerRange.sub(() => { this.needUpdateRings = true; });
            this.outerRange.sub(() => { this.needUpdateRings = true; });
            this.needUpdateRings = true;
        }
        /**
         * Initializes the range display labels.
         */
        initLabels() {
            const displayUnit = msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            if (this.props.innerLabelRadial !== null && this.props.innerLabelRadial !== undefined) {
                this.innerLabel = this.innerRangeLayerRef.instance.createLabel(this.props.renderLabel !== undefined
                    ? this.props.renderLabel(this.innerRange, displayUnit)
                    : (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { range: this.innerRange, displayUnit: displayUnit })));
                this.innerLabel.setAnchor(new Float64Array([0.5, 0.5]));
                this.innerLabel.setRadialAngle(this.props.innerLabelRadial * Avionics.Utils.DEG2RAD);
            }
            if (this.props.outerLabelRadial !== null && this.props.outerLabelRadial !== undefined) {
                this.outerLabel = this.outerRangeLayerRef.instance.createLabel(this.props.renderLabel !== undefined
                    ? this.props.renderLabel(this.outerRange, displayUnit)
                    : (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { range: this.outerRange, displayUnit: displayUnit })));
                this.outerLabel.setAnchor(new Float64Array([0.5, 0.5]));
                this.outerLabel.setRadialAngle(this.props.outerLabelRadial * Avionics.Utils.DEG2RAD);
            }
        }
        /**
         * Initializes ring styles.
         */
        initStyles() {
            this.tickLayerRef.instance.display.context.fillStyle = this.tickColor;
            this.innerRangeLayerRef.instance.setRingStrokeStyles(this.innerStrokeWidth, this.innerStrokeStyle, this.innerStrokeDash);
            this.outerRangeLayerRef.instance.setRingStrokeStyles(this.outerStrokeWidth, this.outerStrokeStyle, this.outerStrokeDash);
        }
        /**
         * Initializes modules listeners.
         */
        initModuleListeners() {
            const innerRangeCallback = this.updateInnerRange.bind(this);
            const outerRangeCallback = this.updateOuterRange.bind(this);
            this.rangeModule.nominalRanges.sub(innerRangeCallback);
            this.rangeModule.nominalRanges.sub(outerRangeCallback);
            this.trafficModule.innerRangeIndex.sub(innerRangeCallback, true);
            this.trafficModule.outerRangeIndex.sub(outerRangeCallback, true);
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.tickLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.innerRangeLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.outerRangeLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.MapProjectionChangeType.ProjectedSize)) {
                // Need to reset the canvas context fill style because a resize will wipe its state.
                this.tickLayerRef.instance.display.context.fillStyle = this.tickColor;
            }
            this.needUpdateRings = msfssdk.BitFlags.isAny(changeFlags, msfssdk.MapProjectionChangeType.TargetProjected | msfssdk.MapProjectionChangeType.ProjectedResolution);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            this.tickLayerRef.instance.onUpdated(time, elapsed);
            if (this.needUpdateRings) {
                this.updateRings();
                this.needUpdateRings = false;
            }
            this.innerRangeLayerRef.instance.onUpdated(time, elapsed);
            this.outerRangeLayerRef.instance.onUpdated(time, elapsed);
        }
        /**
         * Updates the rings.
         */
        updateRings() {
            const center = this.props.mapProjection.getTargetProjected();
            const innerRadius = this.innerRange.get().asUnit(msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const outerRadius = this.outerRange.get().asUnit(msfssdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            if (innerRadius > 0) {
                this.innerRangeLayerRef.instance.setVisible(true);
                this.innerRangeLayerRef.instance.setRingPosition(center, innerRadius);
            }
            else {
                this.innerRangeLayerRef.instance.setVisible(false);
            }
            if (outerRadius > 0) {
                this.outerRangeLayerRef.instance.setVisible(true);
                this.outerRangeLayerRef.instance.setRingPosition(center, outerRadius);
            }
            else {
                this.outerRangeLayerRef.instance.setVisible(false);
            }
            this.updateTicks(center, innerRadius, outerRadius);
        }
        /**
         * Updates the ring tick marks.
         * @param center The projected center of the rings.
         * @param innerRadius The radius of the inner ring, in pixels.
         * @param outerRadius The radius of the outer ring, in pixels.
         */
        updateTicks(center, innerRadius, outerRadius) {
            const display = this.tickLayerRef.instance.display;
            display.clear();
            if (innerRadius > 0) {
                this.drawTicks(display.context, center, innerRadius, this.innerMajorTickSize, this.innerMinorTickSize);
            }
            if (outerRadius > 0) {
                this.drawTicks(display.context, center, outerRadius, this.outerMajorTickSize, this.outerMinorTickSize);
            }
        }
        /**
         * Draws ring ticks to a canvas. One major tick is drawn at each of the four cardinal positions, and one minor tick
         * is drawn at each of the eight remaining hour positions.
         * @param context A canvas 2D rendering context.
         * @param center The projected center of the outer ring.
         * @param radius The radius of the ring, in pixels.
         * @param majorTickSize The size of each major tick, in pixels.
         * @param minorTickSize The size of each minor tick, in pixels.
         */
        drawTicks(context, center, radius, majorTickSize, minorTickSize) {
            const step = Math.PI / 6;
            for (let i = 0; i < 12; i++) {
                const pos = msfssdk.Vec2Math.setFromPolar(radius, i * step, TrafficMapRangeLayer.vec2Cache[0]);
                this.drawTick(context, center[0] + pos[0], center[1] + pos[1], i % 3 === 0 ? majorTickSize : minorTickSize);
            }
        }
        /**
         * Draws a tick to a canvas.
         * @param context A canvas 2D rendering context.
         * @param x The x-coordinate of the center of the tick.
         * @param y The y-coordinate of the center of the tick.
         * @param size The size of the tick, in pixels.
         */
        drawTick(context, x, y, size) {
            context.fillRect(x - size / 2, y - size / 2, size, size);
        }
        /**
         * Updates the inner ring range.
         */
        updateInnerRange() {
            const range = this.rangeModule.nominalRanges.get()[this.trafficModule.innerRangeIndex.get()];
            this.innerRange.set(range !== null && range !== void 0 ? range : 0);
        }
        /**
         * Updates the outer ring range.
         */
        updateOuterRange() {
            const range = this.rangeModule.nominalRanges.get()[this.trafficModule.outerRangeIndex.get()];
            this.outerRange.set(range !== null && range !== void 0 ? range : 0);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", null,
                msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { ref: this.tickLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
                msfssdk.FSComponent.buildComponent(msfssdk.MapLabeledRingLayer, { ref: this.innerRangeLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
                msfssdk.FSComponent.buildComponent(msfssdk.MapLabeledRingLayer, { ref: this.outerRangeLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
        }
    }
    TrafficMapRangeLayer.DEFAULT_STROKE_WIDTH = 2;
    TrafficMapRangeLayer.DEFAULT_STROKE_STYLE = 'white';
    TrafficMapRangeLayer.DEFAULT_STROKE_DASH = [4, 4];
    TrafficMapRangeLayer.DEFAULT_TICK_COLOR = 'white';
    TrafficMapRangeLayer.DEFAULT_MAJOR_TICK_SIZE = 10;
    TrafficMapRangeLayer.DEFAULT_MINOR_TICK_SIZE = 5;
    TrafficMapRangeLayer.vec2Cache = [new Float64Array(2)];

    var AirspaceRenderType;
    (function (AirspaceRenderType) {
        AirspaceRenderType[AirspaceRenderType["BlueSingle"] = 0] = "BlueSingle";
        AirspaceRenderType[AirspaceRenderType["MaroonSingle"] = 1] = "MaroonSingle";
        AirspaceRenderType[AirspaceRenderType["BlueDashed"] = 2] = "BlueDashed";
        AirspaceRenderType[AirspaceRenderType["BlueCombed"] = 3] = "BlueCombed";
        AirspaceRenderType[AirspaceRenderType["MaroonCombed"] = 4] = "MaroonCombed";
        AirspaceRenderType[AirspaceRenderType["Null"] = 5] = "Null";
    })(AirspaceRenderType || (AirspaceRenderType = {}));
    /**
     * Renders airspace boundaries with a comb-like pattern.
     */
    class CombedAirspaceRenderer extends msfssdk.MapMultiLineAirspaceRenderer {
        /**
         * Constructor.
         * @param color The color of the rendered airspace.
         * @param baseLineWidth The stroke width of the base line that is drawn on the airspace boundary.
         * @param isTeethOutside Whether the teeth should appear on the outside of the boundary.
         * @param teethWidth The width of the teeth.
         * @param teethDash The dash of the teeth.
         */
        constructor(color, baseLineWidth, isTeethOutside, teethWidth, teethDash) {
            super();
            this.color = color;
            this.baseLineWidth = baseLineWidth;
            this.isTeethOutside = isTeethOutside;
            this.teethWidth = teethWidth;
            this.teethDash = teethDash;
        }
        /** @inheritdoc */
        renderLines(shape, context, stream) {
            // render base line
            shape.renderLine(context, 0, this.baseLineWidth, this.color, CombedAirspaceRenderer.emptyDash, stream);
            // render teeth
            shape.renderLine(context, this.teethWidth / 2 * (this.isTeethOutside ? 1 : -1), this.teethWidth, this.color, this.teethDash, stream);
        }
    }
    CombedAirspaceRenderer.emptyDash = [];
    /**
     * Utility class containing functions defining the rendering behavior of airspaces for Garmin maps.
     */
    class MapAirspaceRendering {
        /**
         * Determines the rendering order of airspaces for Garmin maps.
         * @returns The relative rendering order of two airspaces for Garmin maps.
         */
        static renderOrder() {
            return 0;
        }
        /**
         * Selects airspace renderers for Garmin maps.
         * @param airspace The airspace to render.
         * @returns The renderer to use to render the specified airspace.
         */
        static selectRenderer(airspace) {
            switch (airspace.facility.type) {
                case msfssdk.BoundaryType.ClassB:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.BlueSingle];
                case msfssdk.BoundaryType.ClassC:
                case msfssdk.BoundaryType.ClassE:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.MaroonSingle];
                case msfssdk.BoundaryType.ClassD:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.BlueDashed];
                case msfssdk.BoundaryType.Restricted:
                case msfssdk.BoundaryType.Prohibited:
                case msfssdk.BoundaryType.Warning:
                case msfssdk.BoundaryType.Danger:
                case msfssdk.BoundaryType.Training:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.BlueCombed];
                case msfssdk.BoundaryType.MOA:
                case msfssdk.BoundaryType.Alert:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.MaroonCombed];
                default:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.Null];
            }
        }
    }
    MapAirspaceRendering.RENDERERS = {
        [AirspaceRenderType.BlueSingle]: new msfssdk.MapSingleLineAirspaceRenderer(1.5, '#3080ff', []),
        [AirspaceRenderType.MaroonSingle]: new msfssdk.MapSingleLineAirspaceRenderer(1.5, '#4a0045', []),
        [AirspaceRenderType.BlueDashed]: new msfssdk.MapSingleLineAirspaceRenderer(1.5, '#3080ff', [5, 5]),
        [AirspaceRenderType.BlueCombed]: new CombedAirspaceRenderer('#3080ff', 1.5, false, 6, [1.5, 2.5]),
        [AirspaceRenderType.MaroonCombed]: new CombedAirspaceRenderer('#4a0045', 1.5, false, 6, [1.5, 2.5]),
        [AirspaceRenderType.Null]: new msfssdk.NullAirspaceRenderer(),
    };

    /**
     * Types of Garmin traffic systems.
     */
    exports.TrafficSystemType = void 0;
    (function (TrafficSystemType) {
        TrafficSystemType["Tis"] = "TIS";
        TrafficSystemType["Tas"] = "TAS";
        TrafficSystemType["TcasII"] = "TCAS-II";
    })(exports.TrafficSystemType || (exports.TrafficSystemType = {}));

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
     */
    class MapTrafficIntruderIcon extends msfssdk.AbstractMapTrafficIntruderIcon {
        /**
         * Constructor.
         * @param intruder This view's associated intruder.
         * @param trafficModule The traffic module for this icon's parent map.
         * @param ownshipModule The own airplane properties module for this icon's parent map.
         * @param garminTrafficModule The Garmin traffic module for this icon's parent map.
         * @param followAirplaneModule The follow airplane module for this icon's parent map.
         * @param options Configuration options for this icon.
         */
        constructor(intruder, trafficModule, ownshipModule, garminTrafficModule, followAirplaneModule, options) {
            super(intruder, trafficModule, ownshipModule);
            this.garminTrafficModule = garminTrafficModule;
            this.followAirplaneModule = followAirplaneModule;
            this.options = options;
            this.supportTisVector = this.garminTrafficModule.trafficSystem.type === exports.TrafficSystemType.Tis;
        }
        /** @inheritdoc */
        drawIcon(projection, context, projectedPos, isOffScale) {
            const alertLevel = this.intruder.alertLevel.get();
            const isTARA = alertLevel === msfssdk.TcasAlertLevel.TrafficAdvisory || alertLevel === msfssdk.TcasAlertLevel.ResolutionAdvisory;
            if (isOffScale && (!this.options.drawOffScale || !isTARA)) {
                return;
            }
            if (!isTARA
                && (this.intruder.relativePositionVec[2] > this.trafficModule.altitudeRestrictionAbove.get().asUnit(msfssdk.UnitType.METER)
                    || this.intruder.relativePositionVec[2] < -this.trafficModule.altitudeRestrictionBelow.get().asUnit(msfssdk.UnitType.METER))) {
                return;
            }
            context.translate(projectedPos[0], projectedPos[1]);
            if (this.garminTrafficModule.showIntruderLabel.get()) {
                this.drawIconVSArrow(context, alertLevel);
                this.drawIconAltitudeLabel(context, alertLevel);
            }
            const isAdsbActive = this.garminTrafficModule.adsbOperatingMode.get() !== msfssdk.AdsbOperatingMode.Standby;
            if (this.options.supportAdsbVector && isAdsbActive) {
                this.drawAdsbMotionVector(context, projection);
            }
            else if (this.supportTisVector) {
                this.drawTisMotionVector(context, projection);
            }
            if (isAdsbActive) {
                this.drawArrowIcon(context, projection, projectedPos, isOffScale, alertLevel);
            }
            else {
                this.drawNoArrowIcon(context, projection, projectedPos, isOffScale, alertLevel);
            }
            context.resetTransform();
        }
        /**
         * Draws the icon without a directional arrow display.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param projectedPos The projected position of the intruder.
         * @param isOffScale Whether the intruder is off-scale.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawNoArrowIcon(context, projection, projectedPos, isOffScale, alertLevel) {
            context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    this.drawDiamondIcon(context, alertLevel === msfssdk.TcasAlertLevel.ProximityAdvisory);
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    this.drawCircleIcon(context, projection, projectedPos, isOffScale);
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    this.drawSquareIcon(context, projection, projectedPos, isOffScale);
                    break;
            }
        }
        /**
         * Draws a diamond icon.
         * @param context The canvas rendering context to which to draw the icon.
         * @param isFilled Whether the diamond should be filled.
         */
        drawDiamondIcon(context, isFilled) {
            const size = 0.35 * this.options.iconSize;
            context.beginPath();
            context.moveTo(0, -size);
            context.lineTo(size, 0);
            context.lineTo(0, size);
            context.lineTo(-size, 0);
            context.closePath();
            context.strokeStyle = 'black';
            context.lineWidth = Math.max(1, 0.05 * this.options.iconSize);
            context.fillStyle = 'white';
            context.fill();
            context.stroke();
            if (!isFilled) {
                context.beginPath();
                context.moveTo(0, -size * 0.6);
                context.lineTo(size * 0.6, 0);
                context.lineTo(0, size * 0.6);
                context.lineTo(-size * 0.6, 0);
                context.closePath();
                context.fillStyle = 'black';
                context.fill();
            }
        }
        /**
         * Draws a circle icon for TAs.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param projectedPos The projected position of the intruder.
         * @param isOffScale Whether the intruder is off-scale.
         */
        drawCircleIcon(context, projection, projectedPos, isOffScale) {
            context.beginPath();
            context.arc(0, 0, 0.35 * this.options.iconSize, 0, msfssdk.MathUtils.TWO_PI);
            context.strokeStyle = 'black';
            context.lineWidth = Math.max(1, 0.05 * this.options.iconSize);
            context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
            context.fill();
            context.stroke();
            if (isOffScale) {
                const projectedAngle = msfssdk.Vec2Math.theta(msfssdk.Vec2Math.sub(projectedPos, projection.getTargetProjected(), MapTrafficIntruderIcon.vec2Cache[0]));
                context.beginPath();
                context.arc(0, 0, 0.35 * this.options.iconSize, projectedAngle - msfssdk.MathUtils.HALF_PI, projectedAngle + msfssdk.MathUtils.HALF_PI);
                context.closePath();
                context.fillStyle = MapTrafficIntruderIcon.TA_OFFSCALE_COLOR;
                context.fill();
                context.stroke();
            }
        }
        /**
         * Draws a square icon for RAs.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param projectedPos The projected position of the intruder.
         * @param isOffScale Whether the intruder is off-scale.
         */
        drawSquareIcon(context, projection, projectedPos, isOffScale) {
            const size = 0.35 * this.options.iconSize;
            context.beginPath();
            context.moveTo(-size, -size);
            context.lineTo(size, -size);
            context.lineTo(size, size);
            context.lineTo(-size, size);
            context.closePath();
            context.strokeStyle = 'black';
            context.lineWidth = Math.max(1, 0.05 * this.options.iconSize);
            context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
            context.fill();
            context.stroke();
            if (isOffScale) {
                context.save();
                context.clip();
                const projectedAngle = msfssdk.Vec2Math.theta(msfssdk.Vec2Math.sub(projectedPos, projection.getTargetProjected(), MapTrafficIntruderIcon.vec2Cache[0]));
                context.beginPath();
                context.arc(0, 0, this.options.iconSize, projectedAngle - msfssdk.MathUtils.HALF_PI, projectedAngle + msfssdk.MathUtils.HALF_PI);
                context.closePath();
                context.fillStyle = MapTrafficIntruderIcon.RA_OFFSCALE_COLOR;
                context.fill();
                context.stroke();
                context.restore();
            }
        }
        /**
         * Draws the icon with a directional arrow display.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param projectedPos The projected position of the intruder.
         * @param isOffScale Whether the intruder is off-scale.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawArrowIcon(context, projection, projectedPos, isOffScale, alertLevel) {
            context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
            this.drawArrowIconBackground(context, projection, projectedPos, isOffScale, alertLevel);
            this.drawIconArrow(context, projection, alertLevel);
        }
        /**
         * Draws the icon's background when it has a directional arrow display.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param projectedPos The projected position of the intruder.
         * @param isOffScale Whether the intruder is off-scale.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawArrowIconBackground(context, projection, projectedPos, isOffScale, alertLevel) {
            if (alertLevel === msfssdk.TcasAlertLevel.None || alertLevel === msfssdk.TcasAlertLevel.ProximityAdvisory) {
                return;
            }
            context.strokeStyle = '#1a1d21';
            context.lineWidth = Math.max(1, 0.05 * this.options.iconSize);
            context.fillStyle = alertLevel === msfssdk.TcasAlertLevel.ResolutionAdvisory ? MapTrafficIntruderIcon.RA_COLOR : MapTrafficIntruderIcon.TA_COLOR;
            context.beginPath();
            context.arc(0, 0, 0.45 * this.options.iconSize, 0, msfssdk.MathUtils.TWO_PI);
            context.fill();
            context.stroke();
            if (isOffScale) {
                const projectedAngle = msfssdk.Vec2Math.theta(msfssdk.Vec2Math.sub(projectedPos, projection.getTargetProjected(), MapTrafficIntruderIcon.vec2Cache[0]));
                context.beginPath();
                context.arc(0, 0, 0.45 * this.options.iconSize, projectedAngle - msfssdk.MathUtils.HALF_PI, projectedAngle + msfssdk.MathUtils.HALF_PI);
                context.fillStyle = 'black';
                context.fill();
            }
        }
        /**
         * Draws the icon's directional arrow.
         * @param context The canvas rendering context to which to draw the icon.
         * @param projection The map projection.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawIconArrow(context, projection, alertLevel) {
            context.save();
            context.rotate(this.intruder.groundTrack * Avionics.Utils.DEG2RAD + projection.getRotation());
            this.drawIconArrowBackground(context, alertLevel);
            this.drawIconArrowOutline(context, alertLevel);
            context.restore();
        }
        /**
         * Draws the icon's directional arrow background.
         * @param context The canvas rendering context to which to draw the icon.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawIconArrowBackground(context, alertLevel) {
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    context.fillStyle = 'black';
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
                    break;
            }
            context.beginPath();
            context.moveTo(0, -0.3 * this.options.iconSize * 1.4);
            context.lineTo(0.212 * this.options.iconSize * 1.4, 0.212 * this.options.iconSize * 1.4);
            context.lineTo(0, 0.1 * this.options.iconSize * 1.4);
            context.lineTo(-0.212 * this.options.iconSize * 1.4, 0.212 * this.options.iconSize * 1.4);
            context.closePath();
            context.fill();
        }
        /**
         * Draws the icon's directional arrow outline.
         * @param context The canvas rendering context to which to draw the icon.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawIconArrowOutline(context, alertLevel) {
            context.lineWidth = Math.max(1, this.options.iconSize * 0.05);
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                    context.strokeStyle = 'white';
                    context.fillStyle = 'black';
                    break;
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    context.strokeStyle = 'transparent';
                    context.fillStyle = 'white';
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    context.strokeStyle = 'black';
                    context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    context.strokeStyle = 'black';
                    context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
                    break;
            }
            context.beginPath();
            context.moveTo(0, -0.3 * this.options.iconSize);
            context.lineTo(0.212 * this.options.iconSize, 0.212 * this.options.iconSize);
            context.lineTo(0, 0.1 * this.options.iconSize);
            context.lineTo(-0.212 * this.options.iconSize, 0.212 * this.options.iconSize);
            context.closePath();
            context.fill();
            context.stroke();
        }
        /**
         * Draws the icon's vertical speed indicator arrow.
         * @param context The canvas rendering context to which to draw the icon.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawIconVSArrow(context, alertLevel) {
            const showArrow = MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), msfssdk.UnitType.MPS) <= 0;
            if (!showArrow) {
                return;
            }
            const vsSign = Math.sign(this.intruder.velocityVec[2]);
            context.beginPath();
            context.moveTo(0.67 * this.options.iconSize, -0.16 * this.options.iconSize * vsSign);
            context.lineTo(0.67 * this.options.iconSize, 0.16 * this.options.iconSize * vsSign);
            context.moveTo(0.55 * this.options.iconSize, -0.04 * this.options.iconSize * vsSign);
            context.lineTo(0.67 * this.options.iconSize, -0.18 * this.options.iconSize * vsSign);
            context.lineTo(0.79 * this.options.iconSize, -0.04 * this.options.iconSize * vsSign);
            context.lineWidth = Math.max(1, this.options.iconSize * 0.125);
            context.strokeStyle = 'black';
            context.stroke();
            context.lineWidth = Math.max(1, this.options.iconSize * 0.075);
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    context.strokeStyle = 'white';
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    context.strokeStyle = MapTrafficIntruderIcon.TA_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    context.strokeStyle = MapTrafficIntruderIcon.RA_COLOR;
                    break;
            }
            context.stroke();
        }
        /**
         * Draws the icon's altitude label.
         * @param context The canvas rendering context to which to draw the icon.
         * @param alertLevel The alert level assigned to this view's intruder.
         */
        drawIconAltitudeLabel(context, alertLevel) {
            const isRelative = this.trafficModule.isAltitudeRelative.get();
            const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
            const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
                ? msfssdk.UnitType.METER.convertTo(this.intruder.relativePositionVec[2], msfssdk.UnitType.FOOT)
                : this.intruder.altitude.asUnit(msfssdk.UnitType.FOOT);
            const altitudeRounded = Math.round(altitudeFeet / 100);
            const altitudeAbs = Math.abs(altitudeRounded);
            const prefix = altitudeRounded < 0 ? ''
                : isRelative ? '+' : '';
            const altitudeText = `${prefix}${altitudeAbs}`;
            const textWidth = context.measureText(altitudeText).width;
            const textHeight = this.options.fontSize;
            // draw background
            context.fillStyle = 'black';
            if (isAltitudeAbove) {
                context.fillRect(-textWidth / 2 - 2, -0.5 * this.options.iconSize - textHeight - 2, textWidth + 4, textHeight + 2);
            }
            else {
                context.fillRect(-textWidth / 2 - 2, 0.5 * this.options.iconSize, textWidth + 4, textHeight + 2);
            }
            // draw text
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    context.fillStyle = 'white';
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
                    break;
            }
            if (isAltitudeAbove) {
                context.textBaseline = 'bottom';
                context.fillText(altitudeText, 0, -0.5 * this.options.iconSize);
            }
            else {
                context.textBaseline = 'top';
                context.fillText(altitudeText, 0, 0.5 * this.options.iconSize);
            }
        }
        /**
         * Draws a TIS motion vector for this icon.
         * @param context The canvas rendering context to which to draw the vector.
         * @param projection The map projection.
         */
        drawTisMotionVector(context, projection) {
            let color;
            const alertLevel = this.intruder.alertLevel.get();
            switch (alertLevel) {
                case msfssdk.TcasAlertLevel.None:
                case msfssdk.TcasAlertLevel.ProximityAdvisory:
                    color = MapTrafficIntruderIcon.VECTOR_ABS_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.TrafficAdvisory:
                    color = MapTrafficIntruderIcon.TA_COLOR;
                    break;
                case msfssdk.TcasAlertLevel.ResolutionAdvisory:
                    color = MapTrafficIntruderIcon.RA_COLOR;
                    break;
            }
            const vector = this.intruder.velocityVec;
            const vectorDir = msfssdk.Vec2Math.theta(vector);
            const vectorMag = msfssdk.Vec2Math.abs(vector);
            const roundedVector = msfssdk.Vec2Math.setFromPolar(vectorMag, Math.round(vectorDir / MapTrafficIntruderIcon.TIS_VECTOR_DIR_PRECISION) * MapTrafficIntruderIcon.TIS_VECTOR_DIR_PRECISION, MapTrafficIntruderIcon.vec2Cache[0]);
            this.drawLookaheadVector(projection, context, color, roundedVector, MapTrafficIntruderIcon.TIS_VECTOR_LOOKAHEAD);
        }
        /**
         * Draws an ADS-B motion vector for this icon.
         * @param context The canvas rendering context to which to draw the vector.
         * @param projection The map projection.
         */
        drawAdsbMotionVector(context, projection) {
            const vectorMode = this.garminTrafficModule.motionVectorMode.get();
            if (vectorMode === exports.MapTrafficMotionVectorMode.Off) {
                return;
            }
            const vector = vectorMode === exports.MapTrafficMotionVectorMode.Absolute || !this.followAirplaneModule.isFollowing.get()
                ? this.intruder.velocityVec
                : this.intruder.relativeVelocityVec;
            const alertLevel = this.intruder.alertLevel.get();
            if (alertLevel === msfssdk.TcasAlertLevel.None || alertLevel === msfssdk.TcasAlertLevel.ProximityAdvisory) {
                this.drawLookaheadVector(projection, context, vectorMode === exports.MapTrafficMotionVectorMode.Absolute
                    ? MapTrafficIntruderIcon.VECTOR_ABS_COLOR
                    : MapTrafficIntruderIcon.VECTOR_REL_COLOR, vector, this.garminTrafficModule.motionVectorLookahead.get().asUnit(msfssdk.UnitType.SECOND));
            }
            else {
                let prediction, color;
                if (alertLevel === msfssdk.TcasAlertLevel.ResolutionAdvisory) {
                    prediction = this.intruder.tcaRA;
                    color = MapTrafficIntruderIcon.RA_COLOR;
                }
                else {
                    prediction = this.intruder.tcaTA;
                    color = MapTrafficIntruderIcon.TA_COLOR;
                }
                this.drawTCAVector(projection, context, prediction, color, vector);
            }
        }
        /**
         * Draws a motion vector projected to a certain lookahead time.
         * @param projection The map projection.
         * @param context The canvas rendering context to which to draw the vector.
         * @param color The color of the vector.
         * @param vector The vector to draw.
         * @param lookaheadTime The lookahead time, in seconds.
         */
        drawLookaheadVector(projection, context, color, vector, lookaheadTime) {
            context.lineWidth = MapTrafficIntruderIcon.VECTOR_STROKE_WIDTH;
            context.strokeStyle = color;
            context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
            context.beginPath();
            const distance = msfssdk.Vec2Math.abs(vector) * lookaheadTime;
            const distanceView = distance / msfssdk.UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), msfssdk.UnitType.METER);
            const track = -msfssdk.Vec2Math.theta(vector);
            const angle = track + projection.getRotation();
            const end = msfssdk.Vec2Math.setFromPolar(distanceView, angle, MapTrafficIntruderIcon.vec2Cache[1]);
            context.moveTo(0, 0);
            context.lineTo(end[0], end[1]);
            context.stroke();
        }
        /**
         * Draws a motion vector projected to TCA.
         * @param projection The map projection.
         * @param context The canvas rendering context to which to draw the vector.
         * @param prediction The TCA prediction to use.
         * @param color The color of the vector.
         * @param vector The vector to draw.
         */
        drawTCAVector(projection, context, prediction, color, vector) {
            const distanceToEnd = msfssdk.Vec2Math.abs(projection.getProjectedSize());
            if (distanceToEnd > 0) {
                context.lineWidth = MapTrafficIntruderIcon.VECTOR_STROKE_WIDTH;
                context.strokeStyle = color;
                context.setLineDash(MapTrafficIntruderIcon.VECTOR_LINE_DASH);
                context.beginPath();
                const track = -msfssdk.Vec2Math.theta(vector);
                const angle = track + projection.getRotation();
                const end = msfssdk.Vec2Math.setFromPolar(distanceToEnd, angle, MapTrafficIntruderIcon.vec2Cache[1]);
                context.moveTo(0, 0);
                context.lineTo(end[0], end[1]);
                context.stroke();
                context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
                const distanceToTCA = msfssdk.Vec2Math.abs(vector) * prediction.tca.asUnit(msfssdk.UnitType.SECOND);
                const distanceToTCAProjected = distanceToTCA / msfssdk.UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), msfssdk.UnitType.METER);
                if (distanceToTCAProjected > 0) {
                    context.beginPath();
                    const tca = msfssdk.Vec2Math.setFromPolar(distanceToTCAProjected, angle, MapTrafficIntruderIcon.vec2Cache[1]);
                    context.moveTo(0, 0);
                    context.lineTo(tca[0], tca[1]);
                    context.stroke();
                }
            }
        }
    }
    MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD = msfssdk.UnitType.FPM.createNumber(500);
    MapTrafficIntruderIcon.TA_COLOR = '#ffff00';
    MapTrafficIntruderIcon.TA_OFFSCALE_COLOR = '#454500';
    MapTrafficIntruderIcon.RA_COLOR = 'red';
    MapTrafficIntruderIcon.RA_OFFSCALE_COLOR = '#450000';
    MapTrafficIntruderIcon.TIS_VECTOR_DIR_PRECISION = 45 * Avionics.Utils.DEG2RAD;
    MapTrafficIntruderIcon.TIS_VECTOR_LOOKAHEAD = 60; // seconds
    MapTrafficIntruderIcon.VECTOR_STROKE_WIDTH = 2;
    MapTrafficIntruderIcon.VECTOR_ABS_COLOR = 'white';
    MapTrafficIntruderIcon.VECTOR_REL_COLOR = '#4ecc3d';
    MapTrafficIntruderIcon.VECTOR_LINE_DASH = [5, 5];
    MapTrafficIntruderIcon.EMPTY_LINE_DASH = [];
    MapTrafficIntruderIcon.vec2Cache = [msfssdk.Vec2Math.create(), msfssdk.Vec2Math.create()];

    exports.MapTrafficOffScaleStatus = void 0;
    (function (MapTrafficOffScaleStatus) {
        MapTrafficOffScaleStatus[MapTrafficOffScaleStatus["None"] = 0] = "None";
        MapTrafficOffScaleStatus[MapTrafficOffScaleStatus["TA"] = 1] = "TA";
        MapTrafficOffScaleStatus[MapTrafficOffScaleStatus["RA"] = 2] = "RA";
    })(exports.MapTrafficOffScaleStatus || (exports.MapTrafficOffScaleStatus = {}));

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * An airport icon.
     */
    class MapAirportIcon extends msfssdk.MapWaypointSpriteIcon {
        /**
         * Constructor.
         * @param waypoint The waypoint associated with this icon.
         * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
         * with lower priorities.
         * @param img The image to use for the icon.
         * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
         * @param options Options with which to initialize this icon.
         */
        constructor(waypoint, priority, img, size, options) {
            super(waypoint, priority, img, 32, 32, size, options);
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        getSpriteFrame(mapProjection) {
            if (!this.waypoint.longestRunway) {
                return 0;
            }
            const mapRotationDeg = mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
            return Math.round(msfssdk.NavMath.normalizeHeading((this.waypoint.longestRunway.direction + mapRotationDeg)) / 22.5) % 8;
        }
    }
    /**
     * An icon for a highlighted waypoint. This icon embellishes a pre-existing ("base") icon with a surrounding ring and
     * background.
     */
    class MapWaypointHighlightIcon extends msfssdk.AbstractMapWaypointIcon {
        /**
         * Constructor.
         * @param baseIcon This icon's base waypoint icon.
         * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
         * with lower priorities.
         * @param options Options with which to initialize this icon.
         */
        constructor(baseIcon, priority, options) {
            var _a, _b, _c, _d, _e, _f;
            super(baseIcon.waypoint, priority, baseIcon.size, { offset: baseIcon.offset, anchor: baseIcon.anchor });
            this.baseIcon = baseIcon;
            this.ringRadiusBuffer = msfssdk.SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.ringRadiusBuffer) !== null && _a !== void 0 ? _a : 0, true);
            this.strokeWidth = msfssdk.SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.strokeWidth) !== null && _b !== void 0 ? _b : 2, true);
            this.strokeColor = msfssdk.SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _c !== void 0 ? _c : 'white', true);
            this.outlineWidth = msfssdk.SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.outlineWidth) !== null && _d !== void 0 ? _d : 0, true);
            this.outlineColor = msfssdk.SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.outlineColor) !== null && _e !== void 0 ? _e : 'black', true);
            this.bgColor = msfssdk.SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _f !== void 0 ? _f : '#3c3c3c', true);
        }
        /** @inheritdoc */
        drawIconAt(context, mapProjection, left, top) {
            const size = this.baseIcon.size.get();
            const radius = Math.hypot(size[0], size[1]) / 2 + this.ringRadiusBuffer.get();
            const x = left + size[0] / 2;
            const y = top + size[1] / 2;
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI);
            this.drawRingBackground(context);
            this.baseIcon.draw(context, mapProjection);
            this.drawRing(context);
        }
        /**
         * Draws the ring background for this icon.
         * @param context  A canvas rendering context.
         */
        drawRingBackground(context) {
            context.fillStyle = this.bgColor.get();
            context.fill();
        }
        /**
         * Draws the ring for this icon.
         * @param context  A canvas rendering context.
         */
        drawRing(context) {
            const outlineWidth = this.outlineWidth.get();
            const strokeWidth = this.strokeWidth.get();
            if (outlineWidth > 0) {
                this.applyStroke(context, (strokeWidth + 2 * outlineWidth), this.outlineColor.get());
            }
            this.applyStroke(context, strokeWidth, this.strokeColor.get());
        }
        /**
         * Applies a stroke to a canvas rendering context.
         * @param context A canvas rendering context.
         * @param lineWidth The width of the stroke.
         * @param strokeStyle The style of the stroke.
         */
        applyStroke(context, lineWidth, strokeStyle) {
            context.lineWidth = lineWidth;
            context.strokeStyle = strokeStyle;
            context.stroke();
        }
    }

    /**
     *
     */
    class MapWaypointDisplayBuilderClass {
        constructor() {
            this.factories = new Map();
        }
        /** @inheritdoc */
        withFactory(roles, icon, label) {
            msfssdk.BitFlags.forEach(roles, (val, index) => {
                this.factories.set(1 << index, { icon, label });
            }, true);
            return this;
        }
        /** @inheritdoc */
        withNormalStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.Normal, {
                icon: () => new WaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withFlightPlanInactiveStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.FlightPlanInactive, {
                icon: () => new WaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withFlightPlanActiveStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.FlightPlanActive, {
                icon: () => new WaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withHighlightStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.Highlight, {
                icon: () => new WaypointHighlightIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withVNavStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.VNav, {
                icon: () => new VNavWaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new VNavWaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withProcPreviewStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.ProcedurePreview, {
                icon: () => new WaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /** @inheritdoc */
        withProcTransitionPreviewStyles(imgCache, iconStyleSelector, labelStyleSelector) {
            this.factories.set(exports.MapWaypointRenderRole.ProcedureTransitionPreview, {
                icon: () => new WaypointIconFactory(imgCache, iconStyleSelector),
                label: () => new WaypointLabelFactory(labelStyleSelector)
            });
            return this;
        }
        /**
         * Applies this builder's configurations to a waypoint renderer.
         * @param renderer A waypoint renderer.
         */
        apply(renderer) {
            for (const [role, factories] of this.factories) {
                renderer.setIconFactory(role, factories.icon());
                renderer.setLabelFactory(role, factories.label());
            }
        }
    }
    /**
     * A waypoint icon factory.
     */
    class WaypointIconFactory {
        /**
         * Constructor.
         * @param imgCache The image cache from which to retrieve icon images.
         * @param styles A function which retrieves styles for icons.
         */
        constructor(imgCache, styles) {
            this.imgCache = imgCache;
            this.styles = styles;
            this.cache = new Map();
        }
        /** @inheritdoc */
        getIcon(role, waypoint) {
            let existing = this.cache.get(waypoint.uid);
            if (!existing) {
                existing = this.createIcon(waypoint);
                this.cache.set(waypoint.uid, existing);
            }
            return existing;
        }
        /**
         * Creates a new icon for a waypoint.
         * @param waypoint The waypoint for which to create an icon.
         * @returns a waypoint icon.
         */
        createIcon(waypoint) {
            const { priority, size } = this.styles(waypoint);
            const img = this.imgCache.getForWaypoint(waypoint);
            if (img) {
                if (waypoint instanceof AirportWaypoint) {
                    return new MapAirportIcon(waypoint, priority, img, size);
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint || waypoint instanceof msfssdk.FlightPathWaypoint) {
                    return new msfssdk.MapWaypointImageIcon(waypoint, priority, img, size);
                }
            }
            return new msfssdk.MapBlankWaypointIcon(waypoint, 0);
        }
    }
    /**
     * A waypoint label factory.
     */
    class WaypointLabelFactory {
        /**
         * Constructor.
         * @param styles A function which retrieves styles for labels.
         */
        constructor(styles) {
            this.styles = styles;
            this.cache = new Map();
        }
        /** @inheritdoc */
        getLabel(role, waypoint) {
            let existing = this.cache.get(waypoint.uid);
            if (!existing) {
                existing = this.createLabel(waypoint);
                this.cache.set(waypoint.uid, existing);
            }
            return existing;
        }
        /**
         * Creates a new icon for a waypoint.
         * @param waypoint The waypoint for which to create an icon.
         * @returns a waypoint icon.
         */
        createLabel(waypoint) {
            const { priority, alwaysShow, options } = this.styles(waypoint);
            let text = '';
            if (waypoint instanceof msfssdk.FacilityWaypoint) {
                text = msfssdk.ICAO.getIdent(waypoint.facility.get().icao);
            }
            else if (waypoint instanceof msfssdk.FlightPathWaypoint || waypoint instanceof ProcedureTurnLegWaypoint) {
                text = waypoint.ident;
            }
            return new msfssdk.MapCullableLocationTextLabel(text, priority, waypoint.location, alwaysShow, options);
        }
    }
    /**
     * A waypoint icon factory for highlighted waypoints.
     */
    class WaypointHighlightIconFactory {
        /**
         * Constructor.
         * @param imgCache The image cache from which to retrieve icon images.
         * @param styles A function which retrieves styles for icons.
         */
        constructor(imgCache, styles) {
            this.imgCache = imgCache;
            this.styles = styles;
            this.cache = new Map();
        }
        /** @inheritdoc */
        getIcon(role, waypoint) {
            let existing = this.cache.get(waypoint.uid);
            if (!existing) {
                existing = this.createIcon(waypoint);
                this.cache.set(waypoint.uid, existing);
            }
            return existing;
        }
        /**
         * Creates a new icon for a waypoint.
         * @param waypoint The waypoint for which to create an icon.
         * @returns A waypoint icon.
         */
        createIcon(waypoint) {
            const style = this.styles(waypoint);
            const baseIcon = this.createBaseIcon(waypoint, style);
            if (baseIcon) {
                return new MapWaypointHighlightIcon(baseIcon, baseIcon.priority, style.highlightOptions);
            }
            return new msfssdk.MapBlankWaypointIcon(waypoint, 0);
        }
        /**
         * Creates a new base icon for a waypoint.
         * @param waypoint The waypoint for which to create a base icon.
         * @param style The style to apply to the icon.
         * @returns A waypoint base icon.
         */
        createBaseIcon(waypoint, style) {
            const { priority, size } = style;
            const img = this.imgCache.getForWaypoint(waypoint);
            if (img === undefined) {
                return null;
            }
            if (waypoint instanceof AirportWaypoint) {
                return new MapAirportIcon(waypoint, priority, img, size);
            }
            else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                return new msfssdk.MapWaypointImageIcon(waypoint, priority, img, size);
            }
            return null;
        }
    }
    /**
     * A waypoint icon factory for VNAV waypoints.
     */
    class VNavWaypointIconFactory {
        /**
         * Constructor.
         * @param imgCache The image cache from which to retrieve icon images.
         * @param styles A function which retrieves styles for icons.
         */
        constructor(imgCache, styles) {
            this.imgCache = imgCache;
            this.styles = styles;
        }
        /** @inheritdoc */
        getIcon(role, waypoint) {
            return this.createIcon(waypoint);
        }
        /**
         * Creates a new icon for a waypoint.
         * @param waypoint The waypoint for which to create an icon.
         * @returns a waypoint icon.
         */
        createIcon(waypoint) {
            const { priority, size } = this.styles(waypoint);
            const img = this.imgCache.getForWaypoint(waypoint);
            if (img) {
                return new msfssdk.MapWaypointImageIcon(waypoint, priority, img, size);
            }
            return new msfssdk.MapBlankWaypointIcon(waypoint, 0);
        }
    }
    /**
     * A waypoint label factory for VNAV waypoints.
     */
    class VNavWaypointLabelFactory {
        /**
         * Constructor.
         * @param styles A function which retrieves styles for labels.
         */
        constructor(styles) {
            this.styles = styles;
        }
        /** @inheritdoc */
        getLabel(role, waypoint) {
            return this.createLabel(waypoint);
        }
        /**
         * Creates a new icon for a waypoint.
         * @param waypoint The waypoint for which to create an icon.
         * @returns a waypoint icon.
         */
        createLabel(waypoint) {
            const { priority, alwaysShow, options } = this.styles(waypoint);
            let text = '';
            if (waypoint instanceof msfssdk.VNavWaypoint) {
                text = waypoint.uid === 'vnav-tod' ? 'TOD' : 'BOD';
            }
            return new msfssdk.MapCullableLocationTextLabel(text, priority, waypoint.location, alwaysShow, options);
        }
    }

    /**
     * A module describing the display of the altitude intercept arc.
     */
    class MapAltitudeArcModule {
        constructor() {
            /** Whether to show the altitude intercept arc. */
            this.show = msfssdk.Subject.create(false);
        }
    }

    /**
     * A module for the map crosshair.
     */
    class MapCrosshairModule {
        constructor() {
            this.show = msfssdk.Subject.create(false);
        }
    }

    /**
     *
     */
    class MapFlightPlanFocusModule {
        constructor() {
            /**
             * Whether focus is active.
             */
            this.isActive = msfssdk.Subject.create(false);
            /**
             * Whether the flight plan has focus.
             */
            this.planHasFocus = msfssdk.Subject.create(false);
            /**
             * The flight plan focus.
             */
            this.focus = msfssdk.Subject.create(null);
            /**
             * A flight plan data provider for the plan which has focus, or `null`. A data provider is required to update
             * a flight plan leg focus after its component legs have been calculated for the first time.
             */
            this.dataProvider = msfssdk.Subject.create(null);
        }
    }

    /**
     * A module for map weather radar mode data.
     */
    class MapNexradModule {
        constructor() {
            this.showNexrad = msfssdk.Subject.create(false);
        }
    }

    /**
     * A module describing the map pointer.
     */
    class MapPointerModule {
        constructor() {
            /** Whether the pointer is active. */
            this.isActive = msfssdk.Subject.create(false);
            /** The position of the pointer on the projected map, in pixel coordinates. */
            this.position = msfssdk.Vec2Subject.createFromVector(new Float64Array(2));
            /** The desired map target. */
            this.target = msfssdk.GeoPointSubject.createFromGeoPoint(new msfssdk.GeoPoint(0, 0));
        }
    }

    /**
     * A module describing a flight plan procedure to be previewed.
     */
    class MapProcedurePreviewModule {
        constructor() {
            /** The procedure type previewed by the layer. */
            this.procedureType = msfssdk.Subject.create(exports.ProcedureType.DEPARTURE);
            /** The flight plan containing the procedure to be previewed. */
            this.procedurePlan = msfssdk.Subject.create(null);
            /** The flight plan containing the transitions to be previewed. */
            this.transitionPlan = msfssdk.Subject.create(null);
        }
    }

    /**
     * A module describing the map range compass.
     */
    class MapRangeCompassModule {
        constructor() {
            /** Whether to show the range compass. */
            this.show = msfssdk.Subject.create(true);
        }
    }

    /**
     * A module describing the map range ring.
     */
    class MapRangeRingModule {
        constructor() {
            /** Whether to show the range ring. */
            this.show = msfssdk.Subject.create(true);
        }
    }

    /**
     * A module describing the display of the track vector.
     */
    class MapTrackVectorModule {
        constructor() {
            /** Whether to show the track vector. */
            this.show = msfssdk.Subject.create(false);
            /** The track vector's lookahead time. */
            this.lookaheadTime = msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.SECOND.createNumber(60));
        }
    }

    /**
     * A module which defines display units.
     */
    class MapUnitsModule {
        /**
         * Constructor.
         * @param unitsSettingManager A display units user setting manager.
         */
        constructor(unitsSettingManager) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            this.unitsSettingManager = unitsSettingManager;
            /** Distance units mode. */
            this.distanceMode = (_b = (_a = this.unitsSettingManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsDistance')) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(exports.UnitsDistanceSettingMode.Nautical);
            /** Distance units mode. */
            this.navAngleMode = (_d = (_c = this.unitsSettingManager) === null || _c === void 0 ? void 0 : _c.getSetting('unitsNavAngle')) !== null && _d !== void 0 ? _d : msfssdk.Subject.create(exports.UnitsNavAngleSettingMode.Magnetic);
            /** Distance units. */
            this.navAngle = (_f = (_e = this.unitsSettingManager) === null || _e === void 0 ? void 0 : _e.navAngleUnits) !== null && _f !== void 0 ? _f : msfssdk.Subject.create(msfssdk.NavAngleUnit.create(true));
            /** Large distance units. */
            this.distanceLarge = (_h = (_g = this.unitsSettingManager) === null || _g === void 0 ? void 0 : _g.distanceUnitsLarge) !== null && _h !== void 0 ? _h : msfssdk.Subject.create(msfssdk.UnitType.NMILE);
            /** Small distance units. */
            this.distanceSmall = (_k = (_j = this.unitsSettingManager) === null || _j === void 0 ? void 0 : _j.distanceUnitsSmall) !== null && _k !== void 0 ? _k : msfssdk.Subject.create(msfssdk.UnitType.FOOT);
        }
    }

    /**
     * A module which defines a highlighted waypoint.
     */
    class MapWaypointHighlightModule {
        constructor() {
            /** The highlighted waypoint. */
            this.waypoint = msfssdk.Subject.create(null);
        }
    }

    /**
     * A module describing the display of waypoints.
     */
    class MapWaypointsModule {
        constructor() {
            /** Whether to show airports. */
            this.airportShow = {
                [exports.AirportSize.Large]: msfssdk.Subject.create(true),
                [exports.AirportSize.Medium]: msfssdk.Subject.create(true),
                [exports.AirportSize.Small]: msfssdk.Subject.create(true)
            };
            /** Whether to show VORs. */
            this.vorShow = msfssdk.Subject.create(true);
            /** Whether to show NDBs. */
            this.ndbShow = msfssdk.Subject.create(true);
            /** Whether to show intersections. */
            this.intShow = msfssdk.Subject.create(true);
            /** Whether to show user waypoints. */
            this.userShow = msfssdk.Subject.create(true);
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     *
     */
    class GarminMapBuilder {
        /**
         * Configures a map builder to generate a map with measurement unit support.
         *
         * Adds the module `[GarminMapKeys.Units]: MapUnitsModule`.
         * @param mapBuilder The map builder to configure.
         * @param settingManager A units setting manager to control the map's measurement units. If not defined, the map
         * will use a default set of measurement units.
         * @returns The map builder, after it has been configured.
         */
        static units(mapBuilder, settingManager) {
            return mapBuilder.withModule(GarminMapKeys.Units, () => new MapUnitsModule(settingManager));
        }
        /**
         * Configures a map builder to generate a map which supports multiple indexed ranges, with optional support for
         * controlling the map range with a user setting.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[MapSystemKeys.RangeControl]: ResourceModerator<void>`
         * * `[GarminMapKeys.UseRangeSetting]: ResourceModerator<Subject<boolean>>` (only if user setting support is enabled)
         *
         * Modules:
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
         *
         * Controllers:
         * * `[GarminMapKeys.RangeRTR]: MapRangeRTRController`
         * * `[GarminMapKeys.Range]: MapRangeController` (can be used to control map range)
         * * `'useRangeSettingDefault': MapSystemCustomController` (only if user setting support is enabled)
         * @param mapBuilder The map builder to configure.
         * @param nauticalRangeArray The map range array to use for nautical distance mode. If not defined, a range array
         * will not automatically be set when entering nautical distance mode.
         * @param metricRangeArray The map range array to use for metric distance mode. If not defined, a range array will
         * not automatically be set when entering metric distance mode.
         * @param settingManager A setting manager containing a user setting to control the map range. If not defined, range
         * will not be controlled by a user setting.
         * @param useRangeSettingByDefault Whether the range user setting should control the map range by default. Defaults
         * to `true`. Is ignored if `settingManager` is undefined.
         * @returns The map builder, after it has been configured.
         */
        static range(mapBuilder, nauticalRangeArray, metricRangeArray, settingManager, useRangeSettingByDefault = true) {
            const useSetting = settingManager === undefined ? undefined : msfssdk.Subject.create(true);
            if (useSetting) {
                const defaultUseRangeSettingConsumer = {
                    priority: 0,
                    onAcquired: (useRangeSetting) => {
                        useRangeSetting.set(useRangeSettingByDefault);
                    },
                    onCeded: () => { }
                };
                let useRangeSettingDefaultController;
                mapBuilder
                    .withContext(GarminMapKeys.UseRangeSetting, () => new msfssdk.ResourceModerator(useSetting))
                    .withController('useRangeSettingDefault', context => useRangeSettingDefaultController = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.UseRangeSetting].claim(defaultUseRangeSettingConsumer);
                    },
                    onMapDestroyed: () => {
                        useRangeSettingDefaultController.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.UseRangeSetting].forfeit(defaultUseRangeSettingConsumer);
                    }
                }));
            }
            return mapBuilder
                .withRangeControlModerator()
                .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                .withController(GarminMapKeys.RangeRTR, context => new MapRangeRTRController(context))
                .withController(GarminMapKeys.Range, context => new MapRangeController(context, nauticalRangeArray, metricRangeArray, settingManager, useSetting));
        }
        /**
         * Configures a map builder to generate a map which supports different orientations, as enumerated by
         * {@link MapOrientation}. Each orientation defines a different rotation behavior, target offset, and range
         * endpoints.
         *
         * Adds the following...
         *
         * Context properties:
         * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
         * * `[GarminMapKeys.OrientationControl]: ResourceModerator<void>`
         *
         * Modules:
         * * `[MapSystemKeys.Rotation]: MapRotationModule`
         * * `[GarminMapKeys.Orientation]: MapOrientationModule`
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only with user setting support)
         *
         * Controllers:
         * * `[MapSystemKeys.Rotation]: MapRotationController`
         * * `[GarminMapKeys.OrientationRTR]: MapOrientationRTRController`
         * * `[GarminMapKeys.Orientation]: MapOrientationController` (only with user setting support)
         * {@link MapOrientationRTRController}.
         * @param mapBuilder The map builder to configure.
         * @param nominalTargetOffsets The nominal projected target offsets defined by each orientation. Each target offset
         * is a 2-tuple `[x, y]`, where each component is expressed relative to the width or height of the map's projected
         * window, *excluding* the dead zone. If an orientation does not have a defined offset, it will default to `[0, 0]`.
         * @param nominalRangeEndpoints The nominal range endpoints defined by each orientation. Each set of range endpoints
         * is a 4-tuple `[x1, y1, x2, y2]`, where each component is expressed relative to the width or height of the map's
         * projected window, *excluding* the dead zone. If an orientation does not have defined range endpoints, it will
         * default to `[0.5, 0.5, 0.5, 0]` (center to top-center).
         * @param settingManager A setting manager containing user settings used to control the map orientation. If not
         * defined, map orientation will not be bound to user settings.
         * @returns The map builder, after it has been configured.
         */
        static orientation(mapBuilder, nominalTargetOffsets, nominalRangeEndpoints, settingManager) {
            mapBuilder
                .withRotation()
                .withContext(GarminMapKeys.OrientationControl, () => new msfssdk.ResourceModerator(undefined))
                .withModule(GarminMapKeys.Orientation, () => new MapOrientationModule())
                .withController(GarminMapKeys.OrientationRTR, context => new MapOrientationRTRController(context, nominalTargetOffsets, nominalRangeEndpoints));
            if (settingManager !== undefined) {
                mapBuilder
                    .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                    .withController(GarminMapKeys.Orientation, context => new MapOrientationController(context, settingManager));
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map which supports data integrity state. During loss of valid heading
         * information, the map will default to North Up orientation, and the player airplane icon will optionally be changed
         * to reflect this state. During loss of valid GPS signal, the map will stop attempting to follow the player
         * airplane, and the player airplane icon will be hidden.
         * @param mapBuilder The map builder to configure.
         * @param airplaneIconSrc A mutable subscribable which controls the player airplane icon's image source URI.
         * Required for this controller to change the player airplane icon.
         * @param airplaneIconAnchor A mutable subscribable which controls the anchor point of the player airplane icon.
         * Required for this controller to change the player airplane icon.
         * @param normalIconSrc The URI of the normal player airplane icon's image source, or a subscribable which provides
         * it. Required for the player airplane icon to change during loss of valid heading information.
         * @param normalIconAnchor The anchor point of the normal player airplane icon, as `[x, y]`, where each component is
         * relative to the width or height of the icon, or a subscribable which provides it. Required for the player airplane
         * icon to change during loss of valid heading information.
         * @param noHeadingIconSrc The URI of the no-heading player airplane icon's image source, or a subscribable which
         * provides it. Required for the player airplane icon to change during loss of valid heading information.
         * @param noHeadingIconAnchor The anchor point of the no-heading player airplane icon, as `[x, y]`, where each
         * component is relative to the width or height of the icon, or a subscribable which provides it. Required for the
         * player airplane icon to change during loss of valid heading information.
         * @returns The map builder, after it has been configured.
         */
        static dataIntegrity(mapBuilder, airplaneIconSrc, airplaneIconAnchor, normalIconSrc, normalIconAnchor, noHeadingIconSrc, noHeadingIconAnchor) {
            return mapBuilder
                .withModule(msfssdk.MapSystemKeys.DataIntegrity, () => new msfssdk.MapDataIntegrityModule())
                .withController(GarminMapKeys.DataIntegrityRTR, context => {
                const normalIconSrcToUse = typeof normalIconSrc === 'string' ? msfssdk.Subject.create(normalIconSrc) : normalIconSrc;
                const normalIconAnchorToUse = normalIconAnchor instanceof Float64Array
                    ? msfssdk.Subject.create(normalIconAnchor)
                    : normalIconAnchor;
                const noHeadingIconSrcToUse = typeof noHeadingIconSrc === 'string' ? msfssdk.Subject.create(noHeadingIconSrc) : noHeadingIconSrc;
                const noHeadingIconAnchorToUse = noHeadingIconAnchor instanceof Float64Array
                    ? msfssdk.Subject.create(noHeadingIconAnchor)
                    : noHeadingIconAnchor;
                return new MapDataIntegrityRTRController(context, airplaneIconSrc, airplaneIconAnchor, normalIconSrcToUse, normalIconAnchorToUse, noHeadingIconSrcToUse, noHeadingIconAnchorToUse);
            });
        }
        /**
         * Configures a map builder to generate a map which supports declutter modes, and optionally binds the declutter
         * mode to a user setting.
         * @param mapBuilder The map builder to configure.
         * @param settingManager A user setting manager containing the setting controlling declutter mode.
         * @returns The map builder, after it has been configured.
         */
        static declutter(mapBuilder, settingManager) {
            mapBuilder.withModule(GarminMapKeys.Declutter, () => new MapDeclutterModule());
            if ((settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapDeclutter')) !== undefined) {
                mapBuilder.withBindings(GarminMapKeys.Declutter, context => {
                    return [
                        {
                            source: settingManager.getSetting('mapDeclutter'),
                            target: context.model.getModule(GarminMapKeys.Declutter).mode,
                            map: (setting) => {
                                switch (setting) {
                                    case exports.MapDeclutterSettingMode.Level3: return exports.MapDeclutterMode.Level3;
                                    case exports.MapDeclutterSettingMode.Level2: return exports.MapDeclutterMode.Level2;
                                    case exports.MapDeclutterSettingMode.Level1: return exports.MapDeclutterMode.Level1;
                                    default: return exports.MapDeclutterMode.All;
                                }
                            }
                        }
                    ];
                });
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map which supports terrain color modes, and optionally binds the modes to
         * user settings.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only with user settings support)
         * * `[GarminMapKeys.Terrain]: MapTerrainModule`
         *
         * Controllers:
         * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsController`
         * * `[GarminMapKeys.Terrain]: MapTerrainController` (only with user settings support)
         * @param mapBuilder The map builder to configure.
         * @param colors The terrain colors to use for each terrain mode. Ignored if `includeTerrain` is `false`.
         * @param settingManager A user setting manager containing settings which control terrain colors. If not defined,
         * terrain color mode will not be controlled by user settings.
         * @param allowRelativeMode Whether to allow relative terrain mode. Defaults to `true`. Ignored if terrain
         * colors is not controlled by user settings.
         * @returns The map builder, after it has been configured.
         */
        static terrainColors(mapBuilder, colors, settingManager, allowRelativeMode = true) {
            mapBuilder
                .withModule(GarminMapKeys.Terrain, () => new MapTerrainModule())
                .withController(msfssdk.MapSystemKeys.TerrainColors, context => new MapTerrainColorsController(context, colors !== null && colors !== void 0 ? colors : {}));
            const setting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTerrainMode');
            if (setting !== undefined) {
                mapBuilder
                    .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                    .withController(GarminMapKeys.Terrain, context => {
                    return new MapTerrainController(context, settingManager, allowRelativeMode);
                });
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map which supports NEXRAD, and optionally binds the display of NEXRAD to
         * user settings.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
         * * `[GarminMapKeys.Nexrad]: MapNexradModule`
         *
         * Controllers:
         * * `[MapSystemKeys.Weather]: MapWxrController`
         * * `[GarminMapKeys.Nexrad]: MapNexradController`
         * @param mapBuilder The map builder to configure.
         * @param minRangeIndex The minimum range index, inclusive, at which NEXRAD is visible. Defaults to `0`.
         * @param settingManager A user setting manager containing settings which control NEXRAD. If not defined, NEXRAD will
         * not be controlled by user settings.
         * @param maxDeclutterMode The highest global declutter mode, inclusive, at which NEXRAD is visible. Defaults
         * to `MapDeclutterMode.Level2`. Ignored if NEXRAD user settings are not supported.
         * @returns The map builder, after it has been configured.
         */
        static nexrad(mapBuilder, minRangeIndex = 0, settingManager, maxDeclutterMode) {
            return mapBuilder
                .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                .withModule(GarminMapKeys.Nexrad, () => new MapNexradModule())
                .withController(msfssdk.MapSystemKeys.Weather, context => new MapWxrController(context))
                .withController(GarminMapKeys.Nexrad, context => {
                return new MapNexradController(context, minRangeIndex, settingManager, maxDeclutterMode);
            });
        }
        /**
         * Configures a map builder to generate a map which displays a range ring.
         *
         * Requires the modules defined in {@link MapRangeRingLayerModules} with the exception of `'rangeRing'`.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.RangeRing]: MapRangeRingModule`
         *
         * Layers:
         * * `[GarminMapKeys.RangeRing]: MapRangeRingLayer`
         * @param mapBuilder The map builder to configure.
         * @param options Styling options for the ring.
         * @param order The order to assign to the range ring layer. Layers with lower assigned order will be attached to the
         * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
         * added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static rangeRing(mapBuilder, options, order) {
            return mapBuilder
                .withModule(GarminMapKeys.RangeRing, () => new MapRangeRingModule())
                .withLayer(GarminMapKeys.RangeRing, context => {
                return (msfssdk.FSComponent.buildComponent(MapRangeRingLayer, Object.assign({ model: context.model, mapProjection: context.projection }, options)));
            }, order)
                .withInit(GarminMapKeys.RangeRing, context => { context.model.getModule(GarminMapKeys.RangeRing).show.set(true); });
        }
        /**
         * Configures a map builder to generate a map which displays a range compass. The range compass is displayed only in
         * Heading Up and Track Up orientation. If the map also supports a range ring, the range ring will be hidden while
         * the range compass is displayed.
         *
         * Requires the modules defined in {@link MapRangeCompassLayerModules} with the exception of `'rangeCompass'`.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.RangeCompass]: MapRangeCompassModule`
         *
         * Layers:
         * * `[GarminMapKeys.RangeCompass]: MapRangeCompassLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.RangeCompass]: MapRangeCompassController`
         * @param mapBuilder The map builder to configure.
         * @param options Styling options for the ring.
         * @param order The order to assign to the range compass layer. Layers with lower assigned order will be attached to
         * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
         * already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static rangeCompass(mapBuilder, options, order) {
            return mapBuilder
                .withModule(GarminMapKeys.RangeCompass, () => new MapRangeCompassModule())
                .withLayer(GarminMapKeys.RangeCompass, context => {
                return (msfssdk.FSComponent.buildComponent(MapRangeCompassLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus }, options)));
            }, order)
                .withController(GarminMapKeys.RangeCompass, context => new MapRangeCompassController(context));
        }
        /**
         * Configures a map builder to generate a map which displays a crosshair at the projected target position when the
         * map is not following the player airplane. If the map does not have the module
         * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`, the map is assumed to never follow the player airplane,
         * and the crosshair will always be visible.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.Crosshair]: MapCrosshairModule`
         *
         * Layers:
         * * `[GarminMapKeys.Crosshair]: MapCrosshairLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.Crosshair]: MapBindingsController`
         * @param mapBuilder The map builder to configure.
         * @returns The map builder, after it has been configured.
         */
        static crosshair(mapBuilder) {
            return mapBuilder
                .withModule(GarminMapKeys.Crosshair, () => new MapCrosshairModule())
                .withLayer(GarminMapKeys.Crosshair, context => {
                return (msfssdk.FSComponent.buildComponent(MapCrosshairLayer, { model: context.model, mapProjection: context.projection }));
            })
                .withBindings(GarminMapKeys.Crosshair, context => {
                var _a, _b;
                return [{
                        source: (_b = (_a = context.model.getModule(msfssdk.MapSystemKeys.FollowAirplane)) === null || _a === void 0 ? void 0 : _a.isFollowing) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(false),
                        target: context.model.getModule(GarminMapKeys.Crosshair).show,
                        map: (isFollowingAirplane) => !isFollowingAirplane
                    }];
            });
        }
        /**
         * Configures a map builder to generate a map which supports the display of waypoints located within the boundaries
         * of the map's projected window. Waypoints displayed in this manner are rendered by a {@link MapWaypointRenderer}
         * under the role {@link MapWaypointRenderRole.Normal}. Optionally binds the visibility of waypoints to user
         * settings.
         *
         * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
         * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
         * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
         * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
         *
         * Modules:
         * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsModule`
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only if user settings are supported)
         *
         * Layers:
         * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsLayer`
         * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
         *
         * Controllers:
         * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
         * waypoint renderer)
         * * `'waypointsVis': MapWaypointsVisController` (only if user settings are supported)
         * @param mapBuilder The map builder to configure.
         * @param configure A function used to configure the display and styling of waypoint icons and labels.
         * @param settingManager A setting manager containing the user settings controlling waypoint visibility. If not
         * defined, waypoint visibility will not be bound to user settings.
         * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
         * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
         * added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static waypoints(mapBuilder, configure, settingManager, order) {
            mapBuilder
                .withTextLayer(true)
                .withModule(msfssdk.MapSystemKeys.NearestWaypoints, () => new MapWaypointsModule())
                .withContext(msfssdk.MapSystemKeys.WaypointRenderer, context => new MapWaypointRenderer(context[msfssdk.MapSystemKeys.TextManager]))
                .withContext(GarminMapKeys.WaypointDisplayBuilder, () => new MapWaypointDisplayBuilderClass());
            if (settingManager) {
                mapBuilder
                    .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                    .with(GarminMapBuilder.waypointVisSettings, settingManager);
            }
            const layerCount = mapBuilder.layerCount;
            return mapBuilder
                .withLayer(msfssdk.MapSystemKeys.NearestWaypoints, (context) => {
                return (msfssdk.FSComponent.buildComponent(MapWaypointsLayer, { model: context.model, mapProjection: context.projection, bus: context.bus, waypointRenderer: context[msfssdk.MapSystemKeys.WaypointRenderer] }));
            }, order)
                .withLayerOrder(msfssdk.MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount)
                .withInit('waypointsLayerDisplayConfigure', context => {
                configure(context[GarminMapKeys.WaypointDisplayBuilder]);
            })
                .withController(msfssdk.MapSystemKeys.WaypointRenderer, context => new msfssdk.MapSystemGenericController(context, {
                onAfterMapRender: () => { context[GarminMapKeys.WaypointDisplayBuilder].apply(context[msfssdk.MapSystemKeys.WaypointRenderer]); },
                onAfterUpdated: () => { context[msfssdk.MapSystemKeys.WaypointRenderer].update(context.projection); }
            }));
        }
        /**
         * Configures a map builder to bind the visibility of waypoints to user settings.
         *
         * Requires the modules defined in {@link MapWaypointsVisControllerModules}.
         *
         * Adds the controller `[GarminMapKeys.WaypointsVisibility]: MapWaypointsVisController`.
         * @param mapBuilder The map builder to configure.
         * @param settingManager A setting manager containing the user settings controlling waypoint visibility.
         * @returns The map builder, after it has been configured.
         */
        static waypointVisSettings(mapBuilder, settingManager) {
            return mapBuilder.withController(GarminMapKeys.WaypointsVisibility, context => new MapWaypointsVisController(context, settingManager));
        }
        static flightPlans(mapBuilder, options, configure, order) {
            if (options.length === 0) {
                return mapBuilder;
            }
            mapBuilder
                .withTextLayer(true)
                .withContext(msfssdk.MapSystemKeys.WaypointRenderer, context => new MapWaypointRenderer(context[msfssdk.MapSystemKeys.TextManager]))
                .withContext(GarminMapKeys.WaypointDisplayBuilder, () => new MapWaypointDisplayBuilderClass());
            const layerCount = mapBuilder.layerCount;
            for (let i = 0; i < options.length; i++) {
                const { dataProvider, pathRenderer, drawEntirePlan } = options[i];
                mapBuilder.withLayer(`${msfssdk.MapSystemKeys.FlightPlan}${i}`, context => {
                    return (msfssdk.FSComponent.buildComponent(MapFlightPlanLayer, { model: context.model, mapProjection: context.projection, bus: context.bus, waypointRenderer: context[msfssdk.MapSystemKeys.WaypointRenderer], dataProvider: dataProvider, pathRenderer: pathRenderer, drawEntirePlan: typeof drawEntirePlan !== 'object' ? msfssdk.Subject.create(drawEntirePlan !== null && drawEntirePlan !== void 0 ? drawEntirePlan : false) : drawEntirePlan }));
                }, order !== null && order !== void 0 ? order : layerCount);
            }
            return mapBuilder
                .withLayer(GarminMapKeys.FlightPlanWaypoints, context => {
                return (msfssdk.FSComponent.buildComponent(msfssdk.MapSyncedCanvasLayer, { model: context.model, mapProjection: context.projection }));
            }, order !== null && order !== void 0 ? order : layerCount)
                .withLayerOrder(msfssdk.MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount)
                .withInit('flightPlanLayerDisplayConfigure', context => {
                configure(context[GarminMapKeys.WaypointDisplayBuilder]);
            })
                .withController(msfssdk.MapSystemKeys.WaypointRenderer, context => new msfssdk.MapSystemGenericController(context, {
                onAfterMapRender: () => { context[GarminMapKeys.WaypointDisplayBuilder].apply(context[msfssdk.MapSystemKeys.WaypointRenderer]); },
                onAfterUpdated: () => { context[msfssdk.MapSystemKeys.WaypointRenderer].update(context.projection); }
            }))
                .withController(GarminMapKeys.FlightPlanWaypoints, context => new msfssdk.MapSystemGenericController(context, {
                onAfterMapRender: () => {
                    const fplWaypointsLayer = context.getLayer(GarminMapKeys.FlightPlanWaypoints);
                    context[msfssdk.MapSystemKeys.WaypointRenderer].setCanvasContext(exports.MapWaypointRenderRole.FlightPlanInactive, fplWaypointsLayer.display.context);
                    context[msfssdk.MapSystemKeys.WaypointRenderer].setCanvasContext(exports.MapWaypointRenderRole.FlightPlanActive, fplWaypointsLayer.display.context);
                    context[msfssdk.MapSystemKeys.WaypointRenderer].setCanvasContext(exports.MapWaypointRenderRole.VNav, fplWaypointsLayer.display.context);
                }
            }));
        }
        /**
         * Configures a map builder to generate a map which displays the active flight plan. The flight path and all
         * waypoints that are part of the flight plan are displayed. Waypoints displayed in this manner are rendered by a
         * {@link MapWaypointRenderer} under the roles {@link MapWaypointRenderRole.FlightPlanActive} or
         * {@link MapWaypointRenderRole.FlightPlanInactive}. Additionally, if VNAV is supported, TOD and BOD markers will
         * also be rendered under the role {@link MapWaypointRenderRole.VNav}.
         *
         * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
         * flight plan layers. Otherwise, a text layer will be added to the builder after the flight plan layers.
         * @param mapBuilder The map builder to configure.
         * @param flightPlanner The flight planner.
         * @param pathRenderer The flight path renderer to use to the draw the flight plan.
         * @param drawEntirePlan Whether the entire flight plan should always be drawn.
         * @param configure A function used to configure the display and styling of flight plan waypoint icons and labels.
         * @param supportFocus Whether to support flight plan focus on the primary flight plan. If focus is supported, the
         * primary flight plan will be drawn when it is focused, regardless of whether it is active. Defaults to `false`.
         * @param order The order to assign to the flight plan layers. Layers with lower assigned order will be attached to
         * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
         * already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static activeFlightPlan(mapBuilder, flightPlanner, pathRenderer, drawEntirePlan, configure, supportFocus = false, order) {
            if (supportFocus) {
                // Because flight plan focus still leaves the DTO random flight plan visible when it is active, we need to
                // support drawing two flight plans at the same time under those circumstances.
                const primaryPlanProvider = new MapFlightPlannerPlanDataProvider(mapBuilder.bus, flightPlanner);
                const dtoPlanProvider = new MapFlightPlannerPlanDataProvider(mapBuilder.bus, flightPlanner);
                let fplIndexSub;
                let isFocusedSub;
                let controller;
                return mapBuilder
                    .with(GarminMapBuilder.flightPlans, [
                    { dataProvider: primaryPlanProvider, pathRenderer, drawEntirePlan },
                    { dataProvider: dtoPlanProvider, pathRenderer, drawEntirePlan: false }
                ], configure, order)
                    .withController('activeFlightPlanProvider', context => controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: () => {
                        const focusModule = context.model.getModule(GarminMapKeys.FlightPlanFocus);
                        const planProviderHandler = () => {
                            var _a;
                            const activePlanIndex = flightPlanner.activePlanIndex;
                            const isFlightPlanFocused = (_a = focusModule === null || focusModule === void 0 ? void 0 : focusModule.planHasFocus.get()) !== null && _a !== void 0 ? _a : false;
                            // Show the primary plan when a DTO random is not active or when it is focused.
                            primaryPlanProvider.setPlanIndex(activePlanIndex === Fms.PRIMARY_PLAN_INDEX || isFlightPlanFocused ? Fms.PRIMARY_PLAN_INDEX : -1);
                            // Only show the DTO random plan when a DTO random is active.
                            dtoPlanProvider.setPlanIndex(activePlanIndex === Fms.DTO_RANDOM_PLAN_INDEX ? Fms.DTO_RANDOM_PLAN_INDEX : -1);
                        };
                        fplIndexSub = context.bus.getSubscriber().on('fplIndexChanged').handle(planProviderHandler);
                        isFocusedSub = focusModule === null || focusModule === void 0 ? void 0 : focusModule.planHasFocus.sub(planProviderHandler, true);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: () => {
                        fplIndexSub === null || fplIndexSub === void 0 ? void 0 : fplIndexSub.destroy();
                        isFocusedSub === null || isFocusedSub === void 0 ? void 0 : isFocusedSub.destroy();
                    }
                }));
            }
            else {
                return mapBuilder.with(GarminMapBuilder.flightPlans, [{ dataProvider: new MapActiveFlightPlanDataProvider(mapBuilder.bus, flightPlanner), pathRenderer, drawEntirePlan }], configure, order);
            }
        }
        /**
         * Configures a map builder to generate a map which supports displaying a highlighted waypoint, and optionally
         * drawing a line from the highlighted waypoint to the position of the player airplane.
         *
         * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
         * highlighted waypoint layers. Otherwise, a text layer will be added to the builder after the highlighted waypoint
         * layers.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
         * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
         * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
         *
         * Modules:
         * * `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule`
         *
         * Layers:
         * * `[GarminMapKeys.WaypointHighlightLine]: MapLineLayer` (only if line support is included)
         * * `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightLayer`
         * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
         *
         * Controllers:
         * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
         * waypoint renderer)
         * @param mapBuilder The map builder to configure.
         * @param includeLine Whether to include support for drawing a line from the highlighted waypoint to the player
         * airplane.
         * @param configure A function used to configure the display and styling of highlighted waypoint icons and labels.
         * @param lineOptions Styling options for the waypoint highlight line. The default values are the same as for
         * {@link MapLineLayer}, except the `strokeDash` property defaults to `[5, 3, 2, 3]`. Ignored if `includeLine` is
         * `false`.
         * @param order The order to assign to the highlighted waypoint layers. Layers with lower assigned order will be
         * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
         * layers already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static waypointHighlight(mapBuilder, includeLine, configure, lineOptions, order) {
            mapBuilder
                .withTextLayer(true)
                .withModule(GarminMapKeys.WaypointHighlight, () => new MapWaypointHighlightModule())
                .withContext(msfssdk.MapSystemKeys.WaypointRenderer, context => new MapWaypointRenderer(context[msfssdk.MapSystemKeys.TextManager]))
                .withContext(GarminMapKeys.WaypointDisplayBuilder, () => new MapWaypointDisplayBuilderClass());
            if (includeLine) {
                const waypointLocation = new msfssdk.GeoPoint(0, 0);
                const waypointLocationSubject = msfssdk.Subject.create(null);
                let waypointLocationSub;
                let controller;
                mapBuilder
                    .withLayer(GarminMapKeys.WaypointHighlightLine, context => {
                    var _a;
                    const options = Object.assign({}, lineOptions);
                    (_a = options.strokeDash) !== null && _a !== void 0 ? _a : (options.strokeDash = [5, 3, 2, 3]);
                    return (msfssdk.FSComponent.buildComponent(msfssdk.MapLineLayer, Object.assign({ model: context.model, mapProjection: context.projection, start: context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps).position, end: waypointLocationSubject }, options)));
                })
                    .withController('waypointHighlightLineEndSubject', context => {
                    return controller = new msfssdk.MapSystemGenericController(context, {
                        onAfterMapRender: (contextArg) => {
                            contextArg.model.getModule(GarminMapKeys.WaypointHighlight).waypoint.sub(waypoint => {
                                if (waypoint === null) {
                                    waypointLocationSub === null || waypointLocationSub === void 0 ? void 0 : waypointLocationSub.destroy();
                                    waypointLocationSub = undefined;
                                    waypointLocationSubject.set(null);
                                }
                                else {
                                    waypointLocationSub === null || waypointLocationSub === void 0 ? void 0 : waypointLocationSub.destroy();
                                    waypointLocationSub = waypoint.location.sub(location => {
                                        waypointLocation.set(location);
                                        if (waypointLocationSubject.get() === waypointLocation) {
                                            waypointLocationSubject.notify();
                                        }
                                        else {
                                            waypointLocationSubject.set(waypointLocation);
                                        }
                                    }, true);
                                }
                            }, true);
                        },
                        onMapDestroyed: () => {
                            controller.destroy();
                        },
                        onDestroyed: () => {
                            waypointLocationSub === null || waypointLocationSub === void 0 ? void 0 : waypointLocationSub.destroy();
                        }
                    });
                });
            }
            const layerCount = mapBuilder.layerCount;
            return mapBuilder
                .withLayer(GarminMapKeys.WaypointHighlight, (context) => {
                return (msfssdk.FSComponent.buildComponent(MapWaypointHighlightLayer, { model: context.model, mapProjection: context.projection, waypointRenderer: context[msfssdk.MapSystemKeys.WaypointRenderer] }));
            }, order)
                .withLayerOrder(msfssdk.MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount)
                .withInit('waypointHighlightLayerDisplayConfigure', context => {
                configure(context[GarminMapKeys.WaypointDisplayBuilder]);
            })
                .withController(msfssdk.MapSystemKeys.WaypointRenderer, context => new msfssdk.MapSystemGenericController(context, {
                onAfterMapRender: () => { context[GarminMapKeys.WaypointDisplayBuilder].apply(context[msfssdk.MapSystemKeys.WaypointRenderer]); },
                onAfterUpdated: () => { context[msfssdk.MapSystemKeys.WaypointRenderer].update(context.projection); }
            }));
        }
        /**
         * Configures a map builder to generate a map which displays airspaces, and optionally binds the visibility of
         * airspaces to user settings.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
         *
         * Modules:
         * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
         *
         * Layers:
         * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.AirspaceVisibility]: MapAirspaceVisController` (only with user settings support)
         * @param mapBuilder The map builder to configure.
         * @param settingManager A setting manager containing the user settings controlling airspace visibility. If not
         * defined, airspace visibility will not be controlled by user settings.
         * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
         * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
         * added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static airspaces(mapBuilder, settingManager, order) {
            mapBuilder
                .withAirspaces(msfssdk.DefaultLodBoundaryCache.getCache(), GarminAirspaceShowTypeMap.MAP, MapAirspaceRendering.selectRenderer, MapAirspaceRendering.renderOrder, undefined, order);
            if (settingManager !== undefined) {
                mapBuilder.with(GarminMapBuilder.airspaceVisSettings, settingManager);
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to bind the visibility of airspaces to user settings.
         *
         * Requires the modules defined in {@link MapAirspaceVisControllerModules}.
         *
         * Adds the controller `[GarminMapKeys.AirspaceVisibility]: MapAirspaceVisController`.
         * @param mapBuilder The map builder to configure.
         * @param settingManager A setting manager containing the user settings controlling airspace visibility.
         * @returns The map builder, after it has been configured.
         */
        static airspaceVisSettings(mapBuilder, settingManager) {
            return mapBuilder.withController(GarminMapKeys.AirspaceVisibility, context => new MapAirspaceVisController(context, settingManager));
        }
        /**
         * Configures a map builder to generate a map which displays TCAS intruders.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
         * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
         * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
         * * `[MapSystemKeys.Traffic]: MapTrafficModule`
         * * `[GarminMapKeys.Traffic]: MapGarminTrafficModule`
         *
         * Layers:
         * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
         *
         * Controllers:
         * * `[MapSystemKeys.Traffic]: MapTrafficController`
         * * `[GarminMapKeys.Traffic]: MapGarminTrafficController` (only with user settings support)
         * @param mapBuilder The map builder to configure.
         * @param trafficSystem The traffic system from which to derive intruder data.
         * @param iconOptions Configuration options for intruder icons.
         * @param useOuterRangeAsOffScale Whether to use the outer traffic range defined in {@link MapGarminTrafficModule} as
         * the off-scale traffic range.
         * @param offScaleStatus A mutable subscribable to update with the layer's off-scale traffic status.
         * @param iconFactory A function which creates intruder icons for the traffic display. If not defined, a default icon
         * of type {@link MapTrafficIntruderIcon} is created for each intruder.
         * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
         * @param trafficSettingManager A setting manager containing user settings controlling the operation of the traffic
         * system. If not defined, the display of map traffic will not be controlled by those settings.
         * @param mapSettingManager A setting manager containing user settings controlling the display of traffic on maps. If
         * not defined, the display of map traffic will not be controlled by those settings.
         * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
         * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
         * added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static traffic(mapBuilder, trafficSystem, iconOptions, useOuterRangeAsOffScale, offScaleStatus, iconFactory, initCanvasStyles, trafficSettingManager, mapSettingManager, order) {
            const canvasFont = `${iconOptions.fontSize}px ${iconOptions.font}`;
            let offScaleOobOptions;
            if (offScaleStatus !== undefined) {
                offScaleOobOptions = (context) => {
                    const offScaleIntruders = msfssdk.SetSubject.create();
                    const oobIntruders = msfssdk.SetSubject.create();
                    const alertLevelSubs = new Map();
                    const offScaleTAs = msfssdk.SetSubject.create();
                    const offScaleRAs = msfssdk.SetSubject.create();
                    const handler = (set, type, intruder) => {
                        var _a;
                        if (type === msfssdk.SubscribableSetEventType.Added) {
                            alertLevelSubs.set(intruder, intruder.alertLevel.sub(alertLevel => {
                                if (alertLevel === msfssdk.TcasAlertLevel.ResolutionAdvisory) {
                                    offScaleRAs.add(intruder);
                                    offScaleTAs.delete(intruder);
                                }
                                else if (alertLevel === msfssdk.TcasAlertLevel.TrafficAdvisory) {
                                    offScaleTAs.add(intruder);
                                    offScaleRAs.delete(intruder);
                                }
                                else {
                                    offScaleTAs.delete(intruder);
                                    offScaleRAs.delete(intruder);
                                }
                            }, true));
                        }
                        else {
                            (_a = alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
                            alertLevelSubs.delete(intruder);
                            offScaleTAs.delete(intruder);
                            offScaleRAs.delete(intruder);
                        }
                    };
                    offScaleIntruders.sub(handler);
                    oobIntruders.sub(handler);
                    const raTAHandler = () => {
                        if (offScaleRAs.get().size > 0) {
                            offScaleStatus.set(exports.MapTrafficOffScaleStatus.RA);
                        }
                        else if (offScaleTAs.get().size > 0) {
                            offScaleStatus.set(exports.MapTrafficOffScaleStatus.TA);
                        }
                        else {
                            offScaleStatus.set(exports.MapTrafficOffScaleStatus.None);
                        }
                    };
                    offScaleTAs.sub(raTAHandler);
                    offScaleRAs.sub(raTAHandler);
                    raTAHandler();
                    return {
                        offScaleIntruders,
                        oobIntruders,
                        oobOffset: context.deadZone
                    };
                };
            }
            iconFactory !== null && iconFactory !== void 0 ? iconFactory : (iconFactory = (intruder, context) => new MapTrafficIntruderIcon(intruder, context.model.getModule(msfssdk.MapSystemKeys.Traffic), context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps), context.model.getModule(GarminMapKeys.Traffic), context.model.getModule(msfssdk.MapSystemKeys.FollowAirplane), iconOptions));
            initCanvasStyles !== null && initCanvasStyles !== void 0 ? initCanvasStyles : (initCanvasStyles = (canvasContext) => {
                canvasContext.textAlign = 'center';
                canvasContext.font = canvasFont;
            });
            mapBuilder
                .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                .withModule(msfssdk.MapSystemKeys.FollowAirplane, () => new msfssdk.MapFollowAirplaneModule())
                .withModule(GarminMapKeys.Traffic, () => new MapGarminTrafficModule(trafficSystem))
                .withTraffic(trafficSystem, iconFactory, initCanvasStyles, offScaleOobOptions, order)
                .withController(msfssdk.MapSystemKeys.Traffic, context => {
                return new MapTrafficController(context, useOuterRangeAsOffScale);
            });
            if (trafficSettingManager !== undefined) {
                mapBuilder.withController(GarminMapKeys.Traffic, context => new MapGarminTrafficController(context, trafficSettingManager, mapSettingManager));
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map which supports multiple indexed traffic map ranges, with optional
         * support for controlling the map range with a user setting. At each range index there is an outer range and an
         * inner range, except for the first index, at which there is just an outer range. The inner range is always the
         * largest range in the range array that is less than the outer range.
         *
         * Requires the module `[GarminMapKeys.Traffic]: MapGarminTrafficModule`.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[GarminMapKeys.UseRangeSetting]: ResourceModerator<Subject<boolean>>` (only if user setting support is enabled)
         *
         * Modules:
         * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
         *
         * Controllers:
         * * `[GarminMapKeys.RangeRTR]: MapRangeRTRController`
         * * `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` (can be used to control map range)
         * * `'useRangeSettingDefault': MapSystemCustomController` (only if user setting support is enabled)
         * @param mapBuilder The map builder to configure.
         * @param nauticalRangeArray The map range array to use for nautical distance mode. If not defined, a range array
         * will not automatically be set when entering nautical distance mode.
         * @param metricRangeArray The map range array to use for metric distance mode. If not defined, a range array will
         * not automatically be set when entering metric distance mode.
         * @param settingManager A setting manager containing a user setting to control the map range. If not defined, range
         * will not be controlled by a user setting.
         * @param useRangeSettingByDefault Whether the range user setting should control the map range by default. Defaults
         * to `true`. Is ignored if `settingManager` is undefined.
         * @returns The map builder, after it has been configured.
         */
        static trafficRange(mapBuilder, nauticalRangeArray, metricRangeArray, settingManager, useRangeSettingByDefault = true) {
            const useSetting = settingManager === undefined ? undefined : msfssdk.Subject.create(true);
            if (useSetting) {
                const defaultUseRangeSettingConsumer = {
                    priority: 0,
                    onAcquired: (useRangeSetting) => {
                        useRangeSetting.set(useRangeSettingByDefault);
                    },
                    onCeded: () => { }
                };
                let useRangeSettingDefaultController;
                mapBuilder
                    .withContext(GarminMapKeys.UseRangeSetting, () => new msfssdk.ResourceModerator(useSetting))
                    .withController('useRangeSettingDefault', context => useRangeSettingDefaultController = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.UseRangeSetting].claim(defaultUseRangeSettingConsumer);
                    },
                    onMapDestroyed: () => {
                        useRangeSettingDefaultController.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.UseRangeSetting].forfeit(defaultUseRangeSettingConsumer);
                    }
                }));
            }
            return mapBuilder
                .withModule(GarminMapKeys.Range, () => new msfssdk.MapIndexedRangeModule())
                .withController(GarminMapKeys.RangeRTR, context => new MapRangeRTRController(context))
                .withController(GarminMapKeys.TrafficRange, context => {
                return new TrafficMapRangeController(context, nauticalRangeArray, metricRangeArray, settingManager, useSetting);
            });
        }
        /**
         * Configures a map builder to generate a map which displays traffic range rings. There are two rings: an outer and
         * an inner ring. Each ring has tick marks at the 12 clock positions, with major ticks at the 4 cardinal positions.
         * Each ring also has an optional label which displays the range marked by the ring.
         *
         * Requires the modules defined in {@link TrafficMapRangeLayerModules}.
         *
         * Adds the layer `[GarminMapKeys.TrafficRange]: TrafficMapRangeLayer`.
         * @param mapBuilder The map builder to configure.
         * @param ringOptions Styling options for the rings.
         * @param order The order to assign to the ring layer. Layers with lower assigned order will be attached to the map
         * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
         * to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static trafficRangeRings(mapBuilder, ringOptions, order) {
            return mapBuilder.withLayer(GarminMapKeys.TrafficRange, context => {
                return (msfssdk.FSComponent.buildComponent(TrafficMapRangeLayer, Object.assign({ model: context.model, mapProjection: context.projection }, ringOptions)));
            }, order);
        }
        /**
         * Configures a map builder to generate a map with pointer support. Activating the pointer allows the pointer to
         * control map panning and stops the map from actively rotating.
         *
         * If map target and rotation control resource moderators exist on the map context, the pointer RTR controller will
         * attempt to claim those resources with a priority of `100`. Otherwise, the controller assumes nothing else controls
         * the map target or rotation.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.Pointer]: MapPointerModule`
         *
         * Layers:
         * * `[GarminMapKeys.Pointer]: MapPointerLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.Pointer]: MapPointerController` (can be used to control the behavior of the pointer)
         * * `[GarminMapKeys.PointerRTR]: MapPointerRTRController`
         * @param mapBuilder The map builder to configure.
         * @param pointerBoundsOffset The offset of the boundary surrounding the area in which the pointer can freely move,
         * from the edge of the projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
         * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
         * positive offset is directed toward the center of the map.
         * @param icon The pointer icon to render, as a VNode. If not default, a default icon will be rendered.
         * @param order The order to assign to the pointer layer. Layers with lower assigned order will be attached to the
         * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
         * added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static pointer(mapBuilder, pointerBoundsOffset, icon, order) {
            return mapBuilder
                .withModule(GarminMapKeys.Pointer, () => new MapPointerModule())
                .withLayer(GarminMapKeys.Pointer, (context) => {
                return (msfssdk.FSComponent.buildComponent(MapPointerLayer, { model: context.model, mapProjection: context.projection }, icon));
            }, order)
                .withController(GarminMapKeys.Pointer, context => new MapPointerController(context))
                .withController(GarminMapKeys.PointerRTR, context => {
                return new MapPointerRTRController(context, 'isSubscribable' in pointerBoundsOffset ? pointerBoundsOffset : msfssdk.Subject.create(pointerBoundsOffset));
            });
        }
        /**
         * Configures a map builder to generate a map which displays a pointer information box when the pointer is active.
         *
         * Requires the modules defined in {@link MapPointerInfoLayerModules}.
         *
         * Adds the layer `[GarminMapKeys.PointerInfo]: MapPointerInfoLayer`.
         * @param mapBuilder The map builder to configure.
         * @param size The size of the pointer information box.
         * @param order The order to assign to the pointer information layer. Layers with lower assigned order will be
         * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
         * layers already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static pointerInfo(mapBuilder, size, order) {
            return mapBuilder.withLayer(GarminMapKeys.PointerInfo, (context) => {
                return (msfssdk.FSComponent.buildComponent(MapPointerInfoLayer, { model: context.model, mapProjection: context.projection, size: size }));
            }, order);
        }
        /**
         * Configures the map builder to generate a map which supports flight plan focus. Flight plan focus automatically
         * adjusts the map's target and range to place a portion of a flight plan into view.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule`
         *
         * Controllers:
         * * `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusRTRController`
         * @param mapBuilder The map builder to configure.
         * @param nominalFocusMargins A subscribable which provides the nominal focus margins, as
         * `[left, top, right, bottom]` in pixels. The nominal margins define the offset of the boundaries of the focus
         * region relative to the map's projected window, *excluding* the dead zone. Positive values represent offsets
         * toward the center of the window. When the flight plan is focused, the focused elements of the plan are guaranteed
         * to be contained within the focus region.
         * @param defaultFocusRangeIndex The default map range index to apply when the flight plan focus consists of only a
         * single point in space.
         * @param focusDebounceDelay The debounce delay, in milliseconds, to apply to focus target calculations when the
         * flight plan focus changes. Defaults to 500 milliseconds.
         * @returns The map builder, after it has been configured.
         */
        static flightPlanFocus(mapBuilder, nominalFocusMargins, defaultFocusRangeIndex = 0, focusDebounceDelay = 500) {
            const definedNominalFocusMargins = nominalFocusMargins !== null && nominalFocusMargins !== void 0 ? nominalFocusMargins : msfssdk.Subject.create(msfssdk.VecNMath.create(4));
            return mapBuilder
                .withModule(GarminMapKeys.FlightPlanFocus, () => new MapFlightPlanFocusModule())
                .withController(GarminMapKeys.FlightPlanFocus, context => {
                return new MapFlightPlanFocusRTRController(context, 'isSubscribable' in definedNominalFocusMargins ? definedNominalFocusMargins : msfssdk.Subject.create(definedNominalFocusMargins), defaultFocusRangeIndex, focusDebounceDelay);
            });
        }
        /**
         * Configures a map builder to generate a map with an altitude intercept arc, and optionally binds the display of the
         * arc to a user setting.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.AltitudeArc]: MapAltitudeArcModule`
         *
         * Layers:
         * * `[GarminMapKeys.AltitudeArc]: MapAltitudeArcLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.AltitudeArc]: MapBindingsController` (only if user settings are supported)
         * @param mapBuilder The map builder to configure.
         * @param options Options for the arc.
         * @param settingManager A setting manager containing user settings used to control the display of the arc. If not
         * defined, the display of the arc will not be bound to user settings.
         * @param order The order to assign to the altitude arc layer. Layers with lower assigned order will be attached to
         * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
         * already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static altitudeArc(mapBuilder, options, settingManager, order) {
            mapBuilder
                .withModule(GarminMapKeys.AltitudeArc, () => new MapAltitudeArcModule())
                .withLayer(GarminMapKeys.AltitudeArc, context => {
                return (msfssdk.FSComponent.buildComponent(MapAltitudeArcLayer, Object.assign({ model: context.model, mapProjection: context.projection }, options)));
            }, order);
            if ((settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapAltitudeArcShow')) !== undefined) {
                mapBuilder.withBindings(GarminMapKeys.AltitudeArc, context => {
                    return [
                        {
                            source: settingManager.getSetting('mapAltitudeArcShow'),
                            target: context.model.getModule(GarminMapKeys.AltitudeArc).show
                        }
                    ];
                });
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map with a track vector, and optionally binds the display options of the
         * vector to user settings.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GarminMapKeys.TrackVector]: MapTrackVectorModule`
         *
         * Layers:
         * * `[GarminMapKeys.TrackVector]: MapTrackVectorLayer`
         *
         * Controllers:
         * * `[GarminMapKeys.TrackVector]: MapBindingsController` (only if user settings are supported)
         * @param mapBuilder The map builder to configure.
         * @param options Options for the track vector.
         * @param settingManager A setting manager containing user settings used to control the track vector. If not defined,
         * the track vector will not be bound to user settings.
         * @param order The order to assign to the track vector layer. Layers with lower assigned order will be attached to
         * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
         * already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static trackVector(mapBuilder, options, settingManager, order) {
            mapBuilder
                .withModule(GarminMapKeys.TrackVector, () => new MapTrackVectorModule())
                .withLayer(GarminMapKeys.TrackVector, context => {
                return (msfssdk.FSComponent.buildComponent(MapTrackVectorLayer, Object.assign({ model: context.model, mapProjection: context.projection }, options)));
            }, order);
            const showSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTrackVectorShow');
            const lookaheadSetting = settingManager === null || settingManager === void 0 ? void 0 : settingManager.tryGetSetting('mapTrackVectorLookahead');
            if (showSetting !== undefined || lookaheadSetting !== undefined) {
                mapBuilder.withBindings(GarminMapKeys.TrackVector, context => {
                    const seconds = msfssdk.UnitType.SECOND.createNumber(0);
                    const bindings = [];
                    if (showSetting !== undefined) {
                        bindings.push({
                            source: showSetting,
                            target: context.model.getModule(GarminMapKeys.TrackVector).show
                        });
                    }
                    if (lookaheadSetting !== undefined) {
                        bindings.push({
                            source: lookaheadSetting,
                            target: context.model.getModule(GarminMapKeys.TrackVector).lookaheadTime,
                            map: (source) => seconds.set(source)
                        });
                    }
                    return bindings;
                });
            }
            return mapBuilder;
        }
        /**
         * Configures a map builder to generate a map which displays a miniature compass.
         *
         * Adds the layer `GarminMapKeys.MiniCompass: MapMiniCompassLayer`.
         * @param mapBuilder The map builder to configure.
         * @param imgSrc The URI of the mini-compass's image asset.
         * @param order The order to assign to the mini-compass layer. Layers with lower assigned order will be attached to
         * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
         * already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static miniCompass(mapBuilder, imgSrc, order) {
            return mapBuilder.withLayer(GarminMapKeys.MiniCompass, context => {
                return (msfssdk.FSComponent.buildComponent(MapMiniCompassLayer, { model: context.model, mapProjection: context.projection, imgSrc: imgSrc }));
            }, order);
        }
        /**
         * Configures a map builder to generate a map which supports a flight plan procedure preview.
         *
         * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
         * highlighted waypoint layers. Otherwise, a text layer will be added to the builder after the highlighted waypoint
         * layers.
         *
         * Adds the following...
         *
         * Context properties:
         * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
         * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
         * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
         *
         * Modules:
         * * `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewModule`
         *
         * Layers:
         * * `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewLayer`
         * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
         *
         * Controllers:
         * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
         * waypoint renderer)
         * @param mapBuilder The map builder to configure.
         * @param pathRenderer The flight path renderer to use to render the procedure preview.
         * @param configure A function used to configure the display and styling of procedure preview waypoint icons and
         * labels.
         * @param order The order to assign to the highlighted waypoint layers. Layers with lower assigned order will be
         * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
         * layers already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static procPreview(mapBuilder, pathRenderer, configure, order) {
            mapBuilder
                .withTextLayer(true)
                .withModule(GarminMapKeys.ProcedurePreview, () => new MapProcedurePreviewModule())
                .withContext(msfssdk.MapSystemKeys.WaypointRenderer, context => new MapWaypointRenderer(context[msfssdk.MapSystemKeys.TextManager]))
                .withContext(GarminMapKeys.WaypointDisplayBuilder, () => new MapWaypointDisplayBuilderClass());
            const layerCount = mapBuilder.layerCount;
            return mapBuilder
                .withLayer(GarminMapKeys.ProcedurePreview, (context) => {
                return (msfssdk.FSComponent.buildComponent(MapProcedurePreviewLayer, { model: context.model, mapProjection: context.projection, bus: context.bus, waypointRenderer: context[msfssdk.MapSystemKeys.WaypointRenderer], pathRenderer: pathRenderer }));
            }, order)
                .withLayerOrder(msfssdk.MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount)
                .withInit('procPreviewLayerDisplayConfigure', context => {
                configure(context[GarminMapKeys.WaypointDisplayBuilder]);
            })
                .withController(msfssdk.MapSystemKeys.WaypointRenderer, context => new msfssdk.MapSystemGenericController(context, {
                onAfterMapRender: () => { context[GarminMapKeys.WaypointDisplayBuilder].apply(context[msfssdk.MapSystemKeys.WaypointRenderer]); },
                onAfterUpdated: () => { context[msfssdk.MapSystemKeys.WaypointRenderer].update(context.projection); }
            }));
        }
        /**
         * Configures a map builder to include an indicator group.
         * @param mapBuilder The map builder to configure.
         * @param key The key of the indicator group.
         * @param indicatorFactories An array of functions which create the indicators. The order of functions in the array
         * determines the order in which the created indicators will be added to the group.
         * @param callbacks Optional callback functions to register with the indicator group.
         * @param cssClass The CSS class(es) to apply to the root of the indicator group.
         * @param order The order to assign to the layer containing the indicator group. Layers with lower assigned order
         * will be attached to the map before and appear below layers with greater assigned order values. Defaults to the
         * number of layers already added to the map builder.
         * @returns The map builder, after it has been configured.
         */
        static indicatorGroup(mapBuilder, key, indicatorFactories, callbacks, cssClass, order) {
            return mapBuilder.withLayer(key, context => {
                return (msfssdk.FSComponent.buildComponent(msfssdk.MapGenericLayer, Object.assign({ model: context.model, mapProjection: context.projection }, callbacks, { class: cssClass }), indicatorFactories.map(factory => factory(context))));
            }, order);
        }
    }

    /**
     * Displays a map banner message.
     */
    class MapBannerIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.cssClassSet = msfssdk.SetSubject.create(['map-banner']);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    this.cssClassSet.add('map-banner-on');
                    this.cssClassSet.delete('map-banner-off');
                }
                else {
                    this.cssClassSet.delete('map-banner-on');
                    this.cssClassSet.add('map-banner-off');
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            if (this.props.class !== undefined) {
                if (typeof this.props.class === 'object') {
                    this.classSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, MapBannerIndicator.RESERVED_CLASSES);
                }
                else {
                    const classesToAdd = msfssdk.FSComponent.parseCssClassesFromString(this.props.class).filter(val => !MapBannerIndicator.RESERVED_CLASSES.includes(val));
                    for (const cssClass of classesToAdd) {
                        this.cssClassSet.add(cssClass);
                    }
                }
            }
            return (msfssdk.FSComponent.buildComponent("div", { class: this.cssClassSet }, this.props.children));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.classSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    MapBannerIndicator.RESERVED_CLASSES = ['map-banner', 'map-banner-on', 'map-banner-off'];

    /**
     * Displays a map detail level indication.
     */
    class MapDetailIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.modeSub = this.props.declutterMode.sub(this.onDeclutterModeChanged.bind(this), true);
        }
        /**
         * A callback which is called when the declutter mode setting value changes.
         * @param mode The new declutter mode setting value.
         */
        onDeclutterModeChanged(mode) {
            this.rootRef.instance.classList.remove('detail-4', 'detail-3', 'detail-2', 'detail-1');
            this.rootRef.instance.classList.add(MapDetailIndicator.MODE_CLASSES[mode]);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-detail' },
                this.props.showTitle ? msfssdk.FSComponent.buildComponent("div", null, "Detail") : null,
                msfssdk.FSComponent.buildComponent("div", { class: 'map-detail-icon' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-top' }),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-middle' }),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-bottom' }),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-detail-clip' }))));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.modeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    MapDetailIndicator.MODE_CLASSES = {
        [exports.MapDeclutterMode.All]: 'detail-4',
        [exports.MapDeclutterMode.Level3]: 'detail-3',
        [exports.MapDeclutterMode.Level2]: 'detail-2',
        [exports.MapDeclutterMode.Level1]: 'detail-1',
    };

    /**
     * Displays a map orientation indication.
     */
    class MapOrientationIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.text = this.props.orientation.map(mode => {
                var _a;
                return (_a = this.props.text[mode]) !== null && _a !== void 0 ? _a : '';
            });
            this.rootStyle = msfssdk.ObjectSubject.create({ visibility: '' });
        }
        /** @inheritdoc */
        onAfterRender() {
            this.isVisibleSub = this.props.isVisible.sub(isVisible => {
                this.rootStyle.set('visibility', isVisible ? '' : 'hidden');
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { style: this.rootStyle, class: 'map-orientation' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            this.text.destroy();
            (_a = this.isVisibleSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * Displays a terrain color scale.
     */
    class MapTerrainScaleIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
            this.absLabelTextSubs = [
                msfssdk.Subject.create('27000'),
                msfssdk.Subject.create('10000'),
                msfssdk.Subject.create('8000'),
                msfssdk.Subject.create('6000'),
                msfssdk.Subject.create('3000'),
                msfssdk.Subject.create('2000'),
                msfssdk.Subject.create('500'),
                msfssdk.Subject.create('0')
            ];
            this.relLabelTextSubs = [
                msfssdk.Subject.create('500'),
                msfssdk.Subject.create('1000'),
                msfssdk.Subject.create('2000')
            ];
            this.unitTextSub = msfssdk.Subject.create('');
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        onAfterRender() {
            this.props.show.sub(this.updateDisplay.bind(this));
            this.props.terrainMode.sub(this.updateDisplay.bind(this), true);
        }
        /**
         * Updates the display of this indicator.
         */
        updateDisplay() {
            if (this.props.show.get()) {
                switch (this.props.terrainMode.get()) {
                    case exports.MapTerrainMode.None:
                        this.rootRef.instance.style.display = 'none';
                        this.rootRef.instance.classList.remove('terrain-abs', 'terrain-rel');
                        this.unitTextSub.set('');
                        break;
                    case exports.MapTerrainMode.Absolute:
                        this.rootRef.instance.style.display = '';
                        this.rootRef.instance.classList.remove('terrain-rel');
                        this.rootRef.instance.classList.add('terrain-abs');
                        this.unitTextSub.set('');
                        break;
                    case exports.MapTerrainMode.Relative:
                        this.rootRef.instance.style.display = '';
                        this.rootRef.instance.classList.remove('terrain-abs');
                        this.rootRef.instance.classList.add('terrain-rel');
                        this.unitTextSub.set('FT');
                        break;
                }
            }
            else {
                this.rootRef.instance.style.display = 'none';
                this.rootRef.instance.classList.remove('terrain-abs', 'terrain-rel');
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-terrainscale' },
                msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-scale terrainscale-abs' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #c8c8c8;' }),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #939393;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[0])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #904522;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[1])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #904f25;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[2])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #9d6434;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[3])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #c58f45;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[4])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #d0aa43;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[5])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #456821;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[6])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #427238;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[7]))),
                msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-scale terrainscale-rel' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #ff0000' }),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #ffff00;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[0])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #00ff00;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[1])),
                    msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #000000;' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[2]))),
                msfssdk.FSComponent.buildComponent("div", { class: 'map-terrainscale-unit' }, this.unitTextSub)));
        }
    }

    /**
     * Displays a traffic off-scale indication.
     */
    class MapTrafficOffScaleIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.ref = msfssdk.FSComponent.createRef();
            this.text = this.props.status.map(status => {
                return MapTrafficOffScaleIndicator.TEXT[status];
            });
        }
        /** @inheritdoc */
        onAfterRender() {
            this.statusSub = this.props.status.sub(this.onModeChanged.bind(this), true);
        }
        /**
         * A callback which is called when the indicator mode changes.
         * @param mode The new mode.
         */
        onModeChanged(mode) {
            this.ref.instance.classList.remove('offscale-mode-off', 'offscale-mode-ta', 'offscale-mode-ra');
            this.ref.instance.classList.add(MapTrafficOffScaleIndicator.CLASSES[mode]);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.ref, class: 'map-traffic-offscale' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.statusSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    MapTrafficOffScaleIndicator.CLASSES = {
        [exports.MapTrafficOffScaleStatus.None]: 'offscale-mode-off',
        [exports.MapTrafficOffScaleStatus.TA]: 'offscale-mode-ta',
        [exports.MapTrafficOffScaleStatus.RA]: 'offscale-mode-ra'
    };
    MapTrafficOffScaleIndicator.TEXT = {
        [exports.MapTrafficOffScaleStatus.None]: '',
        [exports.MapTrafficOffScaleStatus.TA]: 'TA OFF SCALE',
        [exports.MapTrafficOffScaleStatus.RA]: 'RA OFF SCALE'
    };

    /**
     * Displays a traffic operating status and optional altitude restriction mode indications.
     */
    class MapTrafficStatusIndicator extends msfssdk.DisplayComponent {
        constructor() {
            var _a;
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({ display: '' });
            this.disabledStyle = msfssdk.ObjectSubject.create({ display: '' });
            this.altModeStyle = msfssdk.ObjectSubject.create({ display: '' });
            this.altitudeRestrictionText = (_a = this.props.altitudeRestrictionMode) === null || _a === void 0 ? void 0 : _a.map(mode => {
                return MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT[mode];
            });
        }
        /** @inheritdoc */
        onAfterRender() {
            this.showSub = this.props.show.sub(show => {
                this.rootStyle.set('display', show ? '' : 'none');
            }, true);
            this.operatingModeSub = this.props.operatingMode.sub(mode => {
                this.disabledStyle.set('display', mode === msfssdk.TcasOperatingMode.Standby ? 'inherit' : 'none');
                this.altModeStyle.set('display', mode === msfssdk.TcasOperatingMode.Standby ? 'none' : 'inherit');
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { style: this.rootStyle, class: 'map-traffic-status' },
                this.props.altitudeRestrictionMode !== undefined
                    ? msfssdk.FSComponent.buildComponent("div", { style: this.altModeStyle, class: 'traffic-status-alt' }, this.altitudeRestrictionText)
                    : null,
                msfssdk.FSComponent.buildComponent("svg", { class: 'traffic-status-symbol', viewBox: '0 0 150 100' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 50 5 L 95 50 L 50 95 L 5 50 Z' }),
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 115 10 L 135 35 L 122.5 35 L 122.5 80 L 107.5 80 L 107.5 35 L 95 35 Z' }),
                    msfssdk.FSComponent.buildComponent("g", { style: this.disabledStyle, class: 'traffic-status-disabled' },
                        msfssdk.FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-outline', d: 'M 10 10 L 140 90 M 10 90 L 140 10' }),
                        msfssdk.FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-stroke', d: 'M 10 10 L 140 90 M 10 90 L 140 10' })))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.operatingModeSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.altitudeRestrictionText) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT = {
        [exports.MapTrafficAltitudeRestrictionMode.Unrestricted]: 'UNRES',
        [exports.MapTrafficAltitudeRestrictionMode.Above]: 'ABOVE',
        [exports.MapTrafficAltitudeRestrictionMode.Normal]: 'NORM',
        [exports.MapTrafficAltitudeRestrictionMode.Below]: 'BELOW'
    };

    /**
     * Displays an ADS-B operating mode indication.
     */
    class TrafficMapAdsbModeIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.text = this.props.operatingMode.map(mode => { var _a; return (_a = this.props.text[mode]) !== null && _a !== void 0 ? _a : ''; });
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'map-traffic-adsb-opmode' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.text.destroy();
        }
    }

    /**
     * Displays an ADS-B Off banner indicator.
     */
    class TrafficMapAdsbOffBannerIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.show = msfssdk.MappedSubject.create(([adsbMode, trafficMode]) => {
                return adsbMode === msfssdk.AdsbOperatingMode.Standby && trafficMode !== msfssdk.TcasOperatingMode.Standby;
            }, this.props.adsbOperatingMode, this.props.trafficOperatingMode);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { show: this.show, class: 'map-adsb-standby' }, "ADS-B TRFC OFF"));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.show.destroy();
        }
    }

    /**
     * Displays a traffic system altitude restriction mode indication.
     */
    class TrafficMapAltitudeModeIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.text = this.props.altitudeRestrictionMode.map(mode => { var _a; return (_a = this.props.text[mode]) !== null && _a !== void 0 ? _a : ''; });
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'map-traffic-altmode' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.text.destroy();
        }
    }

    /**
     * Displays a traffic system operating mode indication.
     */
    class TrafficMapOperatingModeIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.text = this.props.operatingMode.map(mode => { var _a; return (_a = this.props.text[mode]) !== null && _a !== void 0 ? _a : ''; });
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'map-traffic-opmode' }, this.text));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.text.destroy();
        }
    }

    /**
     * Displays a traffic system standby mode banner indicator.
     */
    class TrafficMapStandbyBannerIndicator extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.show = this.props.operatingMode.map(mode => mode === msfssdk.TcasOperatingMode.Standby);
            this.cssClassSet = msfssdk.SetSubject.create(['map-traffic-standby']);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.isOnGroundSub = this.props.isOnGround.sub(isOnGround => {
                isOnGround
                    ? this.cssClassSet.add('map-traffic-standby-onground')
                    : this.cssClassSet.delete('map-traffic-standby-onground');
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { show: this.show, class: this.cssClassSet }, "STANDBY"));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            this.show.destroy();
            (_a = this.isOnGroundSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * A utility class for generating Garmin map waypoint styles.
     */
    class MapWaypointStyles {
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for normal waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for normal waypoints.
         */
        static nextGenNormalIconStyles(basePriority, scale = 1) {
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const userPriority = basePriority + 0.9;
            const airportSize = msfssdk.Vec2Math.create(26 * scale, 26 * scale);
            const standardSize = msfssdk.Vec2Math.create(32 * scale, 32 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: { priority: airportPriority[exports.AirportSize.Large], size: airportSize },
                [exports.AirportSize.Medium]: { priority: airportPriority[exports.AirportSize.Medium], size: airportSize },
                [exports.AirportSize.Small]: { priority: airportPriority[exports.AirportSize.Small], size: airportSize }
            };
            const vorStyle = { priority: vorPriority, size: standardSize };
            const ndbStyle = { priority: ndbPriority, size: standardSize };
            const intStyle = { priority: intPriority, size: standardSize };
            const userStyle = { priority: userPriority, size: standardSize };
            const defaultStyle = { priority: basePriority, size: standardSize };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                return defaultStyle;
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for normal waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for normal waypoints.
         */
        static nextGenNormalLabelStyles(basePriority, scale = 1) {
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const userPriority = basePriority + 0.9;
            const airportOptions = {
                [exports.AirportSize.Large]: MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -12 * scale), 20 * scale),
                [exports.AirportSize.Medium]: MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -12 * scale), 16 * scale),
                [exports.AirportSize.Small]: MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -12 * scale), 16 * scale)
            };
            const standardOptions = MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -8 * scale), 16 * scale);
            const intOptions = MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -5 * scale), 16 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: { priority: airportPriority[exports.AirportSize.Large], alwaysShow: false, options: airportOptions[exports.AirportSize.Large] },
                [exports.AirportSize.Medium]: { priority: airportPriority[exports.AirportSize.Medium], alwaysShow: false, options: airportOptions[exports.AirportSize.Medium] },
                [exports.AirportSize.Small]: { priority: airportPriority[exports.AirportSize.Small], alwaysShow: false, options: airportOptions[exports.AirportSize.Small] }
            };
            const vorStyle = { priority: vorPriority, alwaysShow: false, options: standardOptions };
            const ndbStyle = { priority: ndbPriority, alwaysShow: false, options: standardOptions };
            const intStyle = { priority: intPriority, alwaysShow: false, options: intOptions };
            const userStyle = { priority: userPriority, alwaysShow: false, options: standardOptions };
            const defaultStyle = { priority: basePriority, alwaysShow: false, options: standardOptions };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                return defaultStyle;
            };
        }
        /**
         * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a normal
         * role.
         * @param offset The label offset, in pixels.
         * @param fontSize The font size of the label, in pixels.
         * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a normal
         * role.
         */
        static createNextGenNormalLabelOptions(offset, fontSize) {
            return {
                anchor: msfssdk.Vec2Math.create(0.5, 1),
                offset,
                font: 'Roboto',
                fontSize,
                fontOutlineWidth: 6
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for flight plan waypoints.
         * @param active Whether to retrieve styles for active flight plan waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for flight plan waypoints.
         */
        static nextGenFlightPlanIconStyles(active, basePriority, scale = 1) {
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const rwyPriority = basePriority + 0.4;
            const userPriority = basePriority + 0.9;
            const fpPriority = basePriority + 0.1;
            const airportSize = msfssdk.Vec2Math.create(26 * scale, 26 * scale);
            const standardSize = msfssdk.Vec2Math.create(32 * scale, 32 * scale);
            const fpIconSize = msfssdk.Vec2Math.create(8 * scale, 8 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: { priority: airportPriority[exports.AirportSize.Large], size: airportSize },
                [exports.AirportSize.Medium]: { priority: airportPriority[exports.AirportSize.Medium], size: airportSize },
                [exports.AirportSize.Small]: { priority: airportPriority[exports.AirportSize.Small], size: airportSize }
            };
            const vorStyle = { priority: vorPriority, size: standardSize };
            const ndbStyle = { priority: ndbPriority, size: standardSize };
            const intStyle = { priority: intPriority, size: standardSize };
            const rwyStyle = { priority: rwyPriority, size: standardSize };
            const userStyle = { priority: userPriority, size: standardSize };
            const fpStyle = { priority: fpPriority, size: fpIconSize };
            const defaultStyle = { priority: basePriority, size: standardSize };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.RWY:
                            return rwyStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                else if (waypoint instanceof msfssdk.FlightPathWaypoint) {
                    return fpStyle;
                }
                return defaultStyle;
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for flight plan waypoints.
         * @param active Whether to retrieve styles for active flight plan waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for flight plan waypoints.
         */
        static nextGenFlightPlanLabelStyles(active, basePriority, scale = 1) {
            const createLabelOptions = active
                ? MapWaypointStyles.createNextGenFplActiveLabelOptions
                : MapWaypointStyles.createNextGenFplInactiveLabelOptions;
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const rwyPriority = basePriority + 0.4;
            const userPriority = basePriority + 0.9;
            const fpPriority = basePriority + 0.1;
            const airportOptions = {
                [exports.AirportSize.Large]: createLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 20 * scale),
                [exports.AirportSize.Medium]: createLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 16 * scale),
                [exports.AirportSize.Small]: createLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 16 * scale)
            };
            const vorOptions = createLabelOptions(msfssdk.Vec2Math.create(0, -11 * scale), 16 * scale);
            const ndbOptions = createLabelOptions(msfssdk.Vec2Math.create(0, -11 * scale), 16 * scale);
            const userOptions = createLabelOptions(msfssdk.Vec2Math.create(0, -12 * scale), 16 * scale);
            const smallOptions = createLabelOptions(msfssdk.Vec2Math.create(0, -8 * scale), 16 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: { priority: airportPriority[exports.AirportSize.Large], alwaysShow: true, options: airportOptions[exports.AirportSize.Large] },
                [exports.AirportSize.Medium]: { priority: airportPriority[exports.AirportSize.Medium], alwaysShow: true, options: airportOptions[exports.AirportSize.Medium] },
                [exports.AirportSize.Small]: { priority: airportPriority[exports.AirportSize.Small], alwaysShow: true, options: airportOptions[exports.AirportSize.Small] }
            };
            const vorStyle = { priority: vorPriority, alwaysShow: true, options: vorOptions };
            const ndbStyle = { priority: ndbPriority, alwaysShow: true, options: ndbOptions };
            const intStyle = { priority: intPriority, alwaysShow: true, options: smallOptions };
            const rwyStyle = { priority: rwyPriority, alwaysShow: true, options: smallOptions };
            const userStyle = { priority: userPriority, alwaysShow: true, options: userOptions };
            const fpStyle = { priority: fpPriority, alwaysShow: true, options: smallOptions };
            const defaultStyle = { priority: basePriority, alwaysShow: true, options: smallOptions };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.RWY:
                            return rwyStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                else if (waypoint instanceof msfssdk.FlightPathWaypoint || waypoint instanceof ProcedureTurnLegWaypoint) {
                    return fpStyle;
                }
                return defaultStyle;
            };
        }
        /**
         * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an inactive
         * flight plan role.
         * @param offset The label offset, in pixels.
         * @param fontSize The font size of the label, in pixels.
         * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an
         * inactive flight plan role.
         */
        static createNextGenFplInactiveLabelOptions(offset, fontSize) {
            return {
                anchor: msfssdk.Vec2Math.create(0, 1),
                offset,
                font: 'Roboto-Bold',
                fontSize,
                fontColor: 'black',
                fontOutlineWidth: 0,
                showBg: true,
                bgPadding: msfssdk.VecNMath.create(4, 1, 1, 1, 1),
                bgColor: 'white',
                bgOutlineWidth: 1,
                bgOutlineColor: 'black'
            };
        }
        /**
         * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an active
         * flight plan role.
         * @param offset The label offset, in pixels.
         * @param fontSize The font size of the label, in pixels.
         * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an active
         * flight plan role.
         */
        static createNextGenFplActiveLabelOptions(offset, fontSize) {
            return {
                anchor: msfssdk.Vec2Math.create(0, 1),
                offset,
                font: 'Roboto-Bold',
                fontSize,
                fontColor: 'magenta',
                fontOutlineWidth: 0,
                showBg: true,
                bgPadding: msfssdk.VecNMath.create(4, 1, 1, 1, 1),
                bgOutlineWidth: 1
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for highlighted waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for highlighted waypoints.
         */
        static nextGenHighlightIconStyles(basePriority, scale = 1) {
            const baseHighlightOptions = {
                strokeWidth: 2,
                strokeColor: 'white',
                outlineWidth: 0,
                outlineColor: 'black',
                bgColor: '#3c3c3c'
            };
            const airportHighlightRingRadiusBuffer = -5 * scale;
            const standardHighlightRingRadiusBuffer = -8 * scale;
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const userPriority = basePriority + 0.9;
            const airportSize = msfssdk.Vec2Math.create(26 * scale, 26 * scale);
            const standardSize = msfssdk.Vec2Math.create(32 * scale, 32 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: {
                    priority: airportPriority[exports.AirportSize.Large],
                    size: airportSize,
                    highlightOptions: Object.assign({ ringRadiusBuffer: airportHighlightRingRadiusBuffer }, baseHighlightOptions)
                },
                [exports.AirportSize.Medium]: {
                    priority: airportPriority[exports.AirportSize.Medium],
                    size: airportSize,
                    highlightOptions: Object.assign({ ringRadiusBuffer: airportHighlightRingRadiusBuffer }, baseHighlightOptions)
                },
                [exports.AirportSize.Small]: {
                    priority: airportPriority[exports.AirportSize.Small],
                    size: airportSize,
                    highlightOptions: Object.assign({ ringRadiusBuffer: airportHighlightRingRadiusBuffer }, baseHighlightOptions)
                },
            };
            const vorStyle = {
                priority: vorPriority,
                size: standardSize,
                highlightOptions: Object.assign({ ringRadiusBuffer: standardHighlightRingRadiusBuffer }, baseHighlightOptions)
            };
            const ndbStyle = {
                priority: ndbPriority,
                size: standardSize,
                highlightOptions: Object.assign({ ringRadiusBuffer: standardHighlightRingRadiusBuffer }, baseHighlightOptions)
            };
            const intStyle = {
                priority: intPriority,
                size: standardSize,
                highlightOptions: Object.assign({ ringRadiusBuffer: standardHighlightRingRadiusBuffer }, baseHighlightOptions)
            };
            const userStyle = {
                priority: userPriority,
                size: standardSize,
                highlightOptions: Object.assign({ ringRadiusBuffer: standardHighlightRingRadiusBuffer }, baseHighlightOptions)
            };
            const defaultStyle = {
                priority: basePriority,
                size: standardSize,
                highlightOptions: Object.assign({ ringRadiusBuffer: standardHighlightRingRadiusBuffer }, baseHighlightOptions)
            };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                return defaultStyle;
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for highlighted waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for highlighted waypoints.
         */
        static nextGenHighlightLabelStyles(basePriority, scale = 1) {
            const airportPriority = {
                [exports.AirportSize.Large]: basePriority + 0.8,
                [exports.AirportSize.Medium]: basePriority + 0.79,
                [exports.AirportSize.Small]: basePriority + 0.78
            };
            const vorPriority = basePriority + 0.7;
            const ndbPriority = basePriority + 0.6;
            const intPriority = basePriority + 0.5;
            const userPriority = basePriority + 0.9;
            const airportOptions = {
                [exports.AirportSize.Large]: MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 20 * scale),
                [exports.AirportSize.Medium]: MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 16 * scale),
                [exports.AirportSize.Small]: MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -15 * scale), 16 * scale)
            };
            const vorOptions = MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -11 * scale), 16 * scale);
            const ndbOptions = MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -11 * scale), 16 * scale);
            const intOptions = MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -8 * scale), 16 * scale);
            const userOptions = MapWaypointStyles.createNextGenHighlightLabelOptions(msfssdk.Vec2Math.create(0, -12 * scale), 16 * scale);
            const airportStyle = {
                [exports.AirportSize.Large]: { priority: airportPriority[exports.AirportSize.Large], alwaysShow: true, options: airportOptions[exports.AirportSize.Large] },
                [exports.AirportSize.Medium]: { priority: airportPriority[exports.AirportSize.Medium], alwaysShow: true, options: airportOptions[exports.AirportSize.Medium] },
                [exports.AirportSize.Small]: { priority: airportPriority[exports.AirportSize.Small], alwaysShow: true, options: airportOptions[exports.AirportSize.Small] }
            };
            const vorStyle = { priority: vorPriority, alwaysShow: true, options: vorOptions };
            const ndbStyle = { priority: ndbPriority, alwaysShow: true, options: ndbOptions };
            const intStyle = { priority: intPriority, alwaysShow: true, options: intOptions };
            const userStyle = { priority: userPriority, alwaysShow: true, options: userOptions };
            const defaultStyle = { priority: basePriority, alwaysShow: false, options: intOptions };
            return (waypoint) => {
                if (waypoint instanceof AirportWaypoint) {
                    return airportStyle[waypoint.size];
                }
                else if (waypoint instanceof msfssdk.FacilityWaypoint) {
                    switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                        case msfssdk.FacilityType.VOR:
                            return vorStyle;
                        case msfssdk.FacilityType.NDB:
                            return ndbStyle;
                        case msfssdk.FacilityType.Intersection:
                            return intStyle;
                        case msfssdk.FacilityType.USR:
                            return userStyle;
                    }
                }
                return defaultStyle;
            };
        }
        /**
         * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a highlight
         * role.
         * @param offset The label offset, in pixels.
         * @param fontSize The font size of the label, in pixels.
         * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a highlight
         * role.
         */
        static createNextGenHighlightLabelOptions(offset, fontSize) {
            return {
                anchor: msfssdk.Vec2Math.create(0.5, 1),
                offset,
                font: 'Roboto-Bold',
                fontSize,
                fontColor: 'black',
                fontOutlineWidth: 0,
                showBg: true,
                bgPadding: msfssdk.VecNMath.create(4, 1, 1, 1, 1),
                bgColor: 'white',
                bgOutlineWidth: 1,
                bgOutlineColor: 'black'
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for VNAV waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for VNAV waypoints.
         */
        static nextGenVNavIconStyles(basePriority, scale = 1) {
            const vnavStyle = { priority: basePriority, size: msfssdk.Vec2Math.create(32 * scale, 32 * scale) };
            return () => {
                return vnavStyle;
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for VNAV waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for VNAV waypoints.
         */
        static nextGenVNavLabelStyles(basePriority, scale = 1) {
            const vnavStyle = {
                priority: basePriority,
                alwaysShow: true,
                options: MapWaypointStyles.createNextGenNormalLabelOptions(msfssdk.Vec2Math.create(0, -8 * scale), 16 * scale)
            };
            return () => {
                return vnavStyle;
            };
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure preview waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure preview waypoints.
         */
        static nextGenProcPreviewIconStyles(basePriority, scale = 1) {
            return MapWaypointStyles.nextGenFlightPlanIconStyles(false, basePriority, scale);
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview waypoints.
         */
        static nextGenProcPreviewLabelStyles(basePriority, scale = 1) {
            return MapWaypointStyles.nextGenFlightPlanLabelStyles(false, basePriority, scale);
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure transition preview
         * waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure transition
         * preview waypoints.
         */
        static nextGenProcTransitionPreviewIconStyles(basePriority, scale = 1) {
            return MapWaypointStyles.nextGenNormalIconStyles(basePriority, scale);
        }
        /**
         * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for procedure transition preview
         * waypoints.
         * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
         * `[baseIconPriority, baseIconPriority + 1)`.
         * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
         * `1`.
         * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview transition
         * waypoints.
         */
        static nextGenProcTransitionPreviewLabelStyles(basePriority, scale = 1) {
            return MapWaypointStyles.nextGenNormalLabelStyles(basePriority, scale);
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     * Builds next-generation (NXi, G3000, etc) Garmin HSI maps.
     */
    class NextGenHsiMapBuilder {
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin HSI map.
         *
         * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
         * the range of the map.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.targetOffset) !== null && _a !== void 0 ? _a : (options.targetOffset = msfssdk.Vec2Math.create());
            (_b = options.rangeEndpoints) !== null && _b !== void 0 ? _b : (options.rangeEndpoints = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0));
            (_c = options.supportDataIntegrity) !== null && _c !== void 0 ? _c : (options.supportDataIntegrity = true);
            (_d = options.useRangeUserSettingByDefault) !== null && _d !== void 0 ? _d : (options.useRangeUserSettingByDefault = true);
            (_e = options.useDeclutterUserSetting) !== null && _e !== void 0 ? _e : (options.useDeclutterUserSetting = true);
            (_f = options.useTerrainUserSettings) !== null && _f !== void 0 ? _f : (options.useTerrainUserSettings = true);
            (_g = options.allowRelativeTerrainMode) !== null && _g !== void 0 ? _g : (options.allowRelativeTerrainMode = true);
            (_h = options.nexradMinRangeIndex) !== null && _h !== void 0 ? _h : (options.nexradMinRangeIndex = 13);
            (_j = options.useNexradUserSettings) !== null && _j !== void 0 ? _j : (options.useNexradUserSettings = true);
            (_k = options.includeAirspaces) !== null && _k !== void 0 ? _k : (options.includeAirspaces = true);
            (_l = options.useAirspaceVisUserSettings) !== null && _l !== void 0 ? _l : (options.useAirspaceVisUserSettings = true);
            (_m = options.useWaypointVisUserSettings) !== null && _m !== void 0 ? _m : (options.useWaypointVisUserSettings = true);
            (_o = options.includeTrackVector) !== null && _o !== void 0 ? _o : (options.includeTrackVector = true);
            (_p = options.useTrackVectorUserSettings) !== null && _p !== void 0 ? _p : (options.useTrackVectorUserSettings = true);
            (_q = options.includeAltitudeArc) !== null && _q !== void 0 ? _q : (options.includeAltitudeArc = true);
            (_r = options.useAltitudeArcUserSettings) !== null && _r !== void 0 ? _r : (options.useAltitudeArcUserSettings = true);
            (_s = options.includeRangeIndicator) !== null && _s !== void 0 ? _s : (options.includeRangeIndicator = true);
            (_t = options.includeDetailIndicator) !== null && _t !== void 0 ? _t : (options.includeDetailIndicator = true);
            (_u = options.includeTrafficOffScaleIndicator) !== null && _u !== void 0 ? _u : (options.includeTrafficOffScaleIndicator = true);
            (_v = options.includeTrafficStatusIndicator) !== null && _v !== void 0 ? _v : (options.includeTrafficStatusIndicator = true);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.range, (_w = options.nauticalRangeArray) !== null && _w !== void 0 ? _w : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Nautical), (_x = options.metricRangeArray) !== null && _x !== void 0 ? _x : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Metric), options.settingManager, options.useRangeUserSettingByDefault)
                .with(GarminMapBuilder.orientation, { [exports.MapOrientation.HeadingUp]: options.targetOffset }, { [exports.MapOrientation.HeadingUp]: options.rangeEndpoints })
                .withController('hsiMapOrientation', context => {
                const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                const orientationControlConsumer = {
                    priority: Number.MAX_SAFE_INTEGER,
                    onAcquired: () => {
                        orientationModule.orientation.set(exports.MapOrientation.HeadingUp);
                    },
                    onCeded: () => { }
                };
                let controller;
                return controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].claim(orientationControlConsumer);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].forfeit(orientationControlConsumer);
                    }
                });
            })
                .with(GarminMapBuilder.declutter, options.useDeclutterUserSetting ? options.settingManager : undefined)
                .withBing(options.bingId)
                .with(GarminMapBuilder.terrainColors, {
                [exports.MapTerrainMode.None]: MapUtils.noTerrainEarthColors(),
                [exports.MapTerrainMode.Absolute]: MapUtils.absoluteTerrainEarthColors(),
                [exports.MapTerrainMode.Relative]: MapUtils.relativeTerrainEarthColors()
            }, options.useTerrainUserSettings ? options.settingManager : undefined, options.allowRelativeTerrainMode)
                .with(GarminMapBuilder.nexrad, options.nexradMinRangeIndex, options.useNexradUserSettings ? options.settingManager : undefined, exports.MapDeclutterMode.Level2);
            if (options.includeAirspaces) {
                mapBuilder.with(GarminMapBuilder.airspaces, options.useAirspaceVisUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.waypoints, (builder) => {
                builder.withNormalStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenNormalIconStyles(1, options.waypointStyleScale), MapWaypointStyles.nextGenNormalLabelStyles(1, options.waypointStyleScale));
            }, options.useWaypointVisUserSettings ? options.settingManager : undefined);
            if (options.flightPlanner) {
                mapBuilder.with(GarminMapBuilder.activeFlightPlan, options.flightPlanner, new DefaultFlightPathPlanRenderer(), false, (builder) => {
                    builder
                        .withFlightPlanInactiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(false, 2, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(false, 2, options.waypointStyleScale))
                        .withFlightPlanActiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(true, 3, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(true, 3, options.waypointStyleScale))
                        .withVNavStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenVNavIconStyles(4, options.waypointStyleScale), MapWaypointStyles.nextGenVNavLabelStyles(4, options.waypointStyleScale));
                }, false);
            }
            mapBuilder
                .with(GarminMapBuilder.waypointHighlight, false, (builder) => {
                builder.withHighlightStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenHighlightIconStyles(5, options.waypointStyleScale), MapWaypointStyles.nextGenHighlightLabelStyles(5, options.waypointStyleScale));
            });
            if (options.includeTrackVector) {
                mapBuilder.with(GarminMapBuilder.trackVector, {
                    arcTurnRateThreshold: 0.25,
                    arcMaxLookaheadTime: msfssdk.UnitType.SECOND.createNumber(60)
                }, options.useTrackVectorUserSettings ? options.settingManager : undefined);
            }
            if (options.includeAltitudeArc) {
                mapBuilder
                    .withAutopilotProps(['selectedAltitude'], options.dataUpdateFreq)
                    .with(GarminMapBuilder.altitudeArc, {
                    verticalSpeedPrecision: msfssdk.UnitType.FPM.createNumber(50),
                    verticalSpeedThreshold: msfssdk.UnitType.FPM.createNumber(150),
                    altitudeDeviationThreshold: msfssdk.UnitType.FOOT.createNumber(150)
                }, options.useAltitudeArcUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.crosshair);
            const supportTraffic = options.trafficSystem !== undefined
                && options.trafficIconOptions !== undefined;
            let offScale;
            if (supportTraffic && options.includeTrafficOffScaleIndicator) {
                offScale = msfssdk.Subject.create(exports.MapTrafficOffScaleStatus.None);
            }
            if (supportTraffic) {
                const iconOptions = Object.assign({}, options.trafficIconOptions);
                (_y = iconOptions.drawOffScale) !== null && _y !== void 0 ? _y : (iconOptions.drawOffScale = false);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (_z = iconOptions.supportAdsbVector) !== null && _z !== void 0 ? _z : (iconOptions.supportAdsbVector = options.trafficSystem.adsb !== null);
                mapBuilder
                    .withController('hsiMapTrafficOuterRange', context => {
                    let controller;
                    let rangePipe;
                    return controller = new msfssdk.MapSystemGenericController(context, {
                        onAfterMapRender: (contextArg) => {
                            rangePipe = contextArg.model.getModule(GarminMapKeys.Range).nominalRangeIndex.pipe(contextArg.model.getModule(GarminMapKeys.Traffic).outerRangeIndex);
                        },
                        onMapDestroyed: () => {
                            controller.destroy();
                        },
                        onDestroyed: () => {
                            rangePipe === null || rangePipe === void 0 ? void 0 : rangePipe.destroy();
                        }
                    });
                })
                    .with(GarminMapBuilder.traffic, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.trafficSystem, iconOptions, true, offScale, undefined, undefined, options.trafficSettingManager, options.settingManager);
            }
            let airplaneIconSrc = options.airplaneIconSrc;
            let airplaneIconAnchor = options.airplaneIconAnchor;
            if (options.supportDataIntegrity && options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                airplaneIconSrc = msfssdk.Subject.create('');
                airplaneIconAnchor = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            }
            const airplanePropBindings = [
                'position', 'hdgTrue', 'magVar', 'isOnGround',
                ...(options.includeTrackVector || options.includeAltitudeArc
                    ? ['groundSpeed', 'trackTrue']
                    : []),
                ...(options.includeTrackVector
                    ? ['turnRate']
                    : []),
                ...(options.includeAltitudeArc
                    ? ['altitude', 'verticalSpeed']
                    : [])
            ];
            mapBuilder
                .withOwnAirplaneIcon(options.airplaneIconSize, airplaneIconSrc, airplaneIconAnchor)
                .withOwnAirplanePropBindings(airplanePropBindings, options.dataUpdateFreq)
                .withFollowAirplane();
            // Bottom-left indicators
            if (options.includeDetailIndicator || options.includeRangeIndicator) {
                const detailRef = msfssdk.FSComponent.createRef();
                const rangeRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeDetailIndicator) {
                    factories.push((context) => {
                        const declutterModule = context.model.getModule(GarminMapKeys.Declutter);
                        return (msfssdk.FSComponent.buildComponent(MapDetailIndicator, { ref: detailRef, declutterMode: declutterModule.mode, showTitle: false }));
                    });
                }
                if (options.includeRangeIndicator) {
                    factories.push((context) => {
                        const rangeModule = context.model.getModule(GarminMapKeys.Range);
                        const unitsModule = context.model.getModule(GarminMapKeys.Units);
                        return (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { ref: rangeRef, range: rangeModule.nominalRange, displayUnit: unitsModule.distanceLarge }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomLeftIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = detailRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = rangeRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-left');
            }
            // Bottom-center indicators
            if (supportTraffic && (options.includeTrafficOffScaleIndicator || options.includeTrafficStatusIndicator)) {
                const statusRef = msfssdk.FSComponent.createRef();
                const offScaleRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeTrafficOffScaleIndicator) {
                    factories.push(() => {
                        return (msfssdk.FSComponent.buildComponent(MapTrafficOffScaleIndicator, { ref: offScaleRef, status: offScale }));
                    });
                }
                if (options.includeTrafficStatusIndicator) {
                    factories.push((context) => {
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(MapTrafficStatusIndicator, { ref: statusRef, show: trafficModule.show, operatingMode: trafficModule.operatingMode }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomCenterIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = statusRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = offScaleRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-center');
            }
            if (options.supportDataIntegrity) {
                let airplaneIconSrcToUse;
                let airplaneIconAnchorToUse;
                if (options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                    airplaneIconSrcToUse = airplaneIconSrc;
                    airplaneIconAnchorToUse = airplaneIconAnchor;
                }
                mapBuilder.with(GarminMapBuilder.dataIntegrity, airplaneIconSrcToUse, airplaneIconAnchorToUse, options.airplaneIconSrc, options.airplaneIconAnchor, options.noHeadingAirplaneIconSrc, options.noHeadingAirplaneIconAnchor);
            }
            return mapBuilder;
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     * Builds next-generation (NXi, G3000, etc) Garmin navigation maps.
     */
    class NextGenNavMapBuilder {
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin navigation map.
         *
         * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
         * the range of the map.
         *
         * If flight plan focus is supported, the module `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule` is added
         * to the map model and can be used to control the focus.
         *
         * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
         * map context and can be used to control the pointer.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13;
            var _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.targetOffsets) !== null && _a !== void 0 ? _a : (options.targetOffsets = {});
            (_b = (_14 = options.targetOffsets)[_15 = exports.MapOrientation.NorthUp]) !== null && _b !== void 0 ? _b : (_14[_15] = msfssdk.Vec2Math.create());
            (_c = (_16 = options.targetOffsets)[_17 = exports.MapOrientation.HeadingUp]) !== null && _c !== void 0 ? _c : (_16[_17] = msfssdk.Vec2Math.create(0, 0.17));
            (_d = (_18 = options.targetOffsets)[_19 = exports.MapOrientation.TrackUp]) !== null && _d !== void 0 ? _d : (_18[_19] = msfssdk.Vec2Math.create(0, 0.17));
            (_e = options.rangeEndpoints) !== null && _e !== void 0 ? _e : (options.rangeEndpoints = {});
            (_f = (_20 = options.rangeEndpoints)[_21 = exports.MapOrientation.NorthUp]) !== null && _f !== void 0 ? _f : (_20[_21] = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0.25));
            (_g = (_22 = options.rangeEndpoints)[_23 = exports.MapOrientation.HeadingUp]) !== null && _g !== void 0 ? _g : (_22[_23] = msfssdk.VecNMath.create(4, 0.5, 0.67, 0.5, 0.33));
            (_h = (_24 = options.rangeEndpoints)[_25 = exports.MapOrientation.TrackUp]) !== null && _h !== void 0 ? _h : (_24[_25] = msfssdk.VecNMath.create(4, 0.5, 0.67, 0.5, 0.33));
            (_j = options.supportDataIntegrity) !== null && _j !== void 0 ? _j : (options.supportDataIntegrity = true);
            (_k = options.useRangeUserSettingByDefault) !== null && _k !== void 0 ? _k : (options.useRangeUserSettingByDefault = true);
            (_l = options.useOrientationUserSettings) !== null && _l !== void 0 ? _l : (options.useOrientationUserSettings = true);
            (_m = options.useDeclutterUserSetting) !== null && _m !== void 0 ? _m : (options.useDeclutterUserSetting = true);
            (_o = options.useTerrainUserSettings) !== null && _o !== void 0 ? _o : (options.useTerrainUserSettings = true);
            (_p = options.allowRelativeTerrainMode) !== null && _p !== void 0 ? _p : (options.allowRelativeTerrainMode = true);
            (_q = options.nexradMinRangeIndex) !== null && _q !== void 0 ? _q : (options.nexradMinRangeIndex = 13);
            (_r = options.useNexradUserSettings) !== null && _r !== void 0 ? _r : (options.useNexradUserSettings = true);
            (_s = (_26 = options.rangeRingOptions).labelRadial) !== null && _s !== void 0 ? _s : (_26.labelRadial = 225);
            (_t = options.includeAirspaces) !== null && _t !== void 0 ? _t : (options.includeAirspaces = true);
            (_u = options.useAirspaceVisUserSettings) !== null && _u !== void 0 ? _u : (options.useAirspaceVisUserSettings = true);
            (_v = options.useWaypointVisUserSettings) !== null && _v !== void 0 ? _v : (options.useWaypointVisUserSettings = true);
            (_w = options.drawEntirePlan) !== null && _w !== void 0 ? _w : (options.drawEntirePlan = false);
            (_x = options.supportFlightPlanFocus) !== null && _x !== void 0 ? _x : (options.supportFlightPlanFocus = false);
            (_y = options.defaultFocusRangeIndex) !== null && _y !== void 0 ? _y : (options.defaultFocusRangeIndex = 17);
            (_z = options.includeTrackVector) !== null && _z !== void 0 ? _z : (options.includeTrackVector = true);
            (_0 = options.useTrackVectorUserSettings) !== null && _0 !== void 0 ? _0 : (options.useTrackVectorUserSettings = true);
            (_1 = options.includeAltitudeArc) !== null && _1 !== void 0 ? _1 : (options.includeAltitudeArc = true);
            (_2 = options.useAltitudeArcUserSettings) !== null && _2 !== void 0 ? _2 : (options.useAltitudeArcUserSettings = true);
            (_3 = options.includeOrientationIndicator) !== null && _3 !== void 0 ? _3 : (options.includeOrientationIndicator = true);
            (_4 = options.includeRangeIndicator) !== null && _4 !== void 0 ? _4 : (options.includeRangeIndicator = false);
            (_5 = options.includeDetailIndicator) !== null && _5 !== void 0 ? _5 : (options.includeDetailIndicator = true);
            (_6 = options.showDetailIndicatorTitle) !== null && _6 !== void 0 ? _6 : (options.showDetailIndicatorTitle = true);
            (_7 = options.includeTrafficOffScaleIndicator) !== null && _7 !== void 0 ? _7 : (options.includeTrafficOffScaleIndicator = true);
            (_8 = options.includeTerrainScale) !== null && _8 !== void 0 ? _8 : (options.includeTerrainScale = true);
            (_9 = options.includeTrafficStatusIndicator) !== null && _9 !== void 0 ? _9 : (options.includeTrafficStatusIndicator = true);
            (_10 = options.showTrafficAltRestriction) !== null && _10 !== void 0 ? _10 : (options.showTrafficAltRestriction = true);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.range, (_11 = options.nauticalRangeArray) !== null && _11 !== void 0 ? _11 : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Nautical), (_12 = options.metricRangeArray) !== null && _12 !== void 0 ? _12 : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Metric), options.settingManager, options.useRangeUserSettingByDefault)
                .with(GarminMapBuilder.orientation, options.targetOffsets, options.rangeEndpoints, options.useOrientationUserSettings ? options.settingManager : undefined)
                .with(GarminMapBuilder.declutter, options.useDeclutterUserSetting ? options.settingManager : undefined)
                .withBing(options.bingId)
                .with(GarminMapBuilder.terrainColors, {
                [exports.MapTerrainMode.None]: MapUtils.noTerrainEarthColors(),
                [exports.MapTerrainMode.Absolute]: MapUtils.absoluteTerrainEarthColors(),
                [exports.MapTerrainMode.Relative]: MapUtils.relativeTerrainEarthColors()
            }, options.useTerrainUserSettings ? options.settingManager : undefined, options.allowRelativeTerrainMode)
                .with(GarminMapBuilder.nexrad, options.nexradMinRangeIndex, options.useNexradUserSettings ? options.settingManager : undefined, exports.MapDeclutterMode.Level2);
            if (options.includeAirspaces) {
                mapBuilder.with(GarminMapBuilder.airspaces, options.useAirspaceVisUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.waypoints, (builder) => {
                builder.withNormalStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenNormalIconStyles(1, options.waypointStyleScale), MapWaypointStyles.nextGenNormalLabelStyles(1, options.waypointStyleScale));
            }, options.useWaypointVisUserSettings ? options.settingManager : undefined);
            if (options.flightPlanner) {
                if (options.supportFlightPlanFocus) {
                    mapBuilder.with(GarminMapBuilder.flightPlanFocus, options.nominalFocusMargins, options.defaultFocusRangeIndex);
                }
                mapBuilder.with(GarminMapBuilder.activeFlightPlan, options.flightPlanner, new DefaultFlightPathPlanRenderer(), options.drawEntirePlan, (builder) => {
                    builder
                        .withFlightPlanInactiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(false, 2, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(false, 2, options.waypointStyleScale))
                        .withFlightPlanActiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(true, 3, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(true, 3, options.waypointStyleScale))
                        .withVNavStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenVNavIconStyles(4, options.waypointStyleScale), MapWaypointStyles.nextGenVNavLabelStyles(4, options.waypointStyleScale));
                }, options.supportFlightPlanFocus);
            }
            mapBuilder
                .with(GarminMapBuilder.waypointHighlight, false, (builder) => {
                builder.withHighlightStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenHighlightIconStyles(5, options.waypointStyleScale), MapWaypointStyles.nextGenHighlightLabelStyles(5, options.waypointStyleScale));
            });
            mapBuilder
                .with(GarminMapBuilder.rangeRing, options.rangeRingOptions)
                .with(GarminMapBuilder.rangeCompass, options.rangeCompassOptions);
            if (options.includeTrackVector) {
                mapBuilder.with(GarminMapBuilder.trackVector, {
                    arcTurnRateThreshold: 0.25,
                    arcMaxLookaheadTime: msfssdk.UnitType.SECOND.createNumber(60)
                }, options.useTrackVectorUserSettings ? options.settingManager : undefined);
            }
            if (options.includeAltitudeArc) {
                mapBuilder
                    .withAutopilotProps(['selectedAltitude'], options.dataUpdateFreq)
                    .with(GarminMapBuilder.altitudeArc, {
                    verticalSpeedPrecision: msfssdk.UnitType.FPM.createNumber(50),
                    verticalSpeedThreshold: msfssdk.UnitType.FPM.createNumber(150),
                    altitudeDeviationThreshold: msfssdk.UnitType.FOOT.createNumber(150)
                }, options.useAltitudeArcUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.crosshair);
            const supportTraffic = options.trafficSystem !== undefined
                && options.trafficIconOptions !== undefined;
            let offScale;
            if (supportTraffic && options.includeTrafficOffScaleIndicator) {
                offScale = msfssdk.Subject.create(exports.MapTrafficOffScaleStatus.None);
            }
            if (supportTraffic) {
                const iconOptions = Object.assign({}, options.trafficIconOptions);
                iconOptions.drawOffScale = false;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (_13 = iconOptions.supportAdsbVector) !== null && _13 !== void 0 ? _13 : (iconOptions.supportAdsbVector = options.trafficSystem.adsb !== null);
                mapBuilder.with(GarminMapBuilder.traffic, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.trafficSystem, iconOptions, false, offScale, undefined, undefined, options.trafficSettingManager, options.settingManager);
            }
            let airplaneIconSrc = options.airplaneIconSrc;
            let airplaneIconAnchor = options.airplaneIconAnchor;
            if (options.supportDataIntegrity && options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                airplaneIconSrc = msfssdk.Subject.create('');
                airplaneIconAnchor = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            }
            const airplanePropBindings = [
                'position', 'hdgTrue', 'magVar', 'isOnGround',
                ...(options.includeTrackVector || options.includeAltitudeArc
                    ? ['groundSpeed', 'trackTrue']
                    : []),
                ...(options.includeTrackVector
                    ? ['turnRate']
                    : []),
                ...(options.includeAltitudeArc
                    ? ['altitude', 'verticalSpeed']
                    : [])
            ];
            mapBuilder
                .withOwnAirplaneIcon(options.airplaneIconSize, airplaneIconSrc, airplaneIconAnchor)
                .withOwnAirplanePropBindings(airplanePropBindings, options.dataUpdateFreq)
                .withFollowAirplane();
            if (options.miniCompassImgSrc !== undefined) {
                mapBuilder.with(GarminMapBuilder.miniCompass, options.miniCompassImgSrc);
            }
            // Top-left indicators
            if (options.includeOrientationIndicator || options.includeRangeIndicator) {
                const orientationRef = msfssdk.FSComponent.createRef();
                const rangeRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeOrientationIndicator) {
                    factories.push((context) => {
                        var _a, _b;
                        const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                        const pointerModule = context.model.getModule(GarminMapKeys.Pointer);
                        const focusModule = context.model.getModule(GarminMapKeys.FlightPlanFocus);
                        const isVisible = msfssdk.MappedSubject.create(([isPointerActive, isFocusActive]) => !isPointerActive && !isFocusActive, (_a = pointerModule === null || pointerModule === void 0 ? void 0 : pointerModule.isActive) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(false), (_b = focusModule === null || focusModule === void 0 ? void 0 : focusModule.isActive) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(false));
                        return (msfssdk.FSComponent.buildComponent(MapOrientationIndicator, { ref: orientationRef, orientation: orientationModule.orientation, text: {
                                [exports.MapOrientation.NorthUp]: 'NORTH UP',
                                [exports.MapOrientation.HeadingUp]: 'HDG UP',
                                [exports.MapOrientation.TrackUp]: 'TRK UP',
                            }, isVisible: isVisible }));
                    });
                }
                if (options.includeRangeIndicator) {
                    factories.push((context) => {
                        const rangeModule = context.model.getModule(GarminMapKeys.Range);
                        const unitsModule = context.model.getModule(GarminMapKeys.Units);
                        return (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { ref: rangeRef, range: rangeModule.nominalRange, displayUnit: unitsModule.distanceLarge }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopLeftIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = orientationRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = rangeRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-top-left');
            }
            // Bottom-left indicators
            if (options.includeDetailIndicator || (supportTraffic && options.includeTrafficOffScaleIndicator)) {
                const detailRef = msfssdk.FSComponent.createRef();
                const offScaleRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeDetailIndicator) {
                    factories.push((context) => {
                        const declutterModule = context.model.getModule(GarminMapKeys.Declutter);
                        return (msfssdk.FSComponent.buildComponent(MapDetailIndicator, { ref: detailRef, declutterMode: declutterModule.mode, showTitle: options.showDetailIndicatorTitle }));
                    });
                }
                if (supportTraffic && options.includeTrafficOffScaleIndicator) {
                    factories.push(() => {
                        return (msfssdk.FSComponent.buildComponent(MapTrafficOffScaleIndicator, { ref: offScaleRef, status: offScale }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomLeftIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = detailRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = offScaleRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-left');
            }
            // Bottom-right indicators
            if (options.includeTerrainScale || (supportTraffic && options.includeTrafficStatusIndicator)) {
                const scaleRef = msfssdk.FSComponent.createRef();
                const trafficRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (supportTraffic && options.includeTrafficStatusIndicator) {
                    factories.push((context) => {
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(MapTrafficStatusIndicator, { ref: trafficRef, show: trafficModule.show, operatingMode: trafficModule.operatingMode, altitudeRestrictionMode: options.showTrafficAltRestriction ? trafficModule.altitudeRestrictionMode : undefined }));
                    });
                }
                if (options.includeTerrainScale) {
                    factories.push((context) => {
                        const terrainModule = context.model.getModule(GarminMapKeys.Terrain);
                        return (msfssdk.FSComponent.buildComponent(MapTerrainScaleIndicator, { ref: scaleRef, show: terrainModule.showScale, terrainMode: terrainModule.terrainMode }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomRightIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = scaleRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = trafficRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-right');
            }
            // Center indicators
            if (options.supportDataIntegrity) {
                const noGpsRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.supportDataIntegrity) {
                    factories.push((context) => {
                        const dataIntegrityModule = context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
                        return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { ref: noGpsRef, show: dataIntegrityModule.gpsSignalValid.map(isValid => !isValid), class: 'map-banner-no-gps' }, "NO GPS POSITION"));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.CenterIndicators, factories, {
                    onDetached: () => {
                        var _a;
                        (_a = noGpsRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                    }
                }, 'map-indicator-group-center');
            }
            if (options.pointerBoundsOffset !== undefined) {
                mapBuilder.with(GarminMapBuilder.pointer, options.pointerBoundsOffset);
                if (options.pointerInfoSize !== undefined) {
                    mapBuilder.with(GarminMapBuilder.pointerInfo, options.pointerInfoSize);
                }
            }
            if (options.supportDataIntegrity) {
                let airplaneIconSrcToUse;
                let airplaneIconAnchorToUse;
                if (options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                    airplaneIconSrcToUse = airplaneIconSrc;
                    airplaneIconAnchorToUse = airplaneIconAnchor;
                }
                mapBuilder.with(GarminMapBuilder.dataIntegrity, airplaneIconSrcToUse, airplaneIconAnchorToUse, options.airplaneIconSrc, options.airplaneIconAnchor, options.noHeadingAirplaneIconSrc, options.noHeadingAirplaneIconAnchor);
            }
            return mapBuilder;
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    class NextGenNearestMapBuilder {
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin nearest waypoint map.
         *
         * The module `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule` is added to the map model and can be
         * used to control the highlighted waypoint.
         *
         * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
         * the range of the map.
         *
         * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
         * map context and can be used to control the pointer.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
            var _5;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.defaultNoTargetRangeIndex) !== null && _a !== void 0 ? _a : (options.defaultNoTargetRangeIndex = null);
            (_b = options.targetOffset) !== null && _b !== void 0 ? _b : (options.targetOffset = msfssdk.Vec2Math.create());
            (_c = options.rangeEndpoints) !== null && _c !== void 0 ? _c : (options.rangeEndpoints = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0.25));
            (_d = options.supportDataIntegrity) !== null && _d !== void 0 ? _d : (options.supportDataIntegrity = true);
            (_e = options.useRangeUserSettingByDefault) !== null && _e !== void 0 ? _e : (options.useRangeUserSettingByDefault = true);
            (_f = options.useDeclutterUserSetting) !== null && _f !== void 0 ? _f : (options.useDeclutterUserSetting = true);
            (_g = options.useTerrainUserSettings) !== null && _g !== void 0 ? _g : (options.useTerrainUserSettings = true);
            (_h = options.allowRelativeTerrainMode) !== null && _h !== void 0 ? _h : (options.allowRelativeTerrainMode = true);
            (_j = options.nexradMinRangeIndex) !== null && _j !== void 0 ? _j : (options.nexradMinRangeIndex = 13);
            (_k = options.useNexradUserSettings) !== null && _k !== void 0 ? _k : (options.useNexradUserSettings = false);
            (_l = (_5 = options.rangeRingOptions).labelRadial) !== null && _l !== void 0 ? _l : (_5.labelRadial = 225);
            (_m = options.includeAirspaces) !== null && _m !== void 0 ? _m : (options.includeAirspaces = true);
            (_o = options.useAirspaceVisUserSettings) !== null && _o !== void 0 ? _o : (options.useAirspaceVisUserSettings = true);
            (_p = options.useWaypointVisUserSettings) !== null && _p !== void 0 ? _p : (options.useWaypointVisUserSettings = true);
            (_q = options.includeTrackVector) !== null && _q !== void 0 ? _q : (options.includeTrackVector = true);
            (_r = options.useTrackVectorUserSettings) !== null && _r !== void 0 ? _r : (options.useTrackVectorUserSettings = true);
            (_s = options.includeAltitudeArc) !== null && _s !== void 0 ? _s : (options.includeAltitudeArc = true);
            (_t = options.useAltitudeArcUserSettings) !== null && _t !== void 0 ? _t : (options.useAltitudeArcUserSettings = true);
            (_u = options.includeOrientationIndicator) !== null && _u !== void 0 ? _u : (options.includeOrientationIndicator = true);
            (_v = options.includeRangeIndicator) !== null && _v !== void 0 ? _v : (options.includeRangeIndicator = false);
            (_w = options.includeDetailIndicator) !== null && _w !== void 0 ? _w : (options.includeDetailIndicator = true);
            (_x = options.showDetailIndicatorTitle) !== null && _x !== void 0 ? _x : (options.showDetailIndicatorTitle = true);
            (_y = options.includeTrafficOffScaleIndicator) !== null && _y !== void 0 ? _y : (options.includeTrafficOffScaleIndicator = true);
            (_z = options.includeTerrainScale) !== null && _z !== void 0 ? _z : (options.includeTerrainScale = true);
            (_0 = options.includeTrafficStatusIndicator) !== null && _0 !== void 0 ? _0 : (options.includeTrafficStatusIndicator = true);
            (_1 = options.showTrafficAltRestriction) !== null && _1 !== void 0 ? _1 : (options.showTrafficAltRestriction = true);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.range, (_2 = options.nauticalRangeArray) !== null && _2 !== void 0 ? _2 : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Nautical), (_3 = options.metricRangeArray) !== null && _3 !== void 0 ? _3 : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Metric), options.settingManager, options.useRangeUserSettingByDefault)
                .with(GarminMapBuilder.orientation, { [exports.MapOrientation.NorthUp]: options.targetOffset }, { [exports.MapOrientation.NorthUp]: options.rangeEndpoints })
                .withController('nearestMapOrientation', context => {
                const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                const orientationControlConsumer = {
                    priority: Number.MAX_SAFE_INTEGER,
                    onAcquired: () => {
                        orientationModule.orientation.set(exports.MapOrientation.NorthUp);
                    },
                    onCeded: () => { }
                };
                let controller;
                return controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].claim(orientationControlConsumer);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].forfeit(orientationControlConsumer);
                    }
                });
            })
                .with(GarminMapBuilder.declutter, options.useDeclutterUserSetting ? options.settingManager : undefined)
                .withBing(options.bingId)
                .with(GarminMapBuilder.terrainColors, {
                [exports.MapTerrainMode.None]: MapUtils.noTerrainEarthColors(),
                [exports.MapTerrainMode.Absolute]: MapUtils.absoluteTerrainEarthColors(),
                [exports.MapTerrainMode.Relative]: MapUtils.relativeTerrainEarthColors()
            }, options.useTerrainUserSettings ? options.settingManager : undefined, options.allowRelativeTerrainMode)
                .with(GarminMapBuilder.nexrad, options.nexradMinRangeIndex, options.useNexradUserSettings ? options.settingManager : undefined, exports.MapDeclutterMode.Level2);
            if (options.includeAirspaces) {
                mapBuilder.with(GarminMapBuilder.airspaces, options.useAirspaceVisUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.waypoints, (builder) => {
                builder.withNormalStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenNormalIconStyles(1, options.waypointStyleScale), MapWaypointStyles.nextGenNormalLabelStyles(1, options.waypointStyleScale));
            }, options.useWaypointVisUserSettings ? options.settingManager : undefined);
            if (options.flightPlanner) {
                mapBuilder.with(GarminMapBuilder.activeFlightPlan, options.flightPlanner, new DefaultFlightPathPlanRenderer(), false, (builder) => {
                    builder
                        .withFlightPlanInactiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(false, 2, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(false, 2, options.waypointStyleScale))
                        .withFlightPlanActiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(true, 3, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(true, 3, options.waypointStyleScale))
                        .withVNavStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenVNavIconStyles(4, options.waypointStyleScale), MapWaypointStyles.nextGenVNavLabelStyles(4, options.waypointStyleScale));
                }, false);
            }
            if (typeof options.defaultNoTargetRangeIndex === 'number') {
                options.defaultNoTargetRangeIndex = msfssdk.Subject.create(options.defaultNoTargetRangeIndex);
            }
            mapBuilder
                .with(GarminMapBuilder.waypointHighlight, true, (builder) => {
                builder.withHighlightStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenHighlightIconStyles(5, options.waypointStyleScale), MapWaypointStyles.nextGenHighlightLabelStyles(5, options.waypointStyleScale));
            }, options.lineOptions)
                .withController(GarminMapKeys.Nearest, context => {
                return new NearestMapRTRController(context, options.defaultNoTargetRangeIndex);
            });
            mapBuilder
                .with(GarminMapBuilder.rangeRing, options.rangeRingOptions);
            if (options.includeTrackVector) {
                mapBuilder.with(GarminMapBuilder.trackVector, {
                    arcTurnRateThreshold: 0.25,
                    arcMaxLookaheadTime: msfssdk.UnitType.SECOND.createNumber(60)
                }, options.useTrackVectorUserSettings ? options.settingManager : undefined);
            }
            if (options.includeAltitudeArc) {
                mapBuilder
                    .withAutopilotProps(['selectedAltitude'], options.dataUpdateFreq)
                    .with(GarminMapBuilder.altitudeArc, {
                    verticalSpeedPrecision: msfssdk.UnitType.FPM.createNumber(50),
                    verticalSpeedThreshold: msfssdk.UnitType.FPM.createNumber(150),
                    altitudeDeviationThreshold: msfssdk.UnitType.FOOT.createNumber(150)
                }, options.useAltitudeArcUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.crosshair);
            const supportTraffic = options.trafficSystem !== undefined
                && options.trafficIconOptions !== undefined;
            let offScale;
            if (supportTraffic && options.includeTrafficOffScaleIndicator) {
                offScale = msfssdk.Subject.create(exports.MapTrafficOffScaleStatus.None);
            }
            if (supportTraffic) {
                const iconOptions = Object.assign({}, options.trafficIconOptions);
                iconOptions.drawOffScale = false;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (_4 = iconOptions.supportAdsbVector) !== null && _4 !== void 0 ? _4 : (iconOptions.supportAdsbVector = options.trafficSystem.adsb !== null);
                mapBuilder.with(GarminMapBuilder.traffic, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.trafficSystem, iconOptions, false, offScale, undefined, undefined, options.trafficSettingManager, options.settingManager);
            }
            let airplaneIconSrc = options.airplaneIconSrc;
            let airplaneIconAnchor = options.airplaneIconAnchor;
            if (options.supportDataIntegrity && options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                airplaneIconSrc = msfssdk.Subject.create('');
                airplaneIconAnchor = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            }
            const airplanePropBindings = [
                'position', 'hdgTrue', 'magVar', 'isOnGround',
                ...(options.includeTrackVector || options.includeAltitudeArc
                    ? ['groundSpeed', 'trackTrue']
                    : []),
                ...(options.includeTrackVector
                    ? ['turnRate']
                    : []),
                ...(options.includeAltitudeArc
                    ? ['altitude', 'verticalSpeed']
                    : [])
            ];
            mapBuilder
                .withOwnAirplaneIcon(options.airplaneIconSize, airplaneIconSrc, airplaneIconAnchor)
                .withOwnAirplanePropBindings(airplanePropBindings, options.dataUpdateFreq)
                .withFollowAirplane();
            if (options.miniCompassImgSrc !== undefined) {
                mapBuilder.with(GarminMapBuilder.miniCompass, options.miniCompassImgSrc);
            }
            // Top-left indicators
            if (options.includeOrientationIndicator || options.includeRangeIndicator) {
                const orientationRef = msfssdk.FSComponent.createRef();
                const rangeRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeOrientationIndicator) {
                    factories.push((context) => {
                        var _a;
                        const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                        const pointerModule = context.model.getModule(GarminMapKeys.Pointer);
                        return (msfssdk.FSComponent.buildComponent(MapOrientationIndicator, { ref: orientationRef, orientation: orientationModule.orientation, text: {
                                [exports.MapOrientation.NorthUp]: 'NORTH UP',
                                [exports.MapOrientation.HeadingUp]: 'HDG UP',
                                [exports.MapOrientation.TrackUp]: 'TRK UP',
                            }, isVisible: (_a = pointerModule === null || pointerModule === void 0 ? void 0 : pointerModule.isActive.map(isActive => !isActive)) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(true) }));
                    });
                }
                if (options.includeRangeIndicator) {
                    factories.push((context) => {
                        const rangeModule = context.model.getModule(GarminMapKeys.Range);
                        const unitsModule = context.model.getModule(GarminMapKeys.Units);
                        return (msfssdk.FSComponent.buildComponent(MapRangeDisplay, { ref: rangeRef, range: rangeModule.nominalRange, displayUnit: unitsModule.distanceLarge }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopLeftIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = orientationRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = rangeRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-top-left');
            }
            // Bottom-left indicators
            if (options.includeDetailIndicator || (supportTraffic && options.includeTrafficOffScaleIndicator)) {
                const detailRef = msfssdk.FSComponent.createRef();
                const offScaleRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeDetailIndicator) {
                    factories.push((context) => {
                        const declutterModule = context.model.getModule(GarminMapKeys.Declutter);
                        return (msfssdk.FSComponent.buildComponent(MapDetailIndicator, { ref: detailRef, declutterMode: declutterModule.mode, showTitle: options.showDetailIndicatorTitle }));
                    });
                }
                if (supportTraffic && options.includeTrafficOffScaleIndicator) {
                    factories.push(() => {
                        return (msfssdk.FSComponent.buildComponent(MapTrafficOffScaleIndicator, { ref: offScaleRef, status: offScale }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomLeftIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = detailRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = offScaleRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-left');
            }
            // Bottom-right indicators
            if (options.includeTerrainScale || (supportTraffic && options.includeTrafficStatusIndicator)) {
                const scaleRef = msfssdk.FSComponent.createRef();
                const trafficRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (supportTraffic && options.includeTrafficStatusIndicator) {
                    factories.push((context) => {
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(MapTrafficStatusIndicator, { ref: trafficRef, show: trafficModule.show, operatingMode: trafficModule.operatingMode, altitudeRestrictionMode: options.showTrafficAltRestriction ? trafficModule.altitudeRestrictionMode : undefined }));
                    });
                }
                if (options.includeTerrainScale) {
                    factories.push((context) => {
                        const terrainModule = context.model.getModule(GarminMapKeys.Terrain);
                        return (msfssdk.FSComponent.buildComponent(MapTerrainScaleIndicator, { ref: scaleRef, show: terrainModule.showScale, terrainMode: terrainModule.terrainMode }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.BottomRightIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = scaleRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = trafficRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-bottom-right');
            }
            // Center indicators
            if (options.supportDataIntegrity) {
                const noGpsRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.supportDataIntegrity) {
                    factories.push((context) => {
                        const dataIntegrityModule = context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
                        return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { ref: noGpsRef, show: dataIntegrityModule.gpsSignalValid.map(isValid => !isValid), class: 'map-banner-no-gps' }, "NO GPS POSITION"));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.CenterIndicators, factories, {
                    onDetached: () => {
                        var _a;
                        (_a = noGpsRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                    }
                }, 'map-indicator-group-center');
            }
            if (options.pointerBoundsOffset !== undefined) {
                mapBuilder.with(GarminMapBuilder.pointer, options.pointerBoundsOffset);
                if (options.pointerInfoSize !== undefined) {
                    mapBuilder.with(GarminMapBuilder.pointerInfo, options.pointerInfoSize);
                }
            }
            if (options.supportDataIntegrity) {
                let airplaneIconSrcToUse;
                let airplaneIconAnchorToUse;
                if (options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                    airplaneIconSrcToUse = airplaneIconSrc;
                    airplaneIconAnchorToUse = airplaneIconAnchor;
                }
                mapBuilder.with(GarminMapBuilder.dataIntegrity, airplaneIconSrcToUse, airplaneIconAnchorToUse, options.airplaneIconSrc, options.airplaneIconAnchor, options.noHeadingAirplaneIconSrc, options.noHeadingAirplaneIconAnchor);
            }
            return mapBuilder;
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     * Builds next-generation (NXi, G3000, etc) Garmin procedure maps.
     */
    class NextGenProcMapBuilder {
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin procedure map. The map displays a
         * flight plan procedure (departure, arrival, approach) and its transitions, and is always focused on the displayed
         * procedure. The map is also locked to a North Up orientation.
         *
         * The module `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewModule` is added to the map model and can be
         * used to control the displayed procedure.
         *
         * The module `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule` is added to the map model and can be used
         * to control the procedure focus.
         *
         * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
         * the range of the map.
         *
         * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
         * map context and can be used to control the pointer.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            var _l;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.rangeEndpoints) !== null && _a !== void 0 ? _a : (options.rangeEndpoints = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0.25));
            (_b = options.defaultFocusRangeIndex) !== null && _b !== void 0 ? _b : (options.defaultFocusRangeIndex = 17);
            (_c = options.supportDataIntegrity) !== null && _c !== void 0 ? _c : (options.supportDataIntegrity = true);
            (_d = options.useDeclutterUserSetting) !== null && _d !== void 0 ? _d : (options.useDeclutterUserSetting = true);
            (_e = options.useTerrainUserSettings) !== null && _e !== void 0 ? _e : (options.useTerrainUserSettings = false);
            (_f = options.allowRelativeTerrainMode) !== null && _f !== void 0 ? _f : (options.allowRelativeTerrainMode = false);
            (_g = (_l = options.rangeRingOptions).labelRadial) !== null && _g !== void 0 ? _g : (_l.labelRadial = 225);
            (_h = options.includeOrientationIndicator) !== null && _h !== void 0 ? _h : (options.includeOrientationIndicator = false);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.range, (_j = options.nauticalRangeArray) !== null && _j !== void 0 ? _j : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Nautical), (_k = options.metricRangeArray) !== null && _k !== void 0 ? _k : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Metric), options.settingManager, false)
                .with(GarminMapBuilder.orientation, { [exports.MapOrientation.NorthUp]: options.targetOffset }, { [exports.MapOrientation.NorthUp]: options.rangeEndpoints })
                .withController('procMapOrientation', context => {
                const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                const orientationControlConsumer = {
                    priority: Number.MAX_SAFE_INTEGER,
                    onAcquired: () => {
                        orientationModule.orientation.set(exports.MapOrientation.NorthUp);
                    },
                    onCeded: () => { }
                };
                let controller;
                return controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].claim(orientationControlConsumer);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].forfeit(orientationControlConsumer);
                    }
                });
            })
                .with(GarminMapBuilder.declutter, options.useDeclutterUserSetting ? options.settingManager : undefined)
                .withBing(options.bingId)
                .with(GarminMapBuilder.terrainColors, {
                [exports.MapTerrainMode.None]: MapUtils.noTerrainEarthColors(),
                [exports.MapTerrainMode.Absolute]: MapUtils.absoluteTerrainEarthColors(),
                [exports.MapTerrainMode.Relative]: MapUtils.relativeTerrainEarthColors()
            }, options.useTerrainUserSettings ? options.settingManager : undefined, options.allowRelativeTerrainMode);
            mapBuilder
                .with(GarminMapBuilder.procPreview, new ProcMapFlightPathPlanRenderer(), (builder) => {
                builder
                    .withProcTransitionPreviewStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenProcTransitionPreviewIconStyles(1, options.waypointStyleScale), MapWaypointStyles.nextGenProcTransitionPreviewLabelStyles(1, options.waypointStyleScale))
                    .withProcPreviewStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenProcPreviewIconStyles(2, options.waypointStyleScale), MapWaypointStyles.nextGenProcPreviewLabelStyles(2, options.waypointStyleScale));
            })
                .with(GarminMapBuilder.flightPlanFocus, options.nominalFocusMargins, options.defaultFocusRangeIndex)
                .with(GarminMapBuilder.rangeRing, options.rangeRingOptions)
                .with(GarminMapBuilder.crosshair);
            let airplaneIconSrc = options.airplaneIconSrc;
            let airplaneIconAnchor = options.airplaneIconAnchor;
            if (options.supportDataIntegrity && options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                airplaneIconSrc = msfssdk.Subject.create('');
                airplaneIconAnchor = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            }
            mapBuilder
                .withOwnAirplaneIcon(options.airplaneIconSize, airplaneIconSrc, airplaneIconAnchor)
                .withOwnAirplanePropBindings([
                'position',
                'hdgTrue',
                'isOnGround'
            ], options.dataUpdateFreq)
                .withFollowAirplane();
            if (options.miniCompassImgSrc !== undefined) {
                mapBuilder.with(GarminMapBuilder.miniCompass, options.miniCompassImgSrc);
            }
            if (options.includeOrientationIndicator) {
                const ref = msfssdk.FSComponent.createRef();
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopLeftIndicators, [(context) => {
                        var _a;
                        const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                        const pointerModule = context.model.getModule(GarminMapKeys.Pointer);
                        return (msfssdk.FSComponent.buildComponent(MapOrientationIndicator, { ref: ref, orientation: orientationModule.orientation, text: {
                                [exports.MapOrientation.NorthUp]: 'NORTH UP'
                            }, isVisible: (_a = pointerModule === null || pointerModule === void 0 ? void 0 : pointerModule.isActive.map(isActive => !isActive)) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(true) }));
                    }], { onDetached: () => { ref.instance.destroy(); } }, 'map-indicator-group-top-left');
            }
            // Center indicators
            if (options.supportDataIntegrity) {
                const noGpsRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.supportDataIntegrity) {
                    factories.push((context) => {
                        const dataIntegrityModule = context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
                        return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { ref: noGpsRef, show: dataIntegrityModule.gpsSignalValid.map(isValid => !isValid), class: 'map-banner-no-gps' }, "NO GPS POSITION"));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.CenterIndicators, factories, {
                    onDetached: () => {
                        var _a;
                        (_a = noGpsRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                    }
                }, 'map-indicator-group-center');
            }
            if (options.pointerBoundsOffset !== undefined) {
                mapBuilder.with(GarminMapBuilder.pointer, options.pointerBoundsOffset);
                if (options.pointerInfoSize !== undefined) {
                    mapBuilder.with(GarminMapBuilder.pointerInfo, options.pointerInfoSize);
                }
            }
            if (options.supportDataIntegrity) {
                let airplaneIconSrcToUse;
                let airplaneIconAnchorToUse;
                if (options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                    airplaneIconSrcToUse = airplaneIconSrc;
                    airplaneIconAnchorToUse = airplaneIconAnchor;
                }
                mapBuilder.with(GarminMapBuilder.dataIntegrity, airplaneIconSrcToUse, airplaneIconAnchorToUse, options.airplaneIconSrc, options.airplaneIconAnchor, options.noHeadingAirplaneIconSrc, options.noHeadingAirplaneIconAnchor);
            }
            return mapBuilder.withInit('procMapInit', context => {
                context.model.getModule(GarminMapKeys.FlightPlanFocus).planHasFocus.set(true);
                if (!options.useTerrainUserSettings) {
                    context.model.getModule(GarminMapKeys.Terrain).terrainMode.set(exports.MapTerrainMode.None);
                }
            });
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     * Builds next-generation (NXi, G3000, etc) Garmin waypoint maps.
     */
    class NextGenWaypointMapBuilder {
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin waypoint map. The map is locked to
         * a North Up orientation, targets a highlighted waypoint, and follows the player airplane when there is no
         * highlighted waypoint.
         *
         * The module `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule` is added to the map model and can be
         * used to control the highlighted waypoint.
         *
         * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
         * the range of the waypoint map.
         *
         * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
         * map context and can be used to control the pointer.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
            var _u;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.includeLine) !== null && _a !== void 0 ? _a : (options.includeLine = false);
            (_b = options.defaultNoTargetRangeIndex) !== null && _b !== void 0 ? _b : (options.defaultNoTargetRangeIndex = null);
            (_c = options.defaultTargetRangeIndex) !== null && _c !== void 0 ? _c : (options.defaultTargetRangeIndex = null);
            (_d = options.supportAirportAutoRange) !== null && _d !== void 0 ? _d : (options.supportAirportAutoRange = false);
            (_e = options.rangeEndpoints) !== null && _e !== void 0 ? _e : (options.rangeEndpoints = msfssdk.VecNMath.create(4, 0.5, 0.5, 0.5, 0.25));
            (_f = options.supportDataIntegrity) !== null && _f !== void 0 ? _f : (options.supportDataIntegrity = true);
            (_g = options.useDeclutterUserSetting) !== null && _g !== void 0 ? _g : (options.useDeclutterUserSetting = true);
            (_h = options.useTerrainUserSettings) !== null && _h !== void 0 ? _h : (options.useTerrainUserSettings = true);
            (_j = options.allowRelativeTerrainMode) !== null && _j !== void 0 ? _j : (options.allowRelativeTerrainMode = false);
            (_k = options.nexradMinRangeIndex) !== null && _k !== void 0 ? _k : (options.nexradMinRangeIndex = 13);
            (_l = options.useNexradUserSettings) !== null && _l !== void 0 ? _l : (options.useNexradUserSettings = false);
            (_m = options.includeAirspaces) !== null && _m !== void 0 ? _m : (options.includeAirspaces = false);
            (_o = options.useAirspaceVisUserSettings) !== null && _o !== void 0 ? _o : (options.useAirspaceVisUserSettings = true);
            (_p = options.useWaypointVisUserSettings) !== null && _p !== void 0 ? _p : (options.useWaypointVisUserSettings = true);
            (_q = (_u = options.rangeRingOptions).labelRadial) !== null && _q !== void 0 ? _q : (_u.labelRadial = 225);
            (_r = options.includeOrientationIndicator) !== null && _r !== void 0 ? _r : (options.includeOrientationIndicator = true);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.range, (_s = options.nauticalRangeArray) !== null && _s !== void 0 ? _s : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Nautical), (_t = options.metricRangeArray) !== null && _t !== void 0 ? _t : MapUtils.nextGenMapRanges(exports.UnitsDistanceSettingMode.Metric), options.settingManager, false)
                .with(GarminMapBuilder.orientation, { [exports.MapOrientation.NorthUp]: options.targetOffset }, { [exports.MapOrientation.NorthUp]: options.rangeEndpoints })
                .withController('waypointMapOrientation', context => {
                const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                const orientationControlConsumer = {
                    priority: Number.MAX_SAFE_INTEGER,
                    onAcquired: () => {
                        orientationModule.orientation.set(exports.MapOrientation.NorthUp);
                    },
                    onCeded: () => { }
                };
                let controller;
                return controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].claim(orientationControlConsumer);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].forfeit(orientationControlConsumer);
                    }
                });
            })
                .with(GarminMapBuilder.declutter, options.useDeclutterUserSetting ? options.settingManager : undefined)
                .withBing(options.bingId)
                .with(GarminMapBuilder.terrainColors, {
                [exports.MapTerrainMode.None]: MapUtils.noTerrainEarthColors(),
                [exports.MapTerrainMode.Absolute]: MapUtils.absoluteTerrainEarthColors(),
                [exports.MapTerrainMode.Relative]: MapUtils.relativeTerrainEarthColors()
            }, options.useTerrainUserSettings ? options.settingManager : undefined, options.allowRelativeTerrainMode)
                .with(GarminMapBuilder.nexrad, options.nexradMinRangeIndex, options.useNexradUserSettings ? options.settingManager : undefined, exports.MapDeclutterMode.Level2);
            if (options.includeAirspaces) {
                mapBuilder.with(GarminMapBuilder.airspaces, options.useAirspaceVisUserSettings ? options.settingManager : undefined);
            }
            mapBuilder.with(GarminMapBuilder.waypoints, (builder) => {
                builder.withNormalStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenNormalIconStyles(1, options.waypointStyleScale), MapWaypointStyles.nextGenNormalLabelStyles(1, options.waypointStyleScale));
            }, options.useWaypointVisUserSettings ? options.settingManager : undefined);
            if (options.flightPlanner) {
                mapBuilder.with(GarminMapBuilder.activeFlightPlan, options.flightPlanner, new DefaultFlightPathPlanRenderer(), false, (builder) => {
                    builder
                        .withFlightPlanInactiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(false, 2, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(false, 2, options.waypointStyleScale))
                        .withFlightPlanActiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(true, 3, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(true, 3, options.waypointStyleScale));
                });
            }
            if (typeof options.defaultNoTargetRangeIndex === 'number') {
                options.defaultNoTargetRangeIndex = msfssdk.Subject.create(options.defaultNoTargetRangeIndex);
            }
            if (typeof options.defaultTargetRangeIndex === 'number') {
                options.defaultTargetRangeIndex = msfssdk.Subject.create(options.defaultTargetRangeIndex);
            }
            mapBuilder
                .with(GarminMapBuilder.waypointHighlight, options.includeLine, (builder) => {
                builder.withHighlightStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenHighlightIconStyles(4, options.waypointStyleScale), MapWaypointStyles.nextGenHighlightLabelStyles(4, options.waypointStyleScale));
            }, options.lineOptions)
                .withController(GarminMapKeys.Nearest, context => {
                let boundsOffset = undefined;
                if (options.supportAirportAutoRange && options.boundsOffset !== undefined) {
                    boundsOffset = 'isSubscribable' in options.boundsOffset ? options.boundsOffset : msfssdk.Subject.create(options.boundsOffset);
                }
                return new WaypointMapRTRController(context, options.defaultNoTargetRangeIndex, options.defaultTargetRangeIndex, options.supportAirportAutoRange, boundsOffset);
            });
            let airplaneIconSrc = options.airplaneIconSrc;
            let airplaneIconAnchor = options.airplaneIconAnchor;
            if (options.supportDataIntegrity && options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                airplaneIconSrc = msfssdk.Subject.create('');
                airplaneIconAnchor = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            }
            mapBuilder
                .with(GarminMapBuilder.rangeRing, options.rangeRingOptions)
                .with(GarminMapBuilder.crosshair)
                .withOwnAirplaneIcon(options.airplaneIconSize, airplaneIconSrc, airplaneIconAnchor)
                .withOwnAirplanePropBindings([
                'position',
                'hdgTrue',
                'isOnGround'
            ], options.dataUpdateFreq)
                .withFollowAirplane();
            if (options.miniCompassImgSrc !== undefined) {
                mapBuilder.with(GarminMapBuilder.miniCompass, options.miniCompassImgSrc);
            }
            if (options.includeOrientationIndicator) {
                const ref = msfssdk.FSComponent.createRef();
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopLeftIndicators, [(context) => {
                        var _a;
                        const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                        const pointerModule = context.model.getModule(GarminMapKeys.Pointer);
                        return (msfssdk.FSComponent.buildComponent(MapOrientationIndicator, { ref: ref, orientation: orientationModule.orientation, text: {
                                [exports.MapOrientation.NorthUp]: 'NORTH UP'
                            }, isVisible: (_a = pointerModule === null || pointerModule === void 0 ? void 0 : pointerModule.isActive.map(isActive => !isActive)) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(true) }));
                    }], { onDetached: () => { ref.instance.destroy(); } }, 'map-indicator-group-top-left');
            }
            // Center indicators
            if (options.supportDataIntegrity) {
                const noGpsRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.supportDataIntegrity) {
                    factories.push((context) => {
                        const dataIntegrityModule = context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
                        return (msfssdk.FSComponent.buildComponent(MapBannerIndicator, { ref: noGpsRef, show: dataIntegrityModule.gpsSignalValid.map(isValid => !isValid), class: 'map-banner-no-gps' }, "NO GPS POSITION"));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.CenterIndicators, factories, {
                    onDetached: () => {
                        var _a;
                        (_a = noGpsRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                    }
                }, 'map-indicator-group-center');
            }
            if (options.pointerBoundsOffset !== undefined) {
                mapBuilder.with(GarminMapBuilder.pointer, options.pointerBoundsOffset);
                if (options.pointerInfoSize !== undefined) {
                    mapBuilder.with(GarminMapBuilder.pointerInfo, options.pointerInfoSize);
                }
            }
            if (options.supportDataIntegrity) {
                let airplaneIconSrcToUse;
                let airplaneIconAnchorToUse;
                if (options.noHeadingAirplaneIconSrc !== undefined && options.noHeadingAirplaneIconAnchor !== undefined) {
                    airplaneIconSrcToUse = airplaneIconSrc;
                    airplaneIconAnchorToUse = airplaneIconAnchor;
                }
                mapBuilder.with(GarminMapBuilder.dataIntegrity, airplaneIconSrcToUse, airplaneIconAnchorToUse, options.airplaneIconSrc, options.airplaneIconAnchor, options.noHeadingAirplaneIconSrc, options.noHeadingAirplaneIconAnchor);
            }
            return mapBuilder;
        }
    }

    /* eslint-disable jsdoc/require-jsdoc */
    /**
     * Builds Garmin traffic maps.
     */
    class TrafficMapBuilder {
        /**
         * Configures a map builder to generate a Garmin traffic map. The map consists of an optional active flight plan
         * layer, an optional traffic range ring layer, a traffic intruder layer, an airplane icon layer, and an optional
         * mini-compass layer. The map is centered on the player airplane and is locked to a Heading Up orientation.
         *
         * The controller `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` is added to the map context and can be
         * used to control the range of the traffic map.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static build(mapBuilder, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            options = Object.assign({}, options); // so we don't mutate the object that was passed in.
            (_a = options.useRangeSettingByDefault) !== null && _a !== void 0 ? _a : (options.useRangeSettingByDefault = true);
            (_b = options.supportDataIntegrity) !== null && _b !== void 0 ? _b : (options.supportDataIntegrity = true);
            (_c = options.includeOrientationIndicator) !== null && _c !== void 0 ? _c : (options.includeOrientationIndicator = true);
            (_d = options.includeOperatingModeIndicator) !== null && _d !== void 0 ? _d : (options.includeOperatingModeIndicator = true);
            (_e = options.includeAdsbModeIndicator) !== null && _e !== void 0 ? _e : (options.includeAdsbModeIndicator = true);
            (_f = options.includeAltitudeModeIndicator) !== null && _f !== void 0 ? _f : (options.includeAltitudeModeIndicator = true);
            (_g = options.includeStandbyBanner) !== null && _g !== void 0 ? _g : (options.includeStandbyBanner = true);
            (_h = options.includeAdsbOffBanner) !== null && _h !== void 0 ? _h : (options.includeAdsbOffBanner = true);
            mapBuilder
                .withModule(GarminMapKeys.Units, () => new MapUnitsModule(options.unitsSettingManager))
                .with(GarminMapBuilder.orientation, { [exports.MapOrientation.HeadingUp]: options.targetOffset }, { [exports.MapOrientation.HeadingUp]: options.rangeEndpoints })
                .withController('trafficMapOrientation', context => {
                const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                const orientationControlConsumer = {
                    priority: Number.MAX_SAFE_INTEGER,
                    onAcquired: () => {
                        orientationModule.orientation.set(exports.MapOrientation.HeadingUp);
                    },
                    onCeded: () => { }
                };
                let controller;
                return controller = new msfssdk.MapSystemGenericController(context, {
                    onAfterMapRender: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].claim(orientationControlConsumer);
                    },
                    onMapDestroyed: () => {
                        controller.destroy();
                    },
                    onDestroyed: (contextArg) => {
                        contextArg[GarminMapKeys.OrientationControl].forfeit(orientationControlConsumer);
                    }
                });
            });
            if (options.flightPlanner !== undefined && options.flightPathRenderer !== undefined && options.configureFlightPlan !== undefined) {
                mapBuilder.with(GarminMapBuilder.activeFlightPlan, options.flightPlanner, options.flightPathRenderer, false, options.configureFlightPlan);
            }
            mapBuilder.with(GarminMapBuilder.trafficRange, options.nauticalRangeArray, options.metricRangeArray, options.mapRangeSettingManager, options.useRangeSettingByDefault);
            if (options.includeRangeRings) {
                const rangeRingOptions = Object.assign({}, options.rangeRingOptions);
                (_j = rangeRingOptions.outerLabelRadial) !== null && _j !== void 0 ? _j : (rangeRingOptions.outerLabelRadial = 135);
                (_k = rangeRingOptions.innerLabelRadial) !== null && _k !== void 0 ? _k : (rangeRingOptions.innerLabelRadial = 135);
                mapBuilder.with(GarminMapBuilder.trafficRangeRings, rangeRingOptions);
            }
            mapBuilder
                .with(GarminMapBuilder.traffic, options.trafficSystem, options.trafficIconOptions, true, options.offScaleStatus, options.iconFactory, options.initCanvasStyles, options.trafficSettingManager)
                .withOwnAirplaneIcon(options.airplaneIconSize, options.airplaneIconSrc, options.airplaneIconAnchor)
                .withOwnAirplanePropBindings([
                'position',
                'hdgTrue',
                'isOnGround'
            ], options.dataUpdateFreq)
                .withFollowAirplane();
            if (options.miniCompassImgSrc !== undefined) {
                mapBuilder.with(GarminMapBuilder.miniCompass, options.miniCompassImgSrc);
            }
            // Top-left indicators
            if (options.includeOrientationIndicator) {
                const ref = msfssdk.FSComponent.createRef();
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopLeftIndicators, [(context) => {
                        var _a, _b;
                        const orientationModule = context.model.getModule(GarminMapKeys.Orientation);
                        const dataIntegrityModule = context.model.getModule(msfssdk.MapSystemKeys.DataIntegrity);
                        return (msfssdk.FSComponent.buildComponent(MapOrientationIndicator, { ref: ref, orientation: orientationModule.orientation, text: (_a = options.orientationText) !== null && _a !== void 0 ? _a : {}, isVisible: (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.headingSignalValid) !== null && _b !== void 0 ? _b : msfssdk.Subject.create(true) }));
                    }], { onDetached: () => { var _a; (_a = ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy(); } }, 'map-indicator-group-top-left');
            }
            // Top-right indicators
            if (options.includeOperatingModeIndicator || (options.trafficSystem.adsb !== null && options.includeAdsbModeIndicator) || options.includeAltitudeModeIndicator) {
                const operatingModeRef = msfssdk.FSComponent.createRef();
                const adsbModeRef = msfssdk.FSComponent.createRef();
                const altitudeModeRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeOperatingModeIndicator) {
                    factories.push((context) => {
                        var _a;
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(TrafficMapOperatingModeIndicator, { ref: operatingModeRef, operatingMode: trafficModule.operatingMode, text: (_a = options.operatingModeText) !== null && _a !== void 0 ? _a : {} }));
                    });
                }
                if (options.trafficSystem.adsb !== null && options.includeAdsbModeIndicator) {
                    factories.push((context) => {
                        var _a;
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(TrafficMapAdsbModeIndicator, { ref: adsbModeRef, operatingMode: trafficModule.adsbOperatingMode, text: (_a = options.adsbModeText) !== null && _a !== void 0 ? _a : {} }));
                    });
                }
                if (options.includeAltitudeModeIndicator) {
                    factories.push((context) => {
                        var _a;
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(TrafficMapAltitudeModeIndicator, { ref: altitudeModeRef, altitudeRestrictionMode: trafficModule.altitudeRestrictionMode, text: (_a = options.altitudeModeText) !== null && _a !== void 0 ? _a : {} }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.TopRightIndicators, factories, {
                    onDetached: () => {
                        var _a, _b, _c;
                        (_a = operatingModeRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = adsbModeRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                        (_c = altitudeModeRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
                    }
                }, 'map-indicator-group-top-right');
            }
            // Center indicators
            if (options.includeStandbyBanner || (options.trafficSystem.adsb !== null && options.includeAdsbOffBanner)) {
                const standbyRef = msfssdk.FSComponent.createRef();
                const adsbOffRef = msfssdk.FSComponent.createRef();
                const factories = [];
                if (options.includeStandbyBanner) {
                    factories.push((context) => {
                        const ownAirplanePropsModule = context.model.getModule(msfssdk.MapSystemKeys.OwnAirplaneProps);
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(TrafficMapStandbyBannerIndicator, { ref: standbyRef, operatingMode: trafficModule.operatingMode, isOnGround: ownAirplanePropsModule.isOnGround }));
                    });
                }
                if (options.trafficSystem.adsb !== null && options.includeAdsbOffBanner) {
                    factories.push((context) => {
                        const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                        return (msfssdk.FSComponent.buildComponent(TrafficMapAdsbOffBannerIndicator, { ref: adsbOffRef, adsbOperatingMode: trafficModule.adsbOperatingMode, trafficOperatingMode: trafficModule.operatingMode }));
                    });
                }
                mapBuilder.with(GarminMapBuilder.indicatorGroup, GarminMapKeys.CenterIndicators, factories, {
                    onDetached: () => {
                        var _a, _b;
                        (_a = standbyRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
                        (_b = adsbOffRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
                    }
                }, 'map-indicator-group-center');
            }
            if (options.supportDataIntegrity) {
                mapBuilder
                    .withModule(msfssdk.MapSystemKeys.DataIntegrity, () => new msfssdk.MapDataIntegrityModule())
                    .withController('TrafficMapDataIntegrity', context => {
                    let controller;
                    let headingSignalSub;
                    // TODO: Hide flight plan
                    const miniCompassLayer = context.getLayer(GarminMapKeys.MiniCompass);
                    return controller = new msfssdk.MapSystemGenericController(context, {
                        onAfterMapRender: (contextArg) => {
                            headingSignalSub = contextArg.model.getModule(msfssdk.MapSystemKeys.DataIntegrity).headingSignalValid.sub(isValid => {
                                if (isValid) {
                                    miniCompassLayer === null || miniCompassLayer === void 0 ? void 0 : miniCompassLayer.setVisible(true);
                                }
                                else {
                                    miniCompassLayer === null || miniCompassLayer === void 0 ? void 0 : miniCompassLayer.setVisible(false);
                                }
                            }, true);
                        },
                        onMapDestroyed: () => {
                            controller.destroy();
                        },
                        onDestroyed: () => {
                            headingSignalSub === null || headingSignalSub === void 0 ? void 0 : headingSignalSub.destroy();
                        }
                    });
                });
            }
            return mapBuilder.withInit('trafficMapInit', context => {
                const trafficModule = context.model.getModule(GarminMapKeys.Traffic);
                trafficModule.show.set(true);
                trafficModule.showIntruderLabel.set(true);
                trafficModule.alertLevelMode.set(exports.MapTrafficAlertLevelMode.All);
            });
        }
        /**
         * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin traffic map. The map consists of
         * an optional active flight plan layer, an optional traffic range ring layer, a traffic intruder layer, an airplane
         * icon layer, and an optional mini-compass layer. The map is centered on the player airplane and is locked in
         * Heading Up orientation.
         *
         * The controller `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` is added to the map context and can be
         * used to control the range of the traffic map.
         *
         * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
         * the map.
         * @param mapBuilder The map builder to configure.
         * @param options Options for configuring the map.
         * @returns The builder, after it has been configured.
         */
        static buildNextGen(mapBuilder, options) {
            var _a, _b, _c, _d, _e;
            var _f, _g;
            const optionsToUse = Object.assign({}, options);
            (_a = optionsToUse.nauticalRangeArray) !== null && _a !== void 0 ? _a : (optionsToUse.nauticalRangeArray = MapUtils.nextGenTrafficMapRanges());
            (_b = optionsToUse.metricRangeArray) !== null && _b !== void 0 ? _b : (optionsToUse.metricRangeArray = MapUtils.nextGenTrafficMapRanges());
            optionsToUse.trafficIconOptions = Object.assign({}, optionsToUse.trafficIconOptions);
            (_c = (_f = optionsToUse.trafficIconOptions).drawOffScale) !== null && _c !== void 0 ? _c : (_f.drawOffScale = true);
            (_d = (_g = optionsToUse.trafficIconOptions).supportAdsbVector) !== null && _d !== void 0 ? _d : (_g.supportAdsbVector = options.trafficSystem.adsb !== null);
            (_e = optionsToUse.includeRangeRings) !== null && _e !== void 0 ? _e : (optionsToUse.includeRangeRings = true);
            optionsToUse.orientationText = {
                [exports.MapOrientation.HeadingUp]: 'HDG UP'
            };
            let operatingModePrefix = '';
            if (options.trafficSystem.adsb !== null) {
                switch (options.trafficSystem.type) {
                    case exports.TrafficSystemType.Tis:
                        operatingModePrefix = 'TIS: ';
                        break;
                    case exports.TrafficSystemType.Tas:
                        operatingModePrefix = 'TAS: ';
                        break;
                    case exports.TrafficSystemType.TcasII:
                        operatingModePrefix = 'TCAS: ';
                        break;
                }
            }
            if (options.trafficSystem.type === exports.TrafficSystemType.TcasII) {
                optionsToUse.operatingModeText = {
                    [msfssdk.TcasOperatingMode.Standby]: operatingModePrefix + 'STANDBY',
                    [msfssdk.TcasOperatingMode.TAOnly]: operatingModePrefix + 'TA ONLY',
                    [msfssdk.TcasOperatingMode.TA_RA]: operatingModePrefix + 'TA/RA'
                };
            }
            else {
                optionsToUse.operatingModeText = {
                    [msfssdk.TcasOperatingMode.Standby]: operatingModePrefix + 'STANDBY',
                    [msfssdk.TcasOperatingMode.TAOnly]: operatingModePrefix + 'OPERATING',
                    [msfssdk.TcasOperatingMode.TA_RA]: operatingModePrefix + 'OPERATING',
                };
            }
            optionsToUse.adsbModeText = {
                [msfssdk.AdsbOperatingMode.Standby]: 'ADS-B: OFF',
                [msfssdk.AdsbOperatingMode.Surface]: 'ADS-B: SURF',
                [msfssdk.AdsbOperatingMode.Airborne]: 'ADS-B: AIRB',
            };
            optionsToUse.altitudeModeText = {
                [exports.MapTrafficAltitudeRestrictionMode.Unrestricted]: 'UNRESTRICTED',
                [exports.MapTrafficAltitudeRestrictionMode.Above]: 'ABOVE',
                [exports.MapTrafficAltitudeRestrictionMode.Below]: 'BELOW',
                [exports.MapTrafficAltitudeRestrictionMode.Normal]: 'NORMAL',
            };
            if (options.flightPlanner !== undefined) {
                optionsToUse.flightPathRenderer = new DefaultFlightPathPlanRenderer();
                optionsToUse.configureFlightPlan = (builder) => {
                    builder
                        .withFlightPlanInactiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(false, 2, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(false, 2, options.waypointStyleScale))
                        .withFlightPlanActiveStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenFlightPlanIconStyles(true, 3, options.waypointStyleScale), MapWaypointStyles.nextGenFlightPlanLabelStyles(true, 3, options.waypointStyleScale))
                        .withVNavStyles(options.waypointIconImageCache, MapWaypointStyles.nextGenVNavIconStyles(4, options.waypointStyleScale), MapWaypointStyles.nextGenVNavLabelStyles(4, options.waypointStyleScale));
                };
            }
            return mapBuilder.with(TrafficMapBuilder.build, optionsToUse);
        }
    }

    /**
     * The different types of navigation data fields.
     */
    exports.NavDataFieldType = void 0;
    (function (NavDataFieldType) {
        NavDataFieldType["BearingToWaypoint"] = "BRG";
        NavDataFieldType["Destination"] = "DEST";
        NavDataFieldType["DistanceToWaypoint"] = "DIS";
        NavDataFieldType["DistanceToDestination"] = "DTG";
        NavDataFieldType["DesiredTrack"] = "DTK";
        NavDataFieldType["Endurance"] = "END";
        NavDataFieldType["TimeToDestination"] = "ENR";
        NavDataFieldType["TimeOfWaypointArrival"] = "ETA";
        NavDataFieldType["TimeToWaypoint"] = "ETE";
        //FlightTimer = 'FLT', <-- Disabling this for now
        NavDataFieldType["FuelOnBoard"] = "FOB";
        NavDataFieldType["FuelOverDestination"] = "FOD";
        NavDataFieldType["GroundSpeed"] = "GS";
        NavDataFieldType["ISA"] = "ISA";
        NavDataFieldType["TimeOfDestinationArrival"] = "LDG";
        NavDataFieldType["TrueAirspeed"] = "TAS";
        NavDataFieldType["TrackAngleError"] = "TKE";
        NavDataFieldType["GroundTrack"] = "TRK";
        NavDataFieldType["VerticalSpeedRequired"] = "VSR";
        NavDataFieldType["CrossTrack"] = "XTK";
    })(exports.NavDataFieldType || (exports.NavDataFieldType = {}));

    /**
     * Setting modes for date/time format.
     */
    exports.DateTimeFormatSettingMode = void 0;
    (function (DateTimeFormatSettingMode) {
        DateTimeFormatSettingMode["UTC"] = "UTC";
        DateTimeFormatSettingMode["Local24"] = "Local24";
        DateTimeFormatSettingMode["Local12"] = "Local12";
    })(exports.DateTimeFormatSettingMode || (exports.DateTimeFormatSettingMode = {}));
    /**
     * Utility class for retrieving date/time user setting managers.
     */
    class DateTimeUserSettings {
        /**
         * Retrieves a manager for date/time user settings.
         * @param bus The event bus.
         * @returns A manager for date/time user settings.
         */
        static getManager(bus) {
            var _a;
            return (_a = DateTimeUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (DateTimeUserSettings.INSTANCE = new msfssdk.DefaultUserSettingManager(bus, [
                {
                    name: 'dateTimeFormat',
                    defaultValue: exports.DateTimeFormatSettingMode.UTC
                },
                {
                    name: 'dateTimeLocalOffset',
                    defaultValue: 0
                }
            ]));
        }
    }

    /**
     * A navigation data field, consisting of a title and a value.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataField extends msfssdk.DisplayComponent {
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: `nav-data-field ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfssdk.FSComponent.buildComponent("div", { class: 'nav-data-field-title' }, this.props.title),
                this.renderValue()));
        }
    }
    /**
     * A generic navigation data field which renders its children as its value.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataGenericField extends NavDataField {
        /**
         * Renders this data field's value component.
         * @returns This data field's value component, as a VNode.
         */
        renderValue() {
            var _a;
            return (msfssdk.FSComponent.buildComponent(msfssdk.FSComponent.Fragment, null, (_a = this.props.children) !== null && _a !== void 0 ? _a : null));
        }
        /** @inheritdoc */
        destroy() {
            this.props.onDestroy && this.props.onDestroy();
        }
    }
    /**
     * A navigation data field which displays a value consisting of a number with unit type.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataNumberUnitField extends NavDataField {
        constructor() {
            super(...arguments);
            this.numberUnitRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        renderValue() {
            return (msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { ref: this.numberUnitRef, value: this.props.model.value, displayUnit: this.props.displayUnit, formatter: this.props.formatter }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.numberUnitRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A navigation data field which displays a value consisting of a formatted duration.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataDurationField extends NavDataField {
        constructor() {
            super(...arguments);
            this.durationRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        renderValue() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.DurationDisplay, { ref: this.durationRef, value: this.props.model.value, options: this.props.options }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.durationRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A navigation data field which displays a value consisting of a formatted time.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataTimeField extends NavDataField {
        constructor() {
            super(...arguments);
            this.timeRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        renderValue() {
            return (msfssdk.FSComponent.buildComponent(TimeDisplay, { ref: this.timeRef, time: this.props.model.value, format: this.props.format, localOffset: this.props.localOffset }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.timeRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A navigation data field which displays a bearing value.
     *
     * The root element of the field contains the `nav-data-field` CSS class by default.
     *
     * The root element contains a child title element with the CSS class `nav-data-field-title`.
     */
    class NavDataBearingField extends NavDataField {
        constructor() {
            super(...arguments);
            this.bearingRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        renderValue() {
            return (msfssdk.FSComponent.buildComponent(BearingDisplay, { ref: this.bearingRef, value: this.props.model.value, displayUnit: this.props.displayUnit, formatter: this.props.formatter, use360: this.props.use360 }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.bearingRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * A generic implementation of a navigation data bar field renderer. For each data field type, a single-type renderer
     * can be registered. Once registered, the single-type renderer is used to create render data fields for its assigned
     * data field type.
     */
    class GenericNavDataBarFieldRenderer {
        constructor() {
            this.renderers = new Map();
        }
        /**
         * Registers a single-type renderer.
         * @param type The data field type of the single-type renderer to register.
         * @param renderer The single-type renderer to register.
         */
        register(type, renderer) {
            this.renderers.set(type, renderer);
        }
        /**
         * Deregisters a single-type renderer.
         * @param type The data field type of the single-type renderer to deregister.
         * @returns Whether a single-type renderer was deregistered.
         */
        deregister(type) {
            return this.renderers.delete(type);
        }
        /**
         * Renders a navigation data bar field of a given type.
         * @param type A data bar field type.
         * @param model The data model for the field.
         * @returns A navigation data bar field of the given type, as a VNode.
         * @throws Error if an unsupported field type is specified.
         */
        render(type, model) {
            var _a;
            const rendered = (_a = this.renderers.get(type)) === null || _a === void 0 ? void 0 : _a.render(model);
            if (!rendered) {
                throw new Error(`GenericNavDataBarFieldRenderer: no single-type renderer of data field type [${type}] is registered`);
            }
            return rendered;
        }
    }
    /**
     * An abstract implementation of NavDataBarFieldTypeRenderer which supports display unit settings.
     */
    class DisplayUnitNavDataBarFieldTypeRenderer {
        /**
         * Constructor.
         * @param unitsSettingManager A user setting manager for measurement units.
         */
        constructor(unitsSettingManager) {
            this.unitsSettingManager = unitsSettingManager;
        }
    }
    DisplayUnitNavDataBarFieldTypeRenderer.BEARING_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' });
    DisplayUnitNavDataBarFieldTypeRenderer.DISTANCE_FORMATTER = msfssdk.NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: true, nanString: '__._' });
    DisplayUnitNavDataBarFieldTypeRenderer.SPEED_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    DisplayUnitNavDataBarFieldTypeRenderer.FUEL_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    DisplayUnitNavDataBarFieldTypeRenderer.ANGLE_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    DisplayUnitNavDataBarFieldTypeRenderer.TEMPERATURE_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    DisplayUnitNavDataBarFieldTypeRenderer.DURATION_OPTIONS = {
        pad: 0,
        format: msfssdk.DurationDisplayFormat.hh_mm_or_mm_ss,
        delim: msfssdk.DurationDisplayDelim.ColonOrCross,
        nanString: '__:__'
    };
    /**
     * An abstract implementation of NavDataBarFieldTypeRenderer which supports date/time settings.
     */
    class DateTimeNavDataBarFieldTypeRenderer {
        /**
         * Constructor.
         * @param dateTimeSettingManager A date/time user setting manager.
         */
        constructor(dateTimeSettingManager) {
            this.dateTimeSettingManager = dateTimeSettingManager;
            this.timeFormat = msfssdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeFormat'), this.dateTimeSettingManager.getSetting('dateTimeFormat').value);
            this.localOffset = msfssdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeLocalOffset'), this.dateTimeSettingManager.getSetting('dateTimeLocalOffset').value);
        }
    }
    DateTimeNavDataBarFieldTypeRenderer.FORMAT_SETTING_MAP = {
        [exports.DateTimeFormatSettingMode.Local12]: exports.TimeDisplayFormat.Local12,
        [exports.DateTimeFormatSettingMode.Local24]: exports.TimeDisplayFormat.Local24,
        [exports.DateTimeFormatSettingMode.UTC]: exports.TimeDisplayFormat.UTC
    };
    /**
     * Renders Bearing to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldBrgRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataBearingField, { title: 'BRG', model: model, displayUnit: this.unitsSettingManager.navAngleUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.BEARING_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Distance to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldDestRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            // This seems silly but we need to create our own subscribable in order to be able unsubscribe from it when the
            // component is destroyed.
            const textSub = model.value.map(val => val);
            return (msfssdk.FSComponent.buildComponent(NavDataGenericField, { title: 'DEST', model: model, onDestroy: () => {
                    textSub.destroy();
                }, class: 'nav-data-field-white' },
                msfssdk.FSComponent.buildComponent("div", null, textSub)));
        }
    }
    /**
     * Renders Distance to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldDisRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'DIS', model: model, displayUnit: this.unitsSettingManager.distanceUnitsLarge, formatter: DisplayUnitNavDataBarFieldTypeRenderer.DISTANCE_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Distance to Destination navigation data bar fields.
     */
    class NavDataBarFieldDtgRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'DTG', model: model, displayUnit: this.unitsSettingManager.distanceUnitsLarge, formatter: DisplayUnitNavDataBarFieldTypeRenderer.DISTANCE_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Desired Track navigation data bar fields.
     */
    class NavDataBarFieldDtkRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataBearingField, { title: 'DTK', model: model, displayUnit: this.unitsSettingManager.navAngleUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.BEARING_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Endurance navigation data bar fields.
     */
    class NavDataBarFieldEndRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataDurationField, { title: 'END', model: model, options: DisplayUnitNavDataBarFieldTypeRenderer.DURATION_OPTIONS, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Time to Destination navigation data bar fields.
     */
    class NavDataBarFieldEnrRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataDurationField, { title: 'ENR', model: model, options: DisplayUnitNavDataBarFieldTypeRenderer.DURATION_OPTIONS, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Estimated Time of Arrival navigation data bar fields.
     */
    class NavDataBarFieldEtaRenderer extends DateTimeNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataTimeField, { title: 'ETA', model: model, format: this.timeFormat.map(format => DateTimeNavDataBarFieldTypeRenderer.FORMAT_SETTING_MAP[format]), localOffset: this.localOffset, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Time to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldEteRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataDurationField, { title: 'ETE', model: model, options: DisplayUnitNavDataBarFieldTypeRenderer.DURATION_OPTIONS, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Fuel on Board navigation data bar fields.
     */
    class NavDataBarFieldFobRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'FOB', model: model, displayUnit: msfssdk.Subject.create(msfssdk.UnitType.GALLON_FUEL), formatter: DisplayUnitNavDataBarFieldTypeRenderer.FUEL_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Fuel Over Destination navigation data bar fields.
     */
    class NavDataBarFieldFodRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'FOD', model: model, displayUnit: msfssdk.Subject.create(msfssdk.UnitType.GALLON_FUEL), formatter: DisplayUnitNavDataBarFieldTypeRenderer.FUEL_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Ground Speed navigation data bar fields.
     */
    class NavDataBarFieldGsRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'GS', model: model, displayUnit: this.unitsSettingManager.speedUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.SPEED_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders ISA navigation data bar fields.
     */
    class NavDataBarFieldIsaRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'ISA', model: model, displayUnit: this.unitsSettingManager.temperatureUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.TEMPERATURE_FORMATTER, class: 'nav-data-field-white' }));
        }
    }
    /**
     * Renders Estimated Time of Arrival at Destination navigation data bar fields.
     */
    class NavDataBarFieldLdgRenderer extends DateTimeNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataTimeField, { title: 'LDG', model: model, format: this.timeFormat.map(format => DateTimeNavDataBarFieldTypeRenderer.FORMAT_SETTING_MAP[format]), localOffset: this.localOffset, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders True Airspeed navigation data bar fields.
     */
    class NavDataBarFieldTasRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'TAS', model: model, displayUnit: this.unitsSettingManager.speedUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.SPEED_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Track Angle Error navigation data bar fields.
     */
    class NavDataBarFieldTkeRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'TKE', model: model, displayUnit: msfssdk.Subject.create(msfssdk.UnitType.DEGREE), formatter: DisplayUnitNavDataBarFieldTypeRenderer.ANGLE_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Ground Track navigation data bar fields.
     */
    class NavDataBarFieldTrkRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataBearingField, { title: 'TRK', model: model, displayUnit: this.unitsSettingManager.navAngleUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.BEARING_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Vertical Speed Required navigation data bar fields.
     */
    class NavDataBarFieldVsrRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'VSR', model: model, displayUnit: this.unitsSettingManager.verticalSpeedUnits, formatter: DisplayUnitNavDataBarFieldTypeRenderer.SPEED_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }
    /**
     * Renders Cross Track navigation data bar fields.
     */
    class NavDataBarFieldXtkRenderer extends DisplayUnitNavDataBarFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfssdk.FSComponent.buildComponent(NavDataNumberUnitField, { title: 'XTK', model: model, displayUnit: this.unitsSettingManager.distanceUnitsLarge, formatter: DisplayUnitNavDataBarFieldTypeRenderer.DISTANCE_FORMATTER, class: 'nav-data-field-magenta' }));
        }
    }

    /**
     * A default implementation of NavDataBarFieldRenderer.
     */
    class DefaultNavDataBarFieldRenderer {
        /**
         * Constructor.
         * @param unitsSettingManager A display units user setting manager.
         * @param dateTimeSettingManager A date/time user setting manager.
         */
        constructor(unitsSettingManager, dateTimeSettingManager) {
            this.renderer = new GenericNavDataBarFieldRenderer();
            this.renderer.register(exports.NavDataFieldType.BearingToWaypoint, new NavDataBarFieldBrgRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.Destination, new NavDataBarFieldDestRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.DistanceToWaypoint, new NavDataBarFieldDisRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.DistanceToDestination, new NavDataBarFieldDtgRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.DesiredTrack, new NavDataBarFieldDtkRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.Endurance, new NavDataBarFieldEndRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.TimeOfWaypointArrival, new NavDataBarFieldEtaRenderer(dateTimeSettingManager));
            this.renderer.register(exports.NavDataFieldType.TimeToWaypoint, new NavDataBarFieldEteRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.FuelOnBoard, new NavDataBarFieldFobRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.FuelOverDestination, new NavDataBarFieldFodRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.GroundSpeed, new NavDataBarFieldGsRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.ISA, new NavDataBarFieldIsaRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.TimeOfDestinationArrival, new NavDataBarFieldLdgRenderer(dateTimeSettingManager));
            this.renderer.register(exports.NavDataFieldType.TrueAirspeed, new NavDataBarFieldTasRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.TrackAngleError, new NavDataBarFieldTkeRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.GroundTrack, new NavDataBarFieldTrkRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.VerticalSpeedRequired, new NavDataBarFieldVsrRenderer(unitsSettingManager));
            this.renderer.register(exports.NavDataFieldType.CrossTrack, new NavDataBarFieldXtkRenderer(unitsSettingManager));
        }
        /**
         * Renders a navigation data bar field of a given type.
         * @param type A data bar field type.
         * @param model The data model for the field.
         * @returns A navigation data bar field of the given type, as a VNode.
         * @throws Error if an unsupported field type is specified.
         */
        render(type, model) {
            return this.renderer.render(type, model);
        }
    }

    /**
     * A navigation data bar field data model which uses an arbitrary subscribable to provide its value and function to
     * update the value.
     */
    class NavDataBarFieldGenericModel {
        /**
         * Constructor.
         * @param sub The subscribable used to provide this model's value.
         * @param updateFunc The function used to update this model's value. Can take an arbitrary number of arguments, but
         * the first must be the subscribable used to provide this model's value.
         * @param destroyFunc A function which is executed when this model is destroyed.
         */
        constructor(sub, updateFunc, destroyFunc) {
            this.updateFunc = updateFunc;
            this.destroyFunc = destroyFunc;
            this.value = sub;
        }
        /** @inheritdoc */
        update() {
            this.updateFunc(this.value);
        }
        /** @inheritdoc */
        destroy() {
            this.destroyFunc && this.destroyFunc();
        }
    }
    /**
     * A navigation data bar field data model which uses an arbitrary subscribable to provide its value and function to
     * update the value using data cached from one or more event bus consumers.
     */
    class NavDataBarFieldConsumerModel extends NavDataBarFieldGenericModel {
        /**
         * Constructor.
         * @param sub The subscribable used to provide this model's value.
         * @param consumers The event bus consumers used by this model.
         * @param initialValues The initial consumer values with which to initialize this model. These values will be used
         * until they are replaced by consumed values from the event bus.
         * @param updateFunc The function used to update this model's value. The first argument taken by the function is the
         * subscribable used to provide this model's value. The second argument is a tuple of Subscribables providing the
         * cached values from this model's consumers.
         */
        constructor(sub, consumers, initialValues, updateFunc) {
            super(sub, updateFunc, () => {
                for (let i = 0; i < this.consumerSubs.length; i++) {
                    this.consumerSubs[i].destroy();
                }
            });
            this.consumerSubs = consumers.map((consumer, index) => msfssdk.ConsumerSubject.create(consumer, initialValues[index]));
        }
        /** @inheritdoc */
        update() {
            this.updateFunc(this.value, this.consumerSubs);
        }
    }
    /**
     * A navigation data bar field data model which provides a {@link NumberUnitInterface} value that is derived directly
     * from an event bus consumer.
     */
    class NavDataBarFieldConsumerNumberUnitModel extends NavDataBarFieldConsumerModel {
        /**
         * Constructor.
         * @param consumer The event bus consumer used to derive this model's value.
         * @param initialVal The initial consumer value with which to initialize this model. This value will be used until it
         * is replaced by a consumed value from the event bus.
         * @param consumerUnit The unit type of the values consumed from the event bus.
         */
        constructor(consumer, initialVal, consumerUnit) {
            super(msfssdk.NumberUnitSubject.createFromNumberUnit(consumerUnit.createNumber(initialVal)), [consumer], [initialVal], (sub, consumerSubs) => { sub.set(consumerSubs[0].get()); });
        }
    }

    /**
     * A generic implementation of a factory for navigation data bar field data models. For each data field type, a
     * single-type model factory can be registered. Once registered, the single-type model factory is used to create data
     * models for its assigned data field type.
     */
    class GenericNavDataBarFieldModelFactory {
        constructor() {
            this.factories = new Map();
        }
        /**
         * Registers a single-type model factory with this factory.
         * @param type The data field type of the single-type model factory to register.
         * @param factory The single-type model factory to register.
         */
        register(type, factory) {
            this.factories.set(type, factory);
        }
        /**
         * Deregisters a single-type model factory from this factory.
         * @param type The data field type of the single-type model factory to deregister.
         * @returns Whether a single-type model factory was deregistered.
         */
        deregister(type) {
            return this.factories.delete(type);
        }
        /**
         * Creates a navigation data bar field data model for a given type of field.
         * @param type A data bar field type.
         * @returns A navigation data bar field data model for the given field type.
         * @throws Error if an unsupported field type is specified.
         */
        create(type) {
            var _a;
            const model = (_a = this.factories.get(type)) === null || _a === void 0 ? void 0 : _a.create();
            if (!model) {
                throw new Error(`GenericNavDataBarFieldModelFactory: no single-type model factory of data field type [${type}] is registered`);
            }
            return model;
        }
    }
    /**
     * An abstract implementation of {@link NavDataBarFieldTypeModelFactory} which accesses data from the event bus to use
     * to create its data models.
     */
    class EventBusNavDataBarFieldTypeModelFactory {
        /**
         * Constructor.
         * @param bus The event bus.
         */
        constructor(bus) {
            this.bus = bus;
            this.sub = this.bus.getSubscriber();
        }
    }
    /**
     * Creates data models for Bearing to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldBrgModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NavAngleSubject.createFromNavAngle(new msfssdk.NavAngleUnit(msfssdk.NavAngleUnitReferenceNorth.Magnetic, 0, 0).createNumber(0)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_waypoint_bearing_mag').whenChanged(),
                this.sub.on('gps-position')
            ], [false, 0, { lat: 0, long: 0 }], (sub, [isTracking, bearing, planePos]) => {
                const latLong = planePos.get();
                sub.set(isTracking.get() ? bearing.get() : NaN, latLong.lat, latLong.long);
            });
        }
    }
    /**
     * Creates data models for Bearing to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldDestModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param fms The flight management system.
         */
        constructor(bus, fms) {
            super(bus);
            this.fms = fms;
        }
        /** @inheritdoc */
        create() {
            let destinationIdent = '____';
            const originDestHandler = (event) => {
                if (event.planIndex === Fms.PRIMARY_PLAN_INDEX && event.type === msfssdk.OriginDestChangeType.DestinationAdded) {
                    destinationIdent = event.airport === undefined ? '____' : msfssdk.ICAO.getIdent(event.airport);
                }
                else if (event.type === msfssdk.OriginDestChangeType.DestinationRemoved) {
                    destinationIdent = '____';
                }
            };
            const loadHandler = (event) => {
                if (event.planIndex !== Fms.PRIMARY_PLAN_INDEX) {
                    return;
                }
                const primaryPlan = this.fms.getPrimaryFlightPlan();
                destinationIdent = primaryPlan.destinationAirport === undefined ? '____' : msfssdk.ICAO.getIdent(primaryPlan.destinationAirport);
            };
            const copyHandler = (event) => {
                if (event.targetPlanIndex !== Fms.PRIMARY_PLAN_INDEX) {
                    return;
                }
                const primaryPlan = this.fms.getPrimaryFlightPlan();
                destinationIdent = primaryPlan.destinationAirport === undefined ? '____' : msfssdk.ICAO.getIdent(primaryPlan.destinationAirport);
            };
            const originDestConsumer = this.sub.on('fplOriginDestChanged');
            originDestConsumer.handle(originDestHandler);
            const loadConsumer = this.sub.on('fplLoaded');
            loadConsumer.handle(loadHandler);
            const copyConsumer = this.sub.on('fplCopied');
            copyConsumer.handle(copyHandler);
            return new NavDataBarFieldGenericModel(msfssdk.Subject.create('____'), (sub) => {
                sub.set(destinationIdent);
            }, () => {
                originDestConsumer.off(originDestHandler);
                loadConsumer.off(loadHandler);
                copyConsumer.off(copyHandler);
            });
        }
    }
    /**
     * Creates data models for Distance to Waypoint navigation data bar fields.
     */
    class NavDataBarFieldDisModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_waypoint_distance').whenChanged()
            ], [false, 0], (sub, [isTracking, distance]) => {
                sub.set(isTracking.get() ? distance.get() : NaN);
            });
        }
    }
    /**
     * Creates data models for Distance to Destination navigation data bar fields.
     */
    class NavDataBarFieldDtgModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_destination_distance').whenChanged()
            ], [false, 0], (sub, [isTracking, distance]) => {
                sub.set(isTracking.get() ? distance.get() : NaN);
            });
        }
    }
    /**
     * Creates data models for Desired Track navigation data bar fields.
     */
    class NavDataBarFieldDtkModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NavAngleSubject.createFromNavAngle(new msfssdk.NavAngleUnit(msfssdk.NavAngleUnitReferenceNorth.Magnetic, 0, 0).createNumber(0)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_dtk_mag').whenChanged(),
                this.sub.on('gps-position')
            ], [false, 0, { lat: 0, long: 0 }], (sub, [isTracking, track, planePos]) => {
                const latLong = planePos.get();
                sub.set(isTracking.get() ? track.get() : NaN, latLong.lat, latLong.long);
            });
        }
    }
    /**
     * Creates data models for Endurance navigation data bar fields.
     */
    class NavDataBarFieldEndModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.HOUR.createNumber(NaN)), [
                this.sub.on('fuel_total').whenChanged(),
                this.sub.on('fuel_flow_total').whenChanged()
            ], [0, 0], (sub, [fuelRemaining, fuelFlow]) => {
                let endurance = NaN;
                const fuelFlowGph = fuelFlow.get();
                if (fuelFlowGph > 0) {
                    const fuelGal = fuelRemaining.get();
                    endurance = fuelGal / fuelFlowGph;
                }
                sub.set(endurance);
            });
        }
    }
    /**
     * Creates data models for Time To Destination navigation data bar fields.
     */
    class NavDataBarFieldEnrModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.HOUR.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_destination_distance').whenChanged(),
                this.sub.on('ground_speed').whenChanged()
            ], [false, 0, 0], (sub, [isTracking, distance, gs]) => {
                let time = NaN;
                if (isTracking.get()) {
                    const gsKnots = gs.get();
                    if (gsKnots > 30) {
                        const distanceNM = distance.get();
                        time = distanceNM / gsKnots;
                    }
                }
                sub.set(time);
            });
        }
    }
    /**
     * Creates data models for Estimated Time of Arrival navigation data bar fields.
     */
    class NavDataBarFieldEtaModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.Subject.create(NaN), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_waypoint_distance').whenChanged(),
                this.sub.on('ground_speed').whenChanged(),
                this.sub.on('simTime')
            ], [false, 0, 0, NaN], (sub, [isTracking, distance, gs, time]) => {
                let eta = NaN;
                if (isTracking.get()) {
                    const gsKnots = gs.get();
                    if (gsKnots > 30) {
                        const distanceNM = distance.get();
                        eta = msfssdk.UnitType.HOUR.convertTo(distanceNM / gsKnots, msfssdk.UnitType.MILLISECOND) + time.get();
                    }
                }
                sub.set(eta);
            });
        }
    }
    /**
     * Creates data models for Time To Waypoint navigation data bar fields.
     */
    class NavDataBarFieldEteModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.HOUR.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_waypoint_distance').whenChanged(),
                this.sub.on('ground_speed').whenChanged()
            ], [false, 0, 0], (sub, [isTracking, distance, gs]) => {
                let time = NaN;
                if (isTracking.get()) {
                    const gsKnots = gs.get();
                    if (gsKnots > 30) {
                        const distanceNM = distance.get();
                        time = distanceNM / gsKnots;
                    }
                }
                sub.set(time);
            });
        }
    }
    /**
     * Creates data models for Fuel on Board navigation data bar fields.
     */
    class NavDataBarFieldFobModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerNumberUnitModel(this.sub.on('fuel_total'), 0, msfssdk.UnitType.GALLON_FUEL);
        }
    }
    /**
     * Creates data models for Fuel Over Destination navigation data bar fields.
     */
    class NavDataBarFieldFodModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.GALLON_FUEL.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_destination_distance').whenChanged(),
                this.sub.on('ground_speed').whenChanged(),
                this.sub.on('fuel_total').whenChanged(),
                this.sub.on('fuel_flow_total').whenChanged()
            ], [false, 0, 0, 0, 0], (sub, [isTracking, distance, gs, fuelRemaining, fuelFlow]) => {
                let fod = NaN;
                if (isTracking.get()) {
                    const gsKnots = gs.get();
                    const fuelFlowGph = fuelFlow.get();
                    if (gsKnots > 30 && fuelFlowGph > 0) {
                        const distanceNM = distance.get();
                        const fuelGal = fuelRemaining.get();
                        fod = fuelGal - distanceNM / gsKnots * fuelFlowGph;
                    }
                }
                sub.set(fod);
            });
        }
    }
    /**
     * Creates data models for Ground Speed navigation data bar fields.
     */
    class NavDataBarFieldGsModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerNumberUnitModel(this.sub.on('ground_speed'), 0, msfssdk.UnitType.KNOT);
        }
    }
    /**
     * Creates data models for ISA navigation data bar fields.
     */
    class NavDataBarFieldIsaModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerNumberUnitModel(this.sub.on('isa_temp_c'), 0, msfssdk.UnitType.CELSIUS);
        }
    }
    /**
     * Creates data models for Estimated Time of Arrival at Destination navigation data bar fields.
     */
    class NavDataBarFieldLdgModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.Subject.create(NaN), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_destination_distance').whenChanged(),
                this.sub.on('ground_speed').whenChanged(),
                this.sub.on('simTime')
            ], [false, 0, 0, NaN], (sub, [isTracking, distance, gs, time]) => {
                let eta = NaN;
                if (isTracking.get()) {
                    const gsKnots = gs.get();
                    if (gsKnots > 30) {
                        const distanceNM = distance.get();
                        eta = msfssdk.UnitType.HOUR.convertTo(distanceNM / gsKnots, msfssdk.UnitType.MILLISECOND) + time.get();
                    }
                }
                sub.set(eta);
            });
        }
    }
    /**
     * Creates data models for True Airspeed navigation data bar fields.
     */
    class NavDataBarFieldTasModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerNumberUnitModel(this.sub.on('tas'), 0, msfssdk.UnitType.KNOT);
        }
    }
    /**
     * Creates data models for Track Angle Error navigation data bar fields.
     */
    class NavDataBarFieldTkeModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.DEGREE.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_dtk_true').whenChanged(),
                this.sub.on('track_deg_true').whenChanged()
            ], [false, 0, 0], (sub, [isTracking, dtk, track]) => {
                sub.set(isTracking.get() ? msfssdk.NavMath.diffAngle(dtk.get(), track.get()) : NaN);
            });
        }
    }
    /**
     * Creates data models for Ground Track navigation data bar fields.
     */
    class NavDataBarFieldTrkModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NavAngleSubject.createFromNavAngle(new msfssdk.NavAngleUnit(msfssdk.NavAngleUnitReferenceNorth.Magnetic, 0, 0).createNumber(0)), [
                this.sub.on('track_deg_magnetic'),
                this.sub.on('gps-position')
            ], [0, { lat: 0, long: 0 }], (sub, [track, planePos]) => {
                const latLong = planePos.get();
                sub.set(track.get(), latLong.lat, latLong.long);
            });
        }
    }
    /**
     * Creates data models for Vertical Speed Required navigation data bar fields.
     */
    class NavDataBarFieldVsrModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.FPM.createNumber(NaN)), [
                this.sub.on('vnav_path_display').whenChanged(),
                this.sub.on('vnav_required_vs').whenChanged()
            ], [false, 0], (sub, [shouldDisplay, vsr]) => {
                sub.set(shouldDisplay.get() ? vsr.get() : NaN);
            });
        }
    }
    /**
     * Creates data models for Cross Track navigation data bar fields.
     */
    class NavDataBarFieldXtkModelFactory extends EventBusNavDataBarFieldTypeModelFactory {
        /** @inheritdoc */
        create() {
            return new NavDataBarFieldConsumerModel(msfssdk.NumberUnitSubject.createFromNumberUnit(msfssdk.UnitType.NMILE.createNumber(NaN)), [
                this.sub.on('lnav_is_tracking').whenChanged(),
                this.sub.on('lnavdata_xtk').whenChanged()
            ], [false, 0], (sub, [isTracking, xtk]) => {
                sub.set(isTracking.get() ? xtk.get() : NaN);
            });
        }
    }

    /**
     * A default implementation of NavDataBarFieldModelFactory.
     */
    class DefaultNavDataBarFieldModelFactory {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param fms The flight management system.
         */
        constructor(bus, fms) {
            this.factory = new GenericNavDataBarFieldModelFactory();
            this.factory.register(exports.NavDataFieldType.BearingToWaypoint, new NavDataBarFieldBrgModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.Destination, new NavDataBarFieldDestModelFactory(bus, fms));
            this.factory.register(exports.NavDataFieldType.DistanceToWaypoint, new NavDataBarFieldDisModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.DistanceToDestination, new NavDataBarFieldDtgModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.DesiredTrack, new NavDataBarFieldDtkModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.Endurance, new NavDataBarFieldEndModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.TimeOfWaypointArrival, new NavDataBarFieldEtaModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.TimeToWaypoint, new NavDataBarFieldEteModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.FuelOnBoard, new NavDataBarFieldFobModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.FuelOverDestination, new NavDataBarFieldFodModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.GroundSpeed, new NavDataBarFieldGsModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.ISA, new NavDataBarFieldIsaModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.TimeOfDestinationArrival, new NavDataBarFieldLdgModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.TrueAirspeed, new NavDataBarFieldTasModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.TrackAngleError, new NavDataBarFieldTkeModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.GroundTrack, new NavDataBarFieldTrkModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.VerticalSpeedRequired, new NavDataBarFieldVsrModelFactory(bus));
            this.factory.register(exports.NavDataFieldType.CrossTrack, new NavDataBarFieldXtkModelFactory(bus));
        }
        /**
         * Creates a navigation data bar field data model for a given type of field.
         * @param type A data bar field type.
         * @returns A navigation data bar field data model for the given field type.
         * @throws Error if an unsupported field type is specified.
         */
        create(type) {
            return this.factory.create(type);
        }
    }

    /**
     * A navigation data bar. Displays zero or more navigation data fields.
     *
     * The root element of the status bar contains the `nav-data-bar` CSS class by default.
     */
    class NavDataBar extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.fieldRenderer = new DefaultNavDataBarFieldRenderer(this.props.unitsSettingManager, this.props.dateTimeSettingManager);
            this.fieldCount = Math.max(0, this.props.fieldCount);
            this.fieldSlots = Array.from({ length: this.fieldCount }, () => msfssdk.FSComponent.buildComponent("div", null));
            this.fields = [];
            this.models = [];
            this.settingSubs = [];
        }
        /** @inheritdoc */
        onAfterRender() {
            for (let i = 0; i < this.fieldCount; i++) {
                this.settingSubs[i] = this.props.dataBarSettingManager.whenSettingChanged(`navDataBarField${i}`).handle(this.onFieldSettingChanged.bind(this, i));
            }
            this.clockSub = this.props.bus.getSubscriber().on('realTime').whenChangedBy(1000 / this.props.updateFreq).handle(this.onUpdated.bind(this));
        }
        /**
         * Responds to changes in field settings.
         * @param index The index of the field whose setting changed.
         * @param type The new setting.
         */
        onFieldSettingChanged(index, type) {
            var _a, _b;
            const slot = this.fieldSlots[index].instance;
            slot.innerHTML = '';
            (_a = this.fields[index]) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.models[index]) === null || _b === void 0 ? void 0 : _b.destroy();
            const model = this.props.modelFactory.create(type);
            model.update();
            const field = this.fieldRenderer.render(type, model);
            this.models[index] = model;
            msfssdk.FSComponent.render(field, slot);
            this.fields[index] = field.instance;
        }
        /**
         * Responds to update events.
         */
        onUpdated() {
            for (let i = 0; i < this.fieldCount; i++) {
                this.models[i].update();
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'nav-data-bar' }, this.fieldSlots));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
            for (let i = 0; i < this.fieldCount; i++) {
                this.settingSubs[i].destroy();
                (_b = this.fields[i]) === null || _b === void 0 ? void 0 : _b.destroy();
                (_c = this.models[i]) === null || _c === void 0 ? void 0 : _c.destroy();
            }
        }
    }

    /**
     * A touchscreen button.
     *
     * The root element of the button contains the `touch-button` CSS class by default. The root element also
     * conditionally contains the `touch-button-disabled` and `touch-button-primed` classes when the button is disabled
     * and primed, respectively.
     *
     * The root element optionally contains a child label element with the CSS class `touch-button-label`.
     */
    class TouchButton extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootRef = msfssdk.FSComponent.createRef();
            this.mouseDownListener = this.onMouseDown.bind(this);
            this.mouseUpListener = this.onMouseUp.bind(this);
            this.mouseLeaveListener = this.onMouseLeave.bind(this);
            this.isEnabled = msfssdk.Subject.create(true);
            this.isHighlighted = msfssdk.Subject.create(false);
            this.isVisible = msfssdk.Subject.create(true);
            this.isPrimed = false;
            this.cssClassSet = msfssdk.SetSubject.create(['touch-button']);
        }
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onAfterRender(node) {
            var _a, _b, _c;
            if (typeof this.props.isEnabled === 'object') {
                this.isEnabledPipe = this.props.isEnabled.pipe(this.isEnabled);
            }
            else {
                this.isEnabled.set((_a = this.props.isEnabled) !== null && _a !== void 0 ? _a : true);
            }
            if (typeof this.props.isHighlighted === 'object') {
                this.isHighlightedPipe = this.props.isHighlighted.pipe(this.isHighlighted);
            }
            else {
                this.isHighlighted.set((_b = this.props.isHighlighted) !== null && _b !== void 0 ? _b : false);
            }
            if (msfssdk.SubscribableUtils.isSubscribable(this.props.isVisible)) {
                this.isVisiblePipe = this.props.isVisible.pipe(this.isVisible);
            }
            else {
                this.isVisible.set((_c = this.props.isVisible) !== null && _c !== void 0 ? _c : true);
            }
            this.isEnabled.sub(isEnabled => {
                if (isEnabled) {
                    this.cssClassSet.delete('touch-button-disabled');
                }
                else {
                    this.cssClassSet.add('touch-button-disabled');
                }
                if (!isEnabled) {
                    this.setPrimed(false);
                }
            }, true);
            this.isHighlighted.sub(isHighlighted => {
                if (isHighlighted) {
                    this.cssClassSet.add('touch-button-highlight');
                }
                else {
                    this.cssClassSet.delete('touch-button-highlight');
                }
            }, true);
            this.isVisible.sub(isVisible => {
                if (isVisible) {
                    this.cssClassSet.delete('touch-button-hidden');
                }
                else {
                    this.cssClassSet.add('touch-button-hidden');
                }
            }, true);
            this.rootRef.instance.addEventListener('mousedown', this.mouseDownListener);
            this.rootRef.instance.addEventListener('mouseup', this.mouseUpListener);
            this.rootRef.instance.addEventListener('mouseleave', this.mouseLeaveListener);
        }
        /**
         * Sets the primed state of this button.
         * @param isPrimed The new primed state.
         */
        setPrimed(isPrimed) {
            if (this.isPrimed === isPrimed) {
                return;
            }
            this.isPrimed = isPrimed;
            if (isPrimed) {
                this.cssClassSet.add('touch-button-primed');
            }
            else {
                this.cssClassSet.delete('touch-button-primed');
            }
        }
        /**
         * Responds to mouse down events on this button's root element.
         */
        onMouseDown() {
            if (this.isEnabled.get()) {
                this.setPrimed(true);
            }
        }
        /**
         * Responds to mouse up events on this button's root element.
         */
        onMouseUp() {
            const wasPrimed = this.isPrimed;
            this.setPrimed(false);
            if (wasPrimed && this.isEnabled.get()) {
                this.onPressed();
            }
        }
        /**
         * Responds to mouse leave events on this button's root element.
         */
        onMouseLeave() {
            this.setPrimed(false);
        }
        /**
         * Responds to when this button is pressed.
         */
        onPressed() {
            this.props.onPressed && this.props.onPressed(this);
        }
        /** @inheritdoc */
        render() {
            var _a;
            const reservedClasses = this.getReservedCssClasses();
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, reservedClasses);
            }
            else {
                for (const cssClassToAdd of msfssdk.FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(cssClass => !reservedClasses.has(cssClass))) {
                    this.cssClassSet.add(cssClassToAdd);
                }
            }
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.rootRef, class: this.cssClassSet },
                this.renderLabel(),
                this.props.children));
        }
        /**
         * Renders this button's label.
         * @returns This button's rendered label, or `null` if this button does not have a label.
         */
        renderLabel() {
            if (this.props.label === undefined) {
                return null;
            }
            return (msfssdk.FSComponent.buildComponent("div", { class: 'touch-button-label' }, this.props.label));
        }
        /**
         * Gets the CSS classes that are reserved for this button's root element.
         * @returns The CSS classes that are reserved for this button's root element.
         */
        getReservedCssClasses() {
            return new Set(['touch-button', 'touch-button-disabled', 'touch-button-primed',
                'touch-button-highlight', 'touch-button-hidden']);
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.isEnabledPipe) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.isHighlightedPipe) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.isVisiblePipe) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.cssClassSub) === null || _d === void 0 ? void 0 : _d.destroy();
            this.rootRef.instance.removeEventListener('mousedown', this.mouseDownListener);
            this.rootRef.instance.removeEventListener('mouseup', this.mouseUpListener);
            this.rootRef.instance.removeEventListener('mouseleave', this.mouseLeaveListener);
            this.props.onDestroy && this.props.onDestroy();
        }
    }

    /**
     * A touchscreen button which displays whether the value of a bound state is equal to a set value. By default, pressing
     * the button will apply its set value to the state. This behavior can be overridden by providing a custom callback
     * function which runs when the button is pressed.
     *
     * The root element of the button contains the `touch-button-set-value` CSS class by default, in addition to all
     * root-element classes used by {@link TouchButton}.
     *
     * The root element contains a child {@link ToggleStatusBar} component with the CSS class
     * `touch-button-set-value-status-bar` and an optional label element with the CSS class `touch-button-label`.
     */
    class SetValueTouchButton extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.buttonRef = msfssdk.FSComponent.createRef();
            this.statusBarRef = msfssdk.FSComponent.createRef();
            this.cssClassSet = msfssdk.SetSubject.create(['touch-button-set-value']);
            this.toggleState = msfssdk.MappedSubject.create(([state, setValue]) => state === setValue, this.props.state, this.props.setValue);
        }
        /** @inheritdoc */
        render() {
            var _a;
            let onPressed;
            if (this.props.onPressed) {
                onPressed = () => {
                    this.props.onPressed(this, this.props.state);
                };
            }
            else {
                onPressed = () => { this.props.state.set(this.props.setValue.get()); };
            }
            const reservedClasses = this.getReservedCssClasses();
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, reservedClasses);
            }
            else {
                for (const cssClassToAdd of msfssdk.FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(cssClass => !reservedClasses.has(cssClass))) {
                    this.cssClassSet.add(cssClassToAdd);
                }
            }
            return (msfssdk.FSComponent.buildComponent(TouchButton, { ref: this.buttonRef, isEnabled: this.props.isEnabled, isHighlighted: this.props.isHighlighted, label: this.props.label, onPressed: onPressed, class: this.cssClassSet },
                msfssdk.FSComponent.buildComponent(ToggleStatusBar, { ref: this.statusBarRef, state: this.toggleState, class: 'touch-button-set-value-status-bar' }),
                this.props.children));
        }
        /**
         * Gets the CSS classes that are reserved for this button's root element.
         * @returns The CSS classes that are reserved for this button's root element.
         */
        getReservedCssClasses() {
            return new Set(['touch-button-set-value']);
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.buttonRef.instance.destroy();
            this.statusBarRef.instance.destroy();
            this.toggleState.destroy();
            this.props.onDestroy && this.props.onDestroy();
        }
    }

    /**
     * A touchscreen button which displays the value of a bound boolean state. By default, pressing the button will toggle
     * its state if the state is mutable. This behavior can be overridden by providing a custom callback function which
     * runs when the button is pressed.
     *
     * The root element of the button contains the `touch-button-toggle` CSS class by default, in addition to all
     * root-element classes used by {@link TouchButton}.
     *
     * The root element contains a child {@link ToggleStatusBar} component with the CSS class
     * `touch-button-toggle-status-bar` and an optional label element with the CSS class `touch-button-label`.
     */
    class ToggleTouchButton extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.buttonRef = msfssdk.FSComponent.createRef();
            this.statusBarRef = msfssdk.FSComponent.createRef();
            this.cssClassSet = msfssdk.SetSubject.create(['touch-button-toggle']);
        }
        /** @inheritdoc */
        render() {
            var _a;
            let onPressed;
            const state = this.props.state;
            if (this.props.onPressed) {
                onPressed = () => {
                    this.props.onPressed(this, state);
                };
            }
            else if ('isMutableSubscribable' in state) {
                onPressed = () => { state.set(!state.get()); };
            }
            const reservedClasses = this.getReservedCssClasses();
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, reservedClasses);
            }
            else {
                for (const cssClassToAdd of msfssdk.FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(cssClass => !reservedClasses.has(cssClass))) {
                    this.cssClassSet.add(cssClassToAdd);
                }
            }
            return (msfssdk.FSComponent.buildComponent(TouchButton, { ref: this.buttonRef, isEnabled: this.props.isEnabled, isHighlighted: this.props.isHighlighted, label: this.props.label, onPressed: onPressed, class: this.cssClassSet },
                msfssdk.FSComponent.buildComponent(ToggleStatusBar, { ref: this.statusBarRef, state: this.props.state, class: 'touch-button-toggle-status-bar' }),
                this.props.children));
        }
        /**
         * Gets the CSS classes that are reserved for this button's root element.
         * @returns The CSS classes that are reserved for this button's root element.
         */
        getReservedCssClasses() {
            return new Set(['touch-button-toggle']);
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.buttonRef.instance.destroy();
            this.statusBarRef.instance.destroy();
            this.props.onDestroy && this.props.onDestroy();
        }
    }

    /**
     * A touchscreen button which displays the value of a bound state.
     *
     * The root element of the button contains the `touch-button-value` CSS class by default, in addition to all
     * root-element classes used by {@link TouchButton}.
     *
     * The value of the button's bound state is rendered into a child `div` element containing the CSS class
     * `touch-button-value-value`.
     */
    class ValueTouchButton extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.buttonRef = msfssdk.FSComponent.createRef();
            this.valueRef = msfssdk.FSComponent.createRef();
            this.cssClassSet = msfssdk.SetSubject.create(['touch-button-value']);
        }
        /**
         * Responds to when this button is pressed.
         */
        onPressed() {
            this.props.onPressed && this.props.onPressed(this, this.props.state);
        }
        /** @inheritdoc */
        render() {
            var _a;
            const reservedClasses = this.getReservedCssClasses();
            if (typeof this.props.class === 'object') {
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, reservedClasses);
            }
            else {
                for (const cssClassToAdd of msfssdk.FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(cssClass => !reservedClasses.has(cssClass))) {
                    this.cssClassSet.add(cssClassToAdd);
                }
            }
            return (msfssdk.FSComponent.buildComponent(TouchButton, { ref: this.buttonRef, isEnabled: this.props.isEnabled, isHighlighted: this.props.isHighlighted, label: this.props.label, onPressed: this.onPressed.bind(this), class: this.cssClassSet },
                this.renderValue(),
                this.props.children));
        }
        /**
         * Renders this button's value display.
         * @returns This button's rendered value display.
         */
        renderValue() {
            let content;
            if (this.props.renderValue === undefined) {
                content = this.renderedValue = this.props.state.map(state => `${state}`);
            }
            else if (typeof this.props.renderValue === 'function') {
                content = this.renderedValue = this.props.state.map(this.props.renderValue);
            }
            else {
                content = this.props.renderValue;
            }
            return (msfssdk.FSComponent.buildComponent("div", { ref: this.valueRef, class: 'touch-button-value-value' }, content));
        }
        /**
         * Gets the CSS classes that are reserved for this button's root element.
         * @returns The CSS classes that are reserved for this button's root element.
         */
        getReservedCssClasses() {
            return new Set(['touch-button-value']);
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            this.buttonRef.instance.destroy();
            (_a = this.renderedValue) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
            this.props.onDestroy && this.props.onDestroy();
        }
    }

    /**
     * Width options for airspeed indicator color ranges.
     */
    exports.AirspeedIndicatorColorRangeWidth = void 0;
    (function (AirspeedIndicatorColorRangeWidth) {
        AirspeedIndicatorColorRangeWidth["Full"] = "Full";
        AirspeedIndicatorColorRangeWidth["Half"] = "Half";
    })(exports.AirspeedIndicatorColorRangeWidth || (exports.AirspeedIndicatorColorRangeWidth = {}));
    /**
     * Color options for airspeed indicator color ranges.
     */
    exports.AirspeedIndicatorColorRangeColor = void 0;
    (function (AirspeedIndicatorColorRangeColor) {
        AirspeedIndicatorColorRangeColor["Red"] = "Red";
        AirspeedIndicatorColorRangeColor["Yellow"] = "Yellow";
        AirspeedIndicatorColorRangeColor["White"] = "White";
        AirspeedIndicatorColorRangeColor["Green"] = "Green";
        AirspeedIndicatorColorRangeColor["BarberPole"] = "BarberPole";
    })(exports.AirspeedIndicatorColorRangeColor || (exports.AirspeedIndicatorColorRangeColor = {}));

    /**
     * Types of airspeed alerts.
     */
    exports.AirspeedAlert = void 0;
    (function (AirspeedAlert) {
        AirspeedAlert[AirspeedAlert["None"] = 0] = "None";
        AirspeedAlert[AirspeedAlert["Overspeed"] = 1] = "Overspeed";
        AirspeedAlert[AirspeedAlert["TrendOverspeed"] = 2] = "TrendOverspeed";
        AirspeedAlert[AirspeedAlert["Underspeed"] = 4] = "Underspeed";
        AirspeedAlert[AirspeedAlert["TrendUnderspeed"] = 8] = "TrendUnderspeed";
    })(exports.AirspeedAlert || (exports.AirspeedAlert = {}));
    /**
     * A default implementation of {@link AirspeedIndicatorDataProvider}.
     */
    class DefaultAirspeedIndicatorDataProvider {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param adcIndex The index of the ADC that is the source of this provider's data.
         * @param options Configuration options for this provider.
         */
        constructor(bus, adcIndex, options) {
            this.bus = bus;
            this._iasKnots = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.iasKnots = this._iasKnots;
            this._tasKnots = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.tasKnots = this._tasKnots;
            this._mach = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.mach = this._mach;
            this._machToKias = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.machToKias = this._machToKias;
            this._pressureAlt = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.pressureAlt = this._pressureAlt;
            this._iasTrend = msfssdk.Subject.create(0);
            /** @inheritdoc */
            this.iasTrend = this._iasTrend;
            this._referenceIas = msfssdk.Subject.create(0);
            /** @inheritdoc */
            this.referenceIas = this._referenceIas;
            this._referenceMach = msfssdk.Subject.create(0);
            /** @inheritdoc */
            this.referenceMach = this._referenceMach;
            this._airspeedAlerts = msfssdk.Subject.create(0);
            /** @inheritdoc */
            this.airspeedAlerts = this._airspeedAlerts;
            this._isOverspeedProtectionActive = msfssdk.Subject.create(false);
            /** @inheritdoc */
            this.isOverspeedProtectionActive = this._isOverspeedProtectionActive;
            this._isUnderspeedProtectionActive = msfssdk.Subject.create(false);
            /** @inheritdoc */
            this.isUnderspeedProtectionActive = this._isUnderspeedProtectionActive;
            this.simTime = msfssdk.ConsumerSubject.create(null, 0);
            this.isOnGround = msfssdk.ConsumerSubject.create(null, false);
            this.referenceIasSource = msfssdk.ConsumerSubject.create(null, 0);
            this.referenceMachSource = msfssdk.ConsumerSubject.create(null, 0);
            this.isReferenceInMach = msfssdk.ConsumerSubject.create(null, false);
            this.referenceIasPipe = this.referenceIasSource.pipe(this._referenceIas, true);
            this.referenceMachPipe = this.referenceMachSource.pipe(this._referenceMach, true);
            this.isFlcActive = msfssdk.ConsumerSubject.create(null, false);
            this.iasTrendSmoother = new msfssdk.ExpSmoother(2000 / Math.LN2);
            this.lastTrendKnots = undefined;
            this.lastTrendTime = 0;
            this.isInit = false;
            this.isAlive = true;
            this.isPaused = false;
            this.adcIndex = msfssdk.SubscribableUtils.toSubscribable(adcIndex, true);
            this.trendLookahead = msfssdk.SubscribableUtils.toSubscribable(options.trendLookahead, true);
            this.overspeedThreshold = msfssdk.SubscribableUtils.toSubscribable(options.overspeedThreshold(this), true);
            this.underspeedThreshold = msfssdk.SubscribableUtils.toSubscribable(options.underspeedThreshold(this), true);
            // TODO: Add handling for auto-throttle
            this._isAirspeedHoldActive = msfssdk.MappedSubject.create(([isFlcActive]) => isFlcActive, this.isFlcActive);
            this.isAirspeedHoldActive = this._isAirspeedHoldActive;
            this.isOverspeed = msfssdk.MappedSubject.create(([iasKnots, threshold]) => iasKnots >= threshold, this._iasKnots, this.overspeedThreshold);
            this.isTrendOverspeed = msfssdk.MappedSubject.create(([iasKnots, iasTrend, threshold]) => iasKnots + iasTrend >= threshold, this._iasKnots, this._iasTrend, this.overspeedThreshold);
            this.isUnderspeed = msfssdk.MappedSubject.create(([iasKnots, threshold, isOnGround]) => !isOnGround && iasKnots <= threshold, this._iasKnots, this.underspeedThreshold, this.isOnGround);
            this.isTrendUnderspeed = msfssdk.MappedSubject.create(([iasKnots, iasTrend, threshold, isOnGround]) => !isOnGround && iasKnots + iasTrend <= threshold, this._iasKnots, this._iasTrend, this.underspeedThreshold, this.isOnGround);
        }
        /**
         * Initializes this data provider. Once initialized
         * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
         * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
         * @throws Error if this data provider is dead.
         */
        init(paused = false) {
            if (!this.isAlive) {
                throw new Error('DefaultAirspeedIndicatorDataProvider: cannot initialize a dead provider');
            }
            if (this.isInit) {
                return;
            }
            this.isInit = true;
            this.isPaused = paused;
            const sub = this.bus.getSubscriber();
            this.simTime.setConsumer(sub.on('simTime'));
            this.isOnGround.setConsumer(sub.on('on_ground'));
            this.adcIndexSub = this.adcIndex.sub(index => {
                this._iasKnots.setConsumer(sub.on(`adc_ias_${index}`));
                this._tasKnots.setConsumer(sub.on(`adc_tas_${index}`));
                this._mach.setConsumer(sub.on(`adc_mach_number_${index}`));
                this._machToKias.setConsumer(sub.on(`adc_mach_to_kias_factor_${index}`));
                this._pressureAlt.setConsumer(sub.on(`adc_pressure_alt_${index}`));
            }, true);
            this.referenceIasSource.setConsumer(sub.on('ap_ias_selected'));
            this.referenceMachSource.setConsumer(sub.on('ap_mach_selected'));
            this.isReferenceInMach.setConsumer(sub.on('ap_selected_speed_is_mach'));
            this.isFlcActive.setConsumer(sub.on('ap_flc_hold'));
            if (paused) {
                this.pause();
            }
            this.trendLookaheadSub = this.trendLookahead.sub(() => {
                this._iasTrend.set(0);
                this.iasTrendSmoother.reset();
            });
            this.simTime.sub(simTime => {
                var _a;
                const dt = simTime - this.lastTrendTime;
                const iasKnots = this.iasKnots.get();
                const oldKnots = this.lastTrendKnots;
                this.lastTrendKnots = iasKnots;
                this.lastTrendTime = simTime;
                let trend;
                if (dt < 0) {
                    trend = 0;
                    this.iasTrendSmoother.reset();
                }
                else if (dt > 0) {
                    if (oldKnots === undefined) {
                        trend = 0;
                        this.iasTrendSmoother.reset();
                    }
                    else {
                        trend = this.iasTrendSmoother.next((iasKnots - oldKnots) / dt * 1000 * this.trendLookahead.get(), dt);
                    }
                }
                else {
                    trend = (_a = this.iasTrendSmoother.last()) !== null && _a !== void 0 ? _a : 0;
                }
                this._iasTrend.set(trend);
            }, true);
            this.isReferenceInMach.sub(isReferenceInMach => {
                if (isReferenceInMach) {
                    this.referenceIasPipe.pause();
                    this._referenceIas.set(null);
                    this.referenceMachPipe.resume(true);
                }
                else {
                    this.referenceMachPipe.pause();
                    this._referenceMach.set(null);
                    this.referenceIasPipe.resume(true);
                }
            }, true);
            this.isOverspeed.sub(isOverspeed => {
                const alerts = this._airspeedAlerts.get();
                this._airspeedAlerts.set(msfssdk.BitFlags.set(alerts, isOverspeed ? exports.AirspeedAlert.Overspeed : exports.AirspeedAlert.None, exports.AirspeedAlert.Overspeed));
            }, true);
            this.isTrendOverspeed.sub(isTrendOverspeed => {
                const alerts = this._airspeedAlerts.get();
                this._airspeedAlerts.set(msfssdk.BitFlags.set(alerts, isTrendOverspeed ? exports.AirspeedAlert.TrendOverspeed : exports.AirspeedAlert.None, exports.AirspeedAlert.TrendOverspeed));
            }, true);
            this.isUnderspeed.sub(isUnderspeed => {
                const alerts = this._airspeedAlerts.get();
                this._airspeedAlerts.set(msfssdk.BitFlags.set(alerts, isUnderspeed ? exports.AirspeedAlert.Underspeed : exports.AirspeedAlert.None, exports.AirspeedAlert.Underspeed));
            }, true);
            this.isTrendUnderspeed.sub(isTrendUnderspeed => {
                const alerts = this._airspeedAlerts.get();
                this._airspeedAlerts.set(msfssdk.BitFlags.set(alerts, isTrendUnderspeed ? exports.AirspeedAlert.TrendUnderspeed : exports.AirspeedAlert.None, exports.AirspeedAlert.TrendUnderspeed));
            }, true);
        }
        /**
         * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
         * destroyed.
         * @throws Error if this data provider is dead.
         */
        resume() {
            if (!this.isAlive) {
                throw new Error('DefaultAirspeedIndicatorDataProvider: cannot resume a dead provider');
            }
            if (!this.isPaused) {
                return;
            }
            this.isPaused = false;
            this.simTime.resume();
            this.isOnGround.resume();
            this._iasKnots.resume();
            this._tasKnots.resume();
            this._mach.resume();
            this._machToKias.resume();
            this._pressureAlt.resume();
            this.referenceIasSource.resume();
            this.referenceMachSource.resume();
            this.isReferenceInMach.resume();
            this.isFlcActive.resume();
            this.isOverspeed.resume();
            this.isTrendOverspeed.resume();
            this.isUnderspeed.resume();
            this.isTrendUnderspeed.resume();
        }
        /**
         * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
         * @throws Error if this data provider is dead.
         */
        pause() {
            if (!this.isAlive) {
                throw new Error('DefaultAirspeedIndicatorDataProvider: cannot pause a dead provider');
            }
            if (this.isPaused) {
                return;
            }
            this.simTime.pause();
            this.isOnGround.pause();
            this._iasKnots.pause();
            this._tasKnots.pause();
            this._mach.pause();
            this._machToKias.pause();
            this._pressureAlt.pause();
            this.referenceIasSource.pause();
            this.referenceMachSource.pause();
            this.isReferenceInMach.pause();
            this.isFlcActive.pause();
            this.isOverspeed.pause();
            this.isTrendOverspeed.pause();
            this.isUnderspeed.pause();
            this.isTrendUnderspeed.pause();
            this.lastTrendKnots = undefined;
            this.isPaused = true;
        }
        /**
         * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
         * no longer be paused or resumed.
         */
        destroy() {
            var _a, _b;
            this.isAlive = false;
            this.simTime.destroy();
            this.isOnGround.destroy();
            this._iasKnots.destroy();
            this._tasKnots.destroy();
            this._mach.destroy();
            this._machToKias.destroy();
            this._pressureAlt.destroy();
            this.referenceIasSource.destroy();
            this.referenceMachSource.destroy();
            this.isReferenceInMach.destroy();
            this.isFlcActive.destroy();
            this.isOverspeed.destroy();
            this.isTrendOverspeed.destroy();
            this.isUnderspeed.destroy();
            this.isTrendUnderspeed.destroy();
            (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.trendLookaheadSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }

    /**
     * Modes for an airspeed indicator's bottom display box.
     */
    exports.AirspeedIndicatorBottomDisplayMode = void 0;
    (function (AirspeedIndicatorBottomDisplayMode) {
        AirspeedIndicatorBottomDisplayMode["TrueAirspeed"] = "Tas";
        AirspeedIndicatorBottomDisplayMode["Mach"] = "Mach";
    })(exports.AirspeedIndicatorBottomDisplayMode || (exports.AirspeedIndicatorBottomDisplayMode = {}));
    /**
     * A next-generation (NXi, G3000, etc) Garmin PFD airspeed indicator.
     */
    class AirspeedIndicator extends msfssdk.DisplayComponent {
        /** @inheritdoc */
        constructor(props) {
            super(props);
            this.referenceRef = msfssdk.FSComponent.createRef();
            this.alertRef = msfssdk.FSComponent.createRef();
            this.tapeRef = msfssdk.FSComponent.createRef();
            this.rootCssClass = msfssdk.SetSubject.create(['airspeed']);
            this.airspeedAlertOptions = Object.assign({}, this.props.airspeedAlertOptions);
            this.activeAlert = this.props.dataProvider.airspeedAlerts.map((alerts) => {
                // We should never have an overspeed and underspeed alert at the same time, but just in case, underspeed alerts
                // will take precedence
                if (this.airspeedAlertOptions.supportUnderspeed && msfssdk.BitFlags.isAny(alerts, exports.AirspeedAlert.Underspeed)) {
                    return exports.AirspeedAlert.Underspeed;
                }
                else if (this.airspeedAlertOptions.supportOverspeed && msfssdk.BitFlags.isAny(alerts, exports.AirspeedAlert.Overspeed)) {
                    return exports.AirspeedAlert.Overspeed;
                }
                else if (this.airspeedAlertOptions.supportTrendUnderspeed && msfssdk.BitFlags.isAny(alerts, exports.AirspeedAlert.TrendUnderspeed)) {
                    return exports.AirspeedAlert.TrendUnderspeed;
                }
                else if (this.airspeedAlertOptions.supportTrendOverspeed && msfssdk.BitFlags.isAny(alerts, exports.AirspeedAlert.TrendOverspeed)) {
                    return exports.AirspeedAlert.TrendOverspeed;
                }
                else {
                    return exports.AirspeedAlert.None;
                }
            });
            this.isReferenceDisplayVisible = msfssdk.Subject.create(false);
            this.isBottomSpeedDisplayVisible = msfssdk.Subject.create(false);
            this.activeAlert.pause();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.activeAlert.resume();
            this.isReferenceDisplayVisible.sub(isVisible => {
                if (isVisible) {
                    this.rootCssClass.add('airspeed-reference-visible');
                }
                else {
                    this.rootCssClass.delete('airspeed-reference-visible');
                }
            }, true);
            this.isBottomSpeedDisplayVisible.sub(isVisible => {
                if (isVisible) {
                    this.rootCssClass.add('airspeed-bottom-speed-display-visible');
                }
                else {
                    this.rootCssClass.delete('airspeed-bottom-speed-display-visible');
                }
            }, true);
            this.activeAlert.sub(this.updateAlertClass.bind(this), true);
        }
        /**
         * Updates this indicator's root CSS class list in response to the current active airspeed alert.
         * @param alert The current active airspeed alert.
         */
        updateAlertClass(alert) {
            this.rootCssClass.delete('airspeed-alert-overspeed');
            this.rootCssClass.delete('airspeed-alert-trend-overspeed');
            this.rootCssClass.delete('airspeed-alert-underspeed');
            this.rootCssClass.delete('airspeed-alert-trend-underspeed');
            switch (alert) {
                case exports.AirspeedAlert.Overspeed:
                    this.rootCssClass.add('airspeed-alert-overspeed');
                    break;
                case exports.AirspeedAlert.TrendOverspeed:
                    this.rootCssClass.add('airspeed-alert-trend-overspeed');
                    break;
                case exports.AirspeedAlert.Underspeed:
                    this.rootCssClass.add('airspeed-alert-underspeed');
                    break;
                case exports.AirspeedAlert.TrendUnderspeed:
                    this.rootCssClass.add('airspeed-alert-trend-underspeed');
                    break;
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass },
                msfssdk.FSComponent.buildComponent(AirspeedTape, Object.assign({ ref: this.tapeRef, dataProvider: this.props.dataProvider }, this.props.tapeScaleOptions, { colorRanges: this.props.colorRanges }, this.props.trendVectorOptions, this.props.vSpeedBugOptions)),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-top-container' },
                    msfssdk.FSComponent.buildComponent(AirspeedReferenceDisplay, { ref: this.referenceRef, referenceIas: this.props.dataProvider.referenceIas, referenceMach: this.props.dataProvider.referenceMach, isAirspeedHoldActive: this.props.dataProvider.isAirspeedHoldActive, isVisible: this.isReferenceDisplayVisible }),
                    msfssdk.FSComponent.buildComponent(AirspeedProtectionAnnunciation, { ref: this.alertRef, isOverspeedProtectionActive: this.props.dataProvider.isOverspeedProtectionActive, isUnderspeedProtectionActive: this.props.dataProvider.isUnderspeedProtectionActive })),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-bottom-container' }, this.props.bottomDisplayOptions.mode === exports.AirspeedIndicatorBottomDisplayMode.TrueAirspeed
                    ? (msfssdk.FSComponent.buildComponent(AirspeedTasDisplay, { tasKnots: this.props.dataProvider.tasKnots, isVisible: this.isBottomSpeedDisplayVisible }))
                    : (msfssdk.FSComponent.buildComponent(AirspeedMachDisplay, { mach: this.props.dataProvider.mach, threshold: (_a = this.props.bottomDisplayOptions.machThreshold) !== null && _a !== void 0 ? _a : msfssdk.Subject.create(0), isVisible: this.isBottomSpeedDisplayVisible })))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.referenceRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.alertRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.tapeRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
            this.activeAlert.destroy();
        }
    }
    /**
     * A next-generation (NXi, G3000, etc) Garmin airspeed tape.
     */
    class AirspeedTape extends msfssdk.DisplayComponent {
        /** @inheritdoc */
        constructor(props) {
            super(props);
            this.iasBoxRef = msfssdk.FSComponent.createRef();
            this.minorTickContainerRef = msfssdk.FSComponent.createRef();
            this.majorTickContainerRef = msfssdk.FSComponent.createRef();
            this.labelContainerRef = msfssdk.FSComponent.createRef();
            this.colorRangeRefs = [];
            this.manualRefSpeedBugRef = msfssdk.FSComponent.createRef();
            this.vSpeedBugRefs = [];
            this.vSpeedOffScaleLabelRefs = [];
            this.rootCssClass = msfssdk.SetSubject.create(['airspeed-tape-container']);
            this.labelTexts = [];
            this.tapeStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '50%',
                width: '100%',
                height: '100%',
                transform: 'translate3d(0, 0, 0)'
            });
            this.tapeClipStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '0%',
                width: '100%',
                height: '100%',
                overflow: 'hidden'
            });
            this.tapeOverflowTopStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '100%',
                width: '100%',
                height: '50%'
            });
            this.trendVectorStyle = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                bottom: '50%',
                height: '0%',
                transform: 'rotateX(0deg)',
                'transform-origin': '50% 100%'
            });
            this.vSpeedOffScaleContainerStyle = msfssdk.ObjectSubject.create({
                display: 'flex',
                'flex-flow': 'column-reverse nowrap',
                position: 'absolute',
                bottom: '0%',
                overflow: 'hidden'
            });
            this.currentLength = msfssdk.Subject.create(0);
            this.currentMinimum = 0;
            this.currentTranslate = msfssdk.Subject.create(0);
            this.minimum = msfssdk.SubscribableUtils.toSubscribable(this.props.minimum, true);
            this.maximum = msfssdk.SubscribableUtils.toSubscribable(this.props.maximum, true);
            this.window = msfssdk.SubscribableUtils.toSubscribable(this.props.window, true);
            this.majorTickInterval = msfssdk.SubscribableUtils.toSubscribable(this.props.majorTickInterval, true);
            this.minorTickFactor = msfssdk.SubscribableUtils.toSubscribable(this.props.minorTickFactor, true);
            this.options = msfssdk.CombinedSubject.create(this.minimum, this.maximum, this.window, this.majorTickInterval, this.minorTickFactor);
            this.isIasBelowScale = msfssdk.MappedSubject.create(([iasKnots, minimum]) => {
                return iasKnots < minimum;
            }, this.props.dataProvider.iasKnots, this.minimum);
            this.isIasAboveScale = msfssdk.MappedSubject.create(([iasKnots, maximum]) => {
                return iasKnots > maximum;
            }, this.props.dataProvider.iasKnots, this.maximum);
            this.isIasOffScale = msfssdk.MappedSubject.create(([isIasBelowScale, isIasAboveScale]) => {
                return isIasBelowScale || isIasAboveScale;
            }, this.isIasBelowScale, this.isIasAboveScale);
            this.iasTapeValue = msfssdk.MappedSubject.create(([iasKnots, minimum, maximum]) => {
                return msfssdk.MathUtils.clamp(iasKnots, minimum, maximum);
            }, this.props.dataProvider.iasKnots, this.minimum, this.maximum);
            this.iasBoxValue = msfssdk.MappedSubject.create(([iasKnots, isIasOffScale]) => {
                return isIasOffScale ? NaN : iasKnots;
            }, this.props.dataProvider.iasKnots, this.isIasOffScale);
            this.trendThreshold = msfssdk.SubscribableUtils.toSubscribable(this.props.trendThreshold, true);
            this.showTrendVector = msfssdk.MappedSubject.create(([iasKnot, minimum, maximum, threshold, iasTrend]) => {
                return iasKnot >= minimum && iasKnot < maximum && Math.abs(iasTrend) >= threshold;
            }, this.props.dataProvider.iasKnots, this.minimum, this.maximum, this.trendThreshold, this.props.dataProvider.iasTrend);
            this.iasTrendParams = msfssdk.CombinedSubject.create(this.props.dataProvider.iasTrend, this.window);
            this.trendVectorHeight = msfssdk.Subject.create(0);
            this.trendVectorScale = msfssdk.Subject.create(1);
            this.updateTapeEvent = new msfssdk.SubEvent();
            this.updateTapeWindowEvent = new msfssdk.SubEvent();
            this.colorRangeSubscribables = [];
            this.iasTapeValue.pause();
            this.iasBoxValue.pause();
            this.showTrendVector.pause();
            this.iasTrendParams.pause();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.iasTapeValue.resume();
            this.iasBoxValue.resume();
            this.iasTapeValue.sub(this.updateTape.bind(this));
            this.iasTrendParams.sub(this.updateTrendVector.bind(this));
            this.showTrendVector.resume();
            this.showTrendVector.sub(show => {
                if (show) {
                    this.trendVectorStyle.set('display', '');
                    this.iasTrendParams.resume();
                }
                else {
                    this.iasTrendParams.pause();
                    this.trendVectorStyle.set('display', 'none');
                }
            }, true);
            this.trendVectorHeight.sub(height => { this.trendVectorStyle.set('height', `${height}%`); });
            this.trendVectorScale.sub(scale => { this.trendVectorStyle.set('transform', `scale(${scale}) rotateX(0deg)`); });
            this.currentTranslate.sub(translate => {
                this.tapeStyle.set('transform', `translate3d(0, ${translate * 100}%, 0)`);
            });
            this.options.sub(this.rebuildTape.bind(this), true);
            this.isIasBelowScale.sub(isIasBelowScale => {
                this.vSpeedOffScaleContainerStyle.set('display', isIasBelowScale ? 'flex' : 'none');
            }, true);
        }
        /**
         * Calculates the absolute vertical position on the tape at which a particular airspeed is located, with `0` at the
         * top of the tape and `1` at the bottom.
         * @param iasKnots An airspeed, in knots.
         * @param clamp Whether the airspeed should be clamped to the range defined by this tape's minimum and maximum
         * representable airspeeds. Defaults to `false`.
         * @returns The absolute vertical position on the tape at which the specified airspeed is located, with `0` at the
         * top of the tape and `1` at the bottom.
         */
        calculateAbsoluteTapePosition(iasKnots, clamp = false) {
            if (clamp) {
                iasKnots = msfssdk.MathUtils.clamp(iasKnots, this.minimum.get(), this.maximum.get());
            }
            return 1 - (iasKnots - this.currentMinimum) / this.currentLength.get();
        }
        /**
         * Calculates the vertical position on the tape window at which a particular airspeed is located, with `0` at the top
         * of the tape window and `1` at the bottom.
         * @param iasKnots An airspeed, in knots.
         * @param clamp Whether the airspeed should be clamped to the range defined by this tape's minimum and maximum
         * representable airspeeds. Defaults to `false`.
         * @returns The vertical position on the tape window at which the specified airspeed is located, with `0` at the top
         * of the tape window and `1` at the bottom.
         */
        calculateWindowTapePosition(iasKnots, clamp = false) {
            return (this.calculateAbsoluteTapePosition(iasKnots, clamp) - 1 + this.currentTranslate.get()) * this.currentLength.get() / this.window.get() + 0.5;
        }
        /**
         * Rebuilds this tape's ticks and labels.
         * @param options Scale options for this tape, as `[minimum, maximum, window, majorTickInterval, minorTickFactor]`.
         */
        rebuildTape(options) {
            const [minimum, maximum, window, majorTickInterval, minorTickFactor] = options;
            this.labelTexts.length = 0;
            this.minorTickContainerRef.instance.innerHTML = '';
            const majorTickCount = Math.ceil(window / majorTickInterval) * 2 + 1;
            const desiredRange = (majorTickCount - 1) * majorTickInterval;
            this.currentLength.set(desiredRange);
            const maxRange = maximum - minimum;
            const trueRange = Math.min(maxRange, desiredRange);
            const heightFactor = trueRange / desiredRange;
            const len = (majorTickCount - 1) * minorTickFactor;
            for (let i = 0; i <= len; i++) {
                const y = 100 - (i / len) * 100 / heightFactor;
                if (i % minorTickFactor === 0) {
                    // major tick
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("path", { d: `M 0 ${y} L 100 ${y}`, "vector-effect": 'non-scaling-stroke', class: 'airspeed-tape-tick airspeed-tape-tick-major' }, "."), this.majorTickContainerRef.instance);
                    const text = msfssdk.Subject.create('0');
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-label', style: `position: absolute; right: 0%; top: ${y}%; transform: translateY(-50%)` }, text), this.labelContainerRef.instance);
                    this.labelTexts.push(text);
                }
                else {
                    // minor tick
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("path", { d: `M 0 ${y} L 100 ${y}`, "vector-effect": 'non-scaling-stroke', class: 'airspeed-tape-tick airspeed-tape-tick-minor' }, "."), this.minorTickContainerRef.instance);
                }
            }
            this.tapeStyle.set('height', `${100 * desiredRange / window}%`);
            this.tapeClipStyle.set('height', `${100 * heightFactor}%`);
            this.currentMinimum = minimum;
            this.updateTapeEvent.notify(this);
            this.updateTapeLabels();
            this.updateTapeOverflow();
            this.updateTape(this.iasTapeValue.get());
        }
        /**
         * Updates the tape based on the current indicated airspeed.
         * @param iasKnots The current indicated airspeed, in knots.
         */
        updateTape(iasKnots) {
            let tapePos = this.calculateAbsoluteTapePosition(iasKnots);
            if (tapePos <= 0.25 || tapePos >= 0.75) {
                const [minimum, maximum, window, majorTickInterval] = this.options.get();
                const desiredMinimum = Math.floor((iasKnots - window) / majorTickInterval) * majorTickInterval;
                const constrainedMinimum = Math.ceil((maximum - this.currentLength.get()) / majorTickInterval) * majorTickInterval;
                const minimumToSet = Math.max(minimum, Math.min(constrainedMinimum, desiredMinimum));
                if (this.currentMinimum !== minimumToSet) {
                    this.currentMinimum = minimumToSet;
                    this.updateTapeEvent.notify(this);
                    this.updateTapeLabels();
                    this.updateTapeOverflow();
                    tapePos = msfssdk.MathUtils.clamp(this.calculateAbsoluteTapePosition(iasKnots), 0, 1);
                }
            }
            this.currentTranslate.set(msfssdk.MathUtils.round(1 - tapePos, 1e-3));
            this.updateTapeWindowEvent.notify(this);
        }
        /**
         * Updates this tape's labels.
         */
        updateTapeLabels() {
            const interval = this.majorTickInterval.get();
            for (let i = 0; i < this.labelTexts.length; i++) {
                this.labelTexts[i].set((this.currentMinimum + interval * i).toFixed(0));
            }
        }
        /**
         * Updates this tape's overflow regions.
         */
        updateTapeOverflow() {
            const maximumPos = this.calculateAbsoluteTapePosition(this.maximum.get());
            this.tapeOverflowTopStyle.set('bottom', `${Math.min(100, 100 - maximumPos * 100)}%`);
        }
        /**
         * Updates this tape's speed trend vector.
         * @param params Parameters for the speed trend vector, as `[iasTrend, window]`.
         */
        updateTrendVector(params) {
            const [iasTrend, window] = params;
            this.trendVectorHeight.set(msfssdk.MathUtils.clamp(msfssdk.MathUtils.round(Math.abs(iasTrend) / window * 100, 0.1), 0, 50));
            this.trendVectorScale.set(iasTrend < 0 ? -1 : 1);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass },
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-border-top' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-border-bottom' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-window', style: 'overflow: hidden;' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape', style: this.tapeStyle },
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-color-range-container', style: 'position: absolute; left: 0%; top: 0%; height: 100%; width: 100%' }, this.renderColorRanges()),
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-clip', style: this.tapeClipStyle },
                            msfssdk.FSComponent.buildComponent("svg", { ref: this.minorTickContainerRef, class: 'airspeed-tape-tick-minor-container', viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: 'position: absolute; top: 0; height: 100%;' }),
                            msfssdk.FSComponent.buildComponent("svg", { ref: this.majorTickContainerRef, class: 'airspeed-tape-tick-major-container', viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: 'position: absolute; top: 0; height: 100%;' }),
                            msfssdk.FSComponent.buildComponent("div", { ref: this.labelContainerRef, class: 'airspeed-tape-label-container', style: 'position: absolute; top: 0; height: 100%; text-align: right;' })),
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-overflow', style: this.tapeOverflowTopStyle }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tape-overflow', style: 'position: absolute; left: 0; top: 100%; width: 100%; height: 50%;' }))),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-trend', style: this.trendVectorStyle }),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-offscale-container', style: this.vSpeedOffScaleContainerStyle }, this.renderOffScaleVSpeedLabels()),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-bug-container', style: 'position: absolute; top: 0; height: 100%; overflow: hidden;' }, this.renderVSpeedBugs()),
                msfssdk.FSComponent.buildComponent(AirspeedIasDisplayBox, { ref: this.iasBoxRef, ias: this.iasBoxValue }),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-refspeed-bug-container', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden;' },
                    msfssdk.FSComponent.buildComponent(ManualReferenceSpeedBug, { ref: this.manualRefSpeedBugRef, referenceIas: this.props.dataProvider.referenceIas, referenceMach: this.props.dataProvider.referenceMach, machToKias: this.props.dataProvider.machToKias, isAirspeedHoldActive: this.props.dataProvider.isAirspeedHoldActive, updateEvent: this.updateTapeWindowEvent, getPosition: this.calculateWindowTapePosition.bind(this) }))));
        }
        /**
         * Renders this tape's color ranges.
         * @returns This tape's color ranges, as an array of VNodes.
         */
        renderColorRanges() {
            const getPosition = this.calculateAbsoluteTapePosition.bind(this);
            const ranges = [];
            for (const definition of this.props.colorRanges) {
                const minimum = definition.minimum(this.props.dataProvider);
                const maximum = definition.maximum(this.props.dataProvider);
                const ref = msfssdk.FSComponent.createRef();
                this.colorRangeRefs.push(ref);
                if (msfssdk.SubscribableUtils.isSubscribable(minimum)) {
                    this.colorRangeSubscribables.push(minimum);
                }
                if (msfssdk.SubscribableUtils.isSubscribable(maximum)) {
                    this.colorRangeSubscribables.push(maximum);
                }
                ranges.push(msfssdk.FSComponent.buildComponent(AirspeedColorRange, { ref: ref, width: definition.width, color: definition.color, minimum: minimum, maximum: maximum, updateEvent: this.updateTapeEvent, getPosition: getPosition }));
            }
            return ranges;
        }
        /**
         * Renders this tape's reference V-speed bugs.
         * @returns This tape's reference V-speed bugs, as an array of VNodes.
         */
        renderVSpeedBugs() {
            const getPosition = this.calculateWindowTapePosition.bind(this);
            const bugs = [];
            for (const def of this.props.vSpeedBugDefinitions) {
                const valueSetting = this.props.vSpeedSettingManager.tryGetSetting(`vSpeedValue_${def.name}`);
                const showSetting = this.props.vSpeedSettingManager.tryGetSetting(`vSpeedShow_${def.name}`);
                if (valueSetting !== undefined && showSetting !== undefined) {
                    const ref = msfssdk.FSComponent.createRef();
                    this.vSpeedBugRefs.push(ref);
                    bugs.push(msfssdk.FSComponent.buildComponent(VSpeedBug, { ref: ref, value: valueSetting, label: def.label, isVisible: msfssdk.MappedSubject.create(([isIasOffScale, show]) => !isIasOffScale && show, this.isIasOffScale, showSetting), updateEvent: this.updateTapeWindowEvent, getPosition: getPosition }));
                }
            }
            return bugs;
        }
        /**
         * Renders this tape's reference V-speed off-scale labels.
         * @returns This tape's reference V-speed off-scale labels, as an array of VNodes.
         */
        renderOffScaleVSpeedLabels() {
            const labels = [];
            for (const def of this.props.vSpeedBugDefinitions) {
                const valueSetting = this.props.vSpeedSettingManager.tryGetSetting(`vSpeedValue_${def.name}`);
                const showSetting = this.props.vSpeedSettingManager.tryGetSetting(`vSpeedShow_${def.name}`);
                if (valueSetting !== undefined && showSetting !== undefined) {
                    const ref = msfssdk.FSComponent.createRef();
                    this.vSpeedOffScaleLabelRefs.push(ref);
                    labels.push(msfssdk.FSComponent.buildComponent(VSpeedOffScaleLabel, { ref: ref, value: valueSetting, label: def.label, isVisible: showSetting }));
                }
            }
            return labels;
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e;
            super.destroy();
            (_a = this.iasBoxRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            for (const ref of this.colorRangeRefs) {
                (_b = ref.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
            }
            (_c = this.manualRefSpeedBugRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
            for (const ref of this.vSpeedBugRefs) {
                (_d = ref.getOrDefault()) === null || _d === void 0 ? void 0 : _d.destroy();
            }
            for (const ref of this.vSpeedOffScaleLabelRefs) {
                (_e = ref.getOrDefault()) === null || _e === void 0 ? void 0 : _e.destroy();
            }
            this.options.destroy();
            this.isIasBelowScale.destroy();
            this.isIasAboveScale.destroy();
            this.isIasOffScale.destroy();
            this.iasTapeValue.destroy();
            this.iasBoxValue.destroy();
            this.iasTrendParams.destroy();
            for (const subscribable of this.colorRangeSubscribables) {
                subscribable.destroy();
            }
        }
    }
    /**
     * An indicated airspeed display box for a next-generation (NXi, G3000, etc) Garmin airspeed tape.
     */
    class AirspeedIasDisplayBox extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.scrollerRefs = [];
        }
        /** @inheritdoc */
        render() {
            const onesScrollerRef = msfssdk.FSComponent.createRef();
            const tensScrollerRef = msfssdk.FSComponent.createRef();
            const hundredsScrollerRef = msfssdk.FSComponent.createRef();
            this.scrollerRefs.push(onesScrollerRef, tensScrollerRef, hundredsScrollerRef);
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box' },
                msfssdk.FSComponent.buildComponent("svg", { viewBox: "0 0 90 70", class: 'airspeed-ias-box-bg', preserveAspectRatio: 'none' },
                    msfssdk.FSComponent.buildComponent("path", { "vector-effect": 'non-scaling-stroke', d: 'M 86 35 l -11 -6 l 0 -26 c 0 -1 -1 -2 -2 -2 l -19 0 c -1 0 -2 1 -2 2 l 0 11 l -44 0 c -1 0 -2 1 -2 2 l 0 38 c 0 1 1 2 2 2 l 44 0 l 0 11 c 0 1 1 2 2 2 l 19 0 c 1 0 2 -1 2 -2 l 0 -26 l 11 -6 z' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-scrollers', style: 'position: absolute; left: 6.7%; top: 1.5%; width: 76.6%; height: 97%;' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-container airspeed-ias-box-hundreds' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: hundredsScrollerRef, value: this.props.ias, base: 10, factor: 100, scrollThreshold: 99, renderDigit: (digit) => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString() })),
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-container airspeed-ias-box-tens' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: tensScrollerRef, value: this.props.ias, base: 10, factor: 10, scrollThreshold: 9 })),
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-container airspeed-ias-box-ones' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: onesScrollerRef, value: this.props.ias, base: 10, factor: 1 }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-ias-box-scroller-mask' })))));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            for (const ref of this.scrollerRefs) {
                (_a = ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            }
        }
    }
    /**
     * A color range for an airspeed indicator tape.
     */
    class AirspeedColorRange extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                top: '0%',
                height: '0%'
            });
            this.minimum = msfssdk.SubscribableUtils.toSubscribable(this.props.minimum, true);
            this.maximum = msfssdk.SubscribableUtils.toSubscribable(this.props.maximum, true);
        }
        /** @inheritdoc */
        onAfterRender() {
            const handler = this.updatePosition.bind(this);
            this.minimumSub = this.minimum.sub(handler);
            this.maximumSub = this.maximum.sub(handler);
            this.updateEventSub = this.props.updateEvent.on(handler);
            this.updatePosition();
        }
        /**
         * Updates this color range's start and end positions on its parent airspeed tape.
         */
        updatePosition() {
            const minPos = msfssdk.MathUtils.clamp(this.props.getPosition(this.minimum.get(), true), 0, 1);
            const maxPos = msfssdk.MathUtils.clamp(this.props.getPosition(this.maximum.get(), true), 0, 1);
            if (minPos <= maxPos) {
                this.style.set('display', 'none');
            }
            else {
                this.style.set('display', '');
                this.style.set('top', `${maxPos * 100}%`);
                this.style.set('height', `${(minPos - maxPos) * 100}%`);
            }
        }
        /** @inheritdoc */
        render() {
            const widthClass = this.props.width === exports.AirspeedIndicatorColorRangeWidth.Full ? 'airspeed-tape-color-range-full' : 'airspeed-tape-color-range-half';
            const colorClass = AirspeedColorRange.COLOR_CLASS[this.props.color];
            return (msfssdk.FSComponent.buildComponent("div", { class: `airspeed-tape-color-range ${widthClass} ${colorClass}`, style: this.style }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.minimumSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.maximumSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.updateEventSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    AirspeedColorRange.COLOR_CLASS = {
        [exports.AirspeedIndicatorColorRangeColor.Red]: 'airspeed-tape-color-range-red',
        [exports.AirspeedIndicatorColorRangeColor.Yellow]: 'airspeed-tape-color-range-yellow',
        [exports.AirspeedIndicatorColorRangeColor.White]: 'airspeed-tape-color-range-white',
        [exports.AirspeedIndicatorColorRangeColor.Green]: 'airspeed-tape-color-range-green',
        [exports.AirspeedIndicatorColorRangeColor.BarberPole]: 'airspeed-tape-color-range-barber-pole',
    };
    /**
     * A speed bug for a next-generation (NXi, G3000, etc) Garmin airspeed tape.
     */
    class SpeedBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                top: '50%',
                transform: 'translate3d(0, -50%, 0)'
            });
            this.position = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            const updateHandler = this.updatePosition.bind(this);
            this.speedKnotsRounded = this.props.speedKnots.map(msfssdk.SubscribableMapFunctions.withPrecision(1));
            this.speedKnotsRounded.pause();
            this.speedKnotsRounded.sub(updateHandler);
            this.updateEventSub = this.props.updateEvent.on(updateHandler, true);
            this.position.sub(translate => {
                this.style.set('top', `${translate}%`);
            });
            this.isVisibleSub = this.props.isVisible.sub(isVisible => {
                if (isVisible) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.speedKnotsRounded.resume();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.resume();
                    this.style.set('display', '');
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.speedKnotsRounded.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.pause();
                    this.style.set('display', 'none');
                }
            }, true);
        }
        /**
         * Updates this speed bug's position on its parent airspeed tape window.
         */
        updatePosition() {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pos = this.props.getPosition(this.speedKnotsRounded.get());
            this.position.set(msfssdk.MathUtils.round(pos * 100, 0.1));
        }
        /** @inheritdoc */
        render() {
            var _a;
            let cssClass;
            if (typeof this.props.class === 'object') {
                cssClass = msfssdk.SetSubject.create(['airspeed-speed-bug']);
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(cssClass, this.props.class, ['airspeed-speed-bug']);
            }
            else {
                cssClass = `airspeed-speed-bug ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
            }
            return (msfssdk.FSComponent.buildComponent("div", { class: cssClass, style: this.style }, this.props.children));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.speedKnotsRounded) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.isVisibleSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.updateEventSub) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }
    /**
     * A reference speed bug.
     */
    class ReferenceSpeedBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.bugRef = msfssdk.FSComponent.createRef();
            this.state = msfssdk.CombinedSubject.create(this.props.referenceIas, this.props.referenceMach, this.props.machToKias, this.props.isAirspeedHoldActive);
            this.isVisible = msfssdk.Subject.create(false);
            this.speedKnots = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.state.sub(this.update.bind(this), true);
        }
        /**
         * Updates this speed bug.
         * @param state The current reference airspeed state.
         */
        update(state) {
            const [ias, mach, machToKias, isAirspeedHoldActive] = state;
            if (isAirspeedHoldActive && (ias !== null || mach !== null)) {
                if (ias !== null) {
                    this.speedKnots.set(ias);
                }
                else {
                    this.speedKnots.set(mach * machToKias);
                }
                this.isVisible.set(true);
            }
            else {
                this.isVisible.set(false);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(SpeedBug, { ref: this.bugRef, speedKnots: this.speedKnots, isVisible: this.isVisible, updateEvent: this.props.updateEvent, getPosition: (iasKnots) => msfssdk.MathUtils.clamp(this.props.getPosition(iasKnots, true), 0, 1), class: 'airspeed-refspeed-bug' }, this.renderContent()));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.bugRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            this.state.destroy();
        }
    }
    /**
     * A manual reference speed bug.
     */
    class ManualReferenceSpeedBug extends ReferenceSpeedBug {
        /** @inheritdoc */
        renderContent() {
            return (msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 100 100', preserveAspectRatio: 'none', class: 'airspeed-refspeed-bug-manual-icon' },
                msfssdk.FSComponent.buildComponent("path", { d: "M 5 5 h 90 v 90 h -90 v -30 L 55 50 L 5 30 Z", "vector-effect": 'non-scaling-stroke' })));
        }
    }
    /**
     * An icon for a reference V-speed bug.
     */
    class VSpeedBugIcon extends msfssdk.DisplayComponent {
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-bug-icon' },
                msfssdk.FSComponent.buildComponent("svg", { class: 'airspeed-vspeed-bug-icon-arrow', viewBox: '0 0 100 100', preserveAspectRatio: 'none' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 0 50 L 100 0 L 100 100 Z', "vector-effect": 'non-scaling-stroke' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-bug-icon-label' }, this.props.children)));
        }
    }
    /**
     * A reference V-speed bug.
     */
    class VSpeedBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.bugRef = msfssdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(SpeedBug, { ref: this.bugRef, speedKnots: this.props.value, isVisible: this.props.isVisible, updateEvent: this.props.updateEvent, getPosition: (iasKnots) => msfssdk.MathUtils.clamp(this.props.getPosition(iasKnots, false), -0.5, 1.5), class: 'airspeed-vspeed-bug' },
                msfssdk.FSComponent.buildComponent(VSpeedBugIcon, null, this.props.label)));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.bugRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A reference V-speed label displayed when the airspeed tape is off-scale.
     */
    class VSpeedOffScaleLabel extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                order: '0'
            });
            this.valueText = this.props.value.map(msfssdk.NumberFormatter.create({ precision: 1 }));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.isVisibleSub = this.props.isVisible.sub(isVisible => {
                this.style.set('display', isVisible ? '' : 'none');
            }, true);
            this.valueSub = this.props.value.sub(value => {
                this.style.set('order', value.toFixed(0));
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-offscale-label', style: this.style },
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-vspeed-offscale-label-value' }, this.valueText),
                msfssdk.FSComponent.buildComponent(VSpeedBugIcon, null, this.props.label)));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            this.valueText.destroy();
            (_a = this.isVisibleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.valueSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    /**
     * A display for an airspeed reference value.
     */
    class AirspeedReferenceDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.iasStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.machStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.referenceIas = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.KNOT.createNumber(0));
            this.referenceMach = msfssdk.Subject.create(0);
            this.state = msfssdk.CombinedSubject.create(this.props.referenceIas, this.props.referenceMach, this.props.isAirspeedHoldActive);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.state.sub(this.update.bind(this), true);
        }
        /**
         * Updates this display.
         * @param state The current reference airspeed state.
         */
        update(state) {
            const [ias, mach, isAirspeedHoldActive] = state;
            if (isAirspeedHoldActive && (ias !== null || mach !== null)) {
                if (ias !== null) {
                    this.iasStyle.set('display', '');
                    this.machStyle.set('display', 'none');
                    this.referenceIas.set(Math.round(ias));
                }
                else {
                    this.machStyle.set('display', '');
                    this.iasStyle.set('display', 'none');
                    this.referenceMach.set(msfssdk.MathUtils.round(mach, 0.001));
                }
                this.rootStyle.set('display', '');
                this.props.isVisible.set(true);
            }
            else {
                this.rootStyle.set('display', 'none');
                this.props.isVisible.set(false);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-refspeed-container', style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("svg", { class: 'airspeed-refspeed-icon', viewBox: '0 0 100 100', preserveAspectRatio: 'none' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 5 5 h 90 v 90 h -90 v -30 L 55 50 L 5 30 Z', "vector-effect": 'non-scaling-stroke' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-refspeed-text' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-refspeed-ias', style: this.iasStyle },
                        msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.referenceIas, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1 }) })),
                    msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-refspeed-mach', style: this.machStyle },
                        "M ",
                        this.referenceMach.map(msfssdk.NumberFormatter.create({ pad: 0, precision: 0.001 }))))));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.state.destroy();
        }
    }
    /**
     * A next-generation (NXi, G3000, etc) Garmin airspeed alert annunciation.
     */
    class AirspeedProtectionAnnunciation extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.text = msfssdk.Subject.create('');
            this.protectionState = msfssdk.CombinedSubject.create(this.props.isOverspeedProtectionActive, this.props.isUnderspeedProtectionActive);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.protectionState.sub(([isOverspeedActive, isUnderspeedActive]) => {
                if (isUnderspeedActive) {
                    this.text.set('MINSPD');
                    this.rootStyle.set('display', '');
                }
                else if (isOverspeedActive) {
                    this.text.set('MAXSPD');
                    this.rootStyle.set('display', '');
                }
                else {
                    this.rootStyle.set('display', 'none');
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-protection-container', style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-protection-text' }, this.text)));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.protectionState.destroy();
        }
    }
    /**
     * A true airspeed display for an airspeed indicator.
     */
    class AirspeedTasDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: ''
            });
            this.tas = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.KNOT.createNumber(0));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.tasSub = this.props.tasKnots.sub(this.update.bind(this), true);
            this.props.isVisible.set(true);
        }
        /**
         * Updates this display.
         * @param tasKnots The current true airspeed, in knots.
         */
        update(tasKnots) {
            this.tas.set(msfssdk.MathUtils.round(tasKnots, 1));
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-bottom-speed-display airspeed-tas-display', style: this.style },
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-tas-display-title' }, "TAS"),
                msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.tas, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1 }), class: 'airspeed-tas-display-value' })));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.tasSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A mach display for an airspeed indicator.
     */
    class AirspeedMachDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.roundedMach = msfssdk.Subject.create(0);
            this.state = msfssdk.CombinedSubject.create(this.props.mach, msfssdk.SubscribableUtils.toSubscribable(this.props.threshold, true));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.state.sub(this.update.bind(this), true);
        }
        /**
         * Updates this display.
         * @param state The state of this display.
         */
        update(state) {
            const [mach, threshold] = state;
            if (mach < threshold) {
                this.style.set('display', 'none');
                this.props.isVisible.set(false);
            }
            else {
                this.roundedMach.set(msfssdk.MathUtils.round(mach, 0.001));
                this.style.set('display', '');
                this.props.isVisible.set(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-bottom-speed-display airspeed-mach-display', style: this.style },
                msfssdk.FSComponent.buildComponent("div", { class: 'airspeed-mach-display-value' },
                    "M ",
                    this.roundedMach.map(msfssdk.NumberFormatter.create({ precision: 0.001, pad: 0 })))));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.state.destroy();
        }
    }

    /**
     * Altitude alert states.
     */
    exports.AltitudeAlertState = void 0;
    (function (AltitudeAlertState) {
        /** Disabled. */
        AltitudeAlertState["Disabled"] = "Disabled";
        /** Inhibited. */
        AltitudeAlertState["Inhibited"] = "Inhibited";
        /** Armed and outside of 1000 feet of selected altitude prior to capture. */
        AltitudeAlertState["Armed"] = "Armed";
        /** Within 1000 feet of selected altitude prior to capture. */
        AltitudeAlertState["Within1000"] = "Within1000";
        /** Within 200 feet of selected altitude prior to capture. */
        AltitudeAlertState["Within200"] = "Within200";
        /** Captured the selected altitude. */
        AltitudeAlertState["Captured"] = "Captured";
        /** Deviation from captured altitude is greater than 200 feet. */
        AltitudeAlertState["Deviation"] = "Deviation";
    })(exports.AltitudeAlertState || (exports.AltitudeAlertState = {}));
    /**
     * Maintains an altitude alert state based on the relationship between indicated altitude and selected altitude.
     */
    class AltitudeAlerter {
        /**
         * Creates an instance of AltitudeAlerter.
         * @param index The index of this alerter.
         * @param bus The event bus.
         * @param adcIndex The index of the ADC from which this alerter sources indicated altitude data.
         */
        constructor(index, bus, adcIndex) {
            this.index = index;
            this.bus = bus;
            this._state = msfssdk.Subject.create(exports.AltitudeAlertState.Disabled);
            this.state = this._state;
            this.stateChangeQueue = [];
            this.isChangingState = false;
            this.indicatedAlt = msfssdk.ConsumerSubject.create(null, 0);
            this.selectedAltSource = msfssdk.ConsumerSubject.create(null, 0);
            this.selectedAltIsInit = msfssdk.ConsumerSubject.create(null, false);
            this.selectedAlt = msfssdk.MappedSubject.create(([selectedAlt, isInit]) => {
                return isInit ? selectedAlt : null;
            }, this.selectedAltSource, this.selectedAltIsInit);
            this.isOnGround = msfssdk.ConsumerSubject.create(null, false);
            this.gpApproachMode = msfssdk.ConsumerSubject.create(null, msfssdk.ApproachGuidanceMode.None);
            this.vnavPathMode = msfssdk.ConsumerSubject.create(null, msfssdk.VNavPathMode.None);
            this.isGsGpActive = msfssdk.Subject.create(false);
            this.isAlertInhibited = msfssdk.MappedSubject.create(([isOnGround, isGsGpActive, selectedAltIsInit]) => {
                return isOnGround || isGsGpActive || !selectedAltIsInit;
            }, this.isOnGround, this.isGsGpActive, this.selectedAltIsInit);
            this.targetAltitude = NaN;
            this.inhibitTimer = new msfssdk.DebounceTimer();
            this.isInit = false;
            this.isAlive = true;
            this.adcIndex = msfssdk.SubscribableUtils.toSubscribable(adcIndex, true);
        }
        /**
         * Initializes this alerter. Once initialized, this alerter will continuously update its alert state until destroyed.
         * @throws Error if this alerter is dead.
         */
        init() {
            if (!this.isAlive) {
                throw new Error('AltitudeAlerter: cannot initialize a dead alerter');
            }
            if (this.isInit) {
                return;
            }
            const sub = this.bus.getSubscriber();
            this.adcIndexSub = this.adcIndex.sub(index => {
                this.indicatedAlt.setConsumer(sub.on(`adc_indicated_alt_${index}`));
            }, true);
            this.selectedAltSource.setConsumer(sub.on('ap_altitude_selected'));
            this.selectedAltIsInit.setConsumer(sub.on('alt_select_is_initialized'));
            this.isOnGround.setConsumer(sub.on('on_ground'));
            this.gpApproachMode.setConsumer(sub.on('gp_approach_mode'));
            this.vnavPathMode.setConsumer(sub.on('vnav_path_mode'));
            this.gpApproachMode.sub(mode => {
                switch (mode) {
                    case msfssdk.ApproachGuidanceMode.GSActive:
                    case msfssdk.ApproachGuidanceMode.GPActive:
                        this.isGsGpActive.set(true);
                        break;
                    default:
                        this.isGsGpActive.set(false);
                }
            }, true);
            this.disableSub = sub.on(`alt_alert_disable_${this.index}`).handle(() => {
                this.changeState(exports.AltitudeAlertState.Disabled);
            });
            this.selectedAltSub = this.selectedAlt.sub(selectedAlt => {
                if (selectedAlt !== null && selectedAlt !== this.targetAltitude) {
                    this.changeState(exports.AltitudeAlertState.Inhibited);
                    this.inhibitTimer.schedule(() => {
                        this.changeState(exports.AltitudeAlertState.Armed);
                    }, AltitudeAlerter.SELECTED_ALT_CHANGE_INHIBIT_DURATION);
                }
            }, false, true);
            this.isAlertInhibited.sub(isInhibited => {
                if (isInhibited) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.pause();
                    this.inhibitTimer.clear();
                    this.changeState(exports.AltitudeAlertState.Inhibited);
                }
                else {
                    this.changeState(exports.AltitudeAlertState.Disabled);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.resume(true);
                }
            }, true);
        }
        /**
         * Requests a change in the state of this alerter. If no state change is currently in progress, the request will be
         * processed immediately. If a state change is currently in progress, the request will be queued and processed after
         * all pending state change requests are processed if no state change other than the one currently in progress is
         * carried out.
         * @param state The alert state to which to change.
         */
        changeState(state) {
            if (this.isChangingState) {
                this.stateChangeQueue.push(state);
            }
            else {
                this.processStateChange(state);
            }
        }
        /**
         * Processes a state change request.
         * @param state The alert state to which to change.
         */
        processStateChange(state) {
            var _a;
            const currentState = this._state.get();
            if (currentState === state) {
                this.dequeueStateChange();
                return;
            }
            if (state !== exports.AltitudeAlertState.Inhibited && this.isAlertInhibited.get()) {
                this.dequeueStateChange();
                return;
            }
            this.isChangingState = true;
            if (state === exports.AltitudeAlertState.Armed) {
                this.targetAltitude = this.selectedAlt.get();
                // If attempting to arm, check if we can directly enter one of the less deviated states
                const delta = Math.abs(this.targetAltitude - this.indicatedAlt.get());
                if (delta < 150) {
                    state = exports.AltitudeAlertState.Captured;
                }
                else if (delta < 200) {
                    state = exports.AltitudeAlertState.Within200;
                }
                else if (delta < 1000) {
                    state = exports.AltitudeAlertState.Within1000;
                }
            }
            (_a = this.indicatedAltSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.indicatedAltSub = undefined;
            this.stateChangeQueue.length = 0;
            this._state.set(state);
            switch (state) {
                case exports.AltitudeAlertState.Armed:
                    this.indicatedAltSub = this.indicatedAlt.sub(indicatedAlt => {
                        const delta = Math.abs(this.targetAltitude - indicatedAlt);
                        if (delta < 200) {
                            this.changeState(exports.AltitudeAlertState.Within200);
                        }
                        else if (delta < 1000) {
                            this.changeState(exports.AltitudeAlertState.Within1000);
                        }
                    }, false, true);
                    this.indicatedAltSub.resume(true);
                    break;
                case exports.AltitudeAlertState.Within1000:
                    this.indicatedAltSub = this.indicatedAlt.sub(indicatedAlt => {
                        const delta = Math.abs(this.targetAltitude - indicatedAlt);
                        if (delta < 200) {
                            this.changeState(exports.AltitudeAlertState.Within200);
                        }
                    }, false, true);
                    this.indicatedAltSub.resume(true);
                    break;
                case exports.AltitudeAlertState.Within200:
                    this.indicatedAltSub = this.indicatedAlt.sub(indicatedAlt => {
                        const delta = Math.abs(this.targetAltitude - indicatedAlt);
                        if (delta < 150) {
                            this.changeState(exports.AltitudeAlertState.Captured);
                        }
                        else if (delta > 250) {
                            this.changeState(exports.AltitudeAlertState.Deviation);
                        }
                    }, false, true);
                    this.indicatedAltSub.resume(true);
                    break;
                case exports.AltitudeAlertState.Captured:
                    this.indicatedAltSub = this.indicatedAlt.sub(indicatedAlt => {
                        const delta = Math.abs(this.targetAltitude - indicatedAlt);
                        if (delta > 200) {
                            this.changeState(exports.AltitudeAlertState.Deviation);
                        }
                    }, false, true);
                    this.indicatedAltSub.resume(true);
                    break;
                case exports.AltitudeAlertState.Deviation:
                    this.indicatedAltSub = this.indicatedAlt.sub(indicatedAlt => {
                        const delta = Math.abs(this.targetAltitude - indicatedAlt);
                        if (delta < 150) {
                            this.changeState(exports.AltitudeAlertState.Captured);
                        }
                    }, false, true);
                    this.indicatedAltSub.resume(true);
                    break;
            }
            this.isChangingState = false;
            this.dequeueStateChange();
        }
        /**
         * Processes the next state change request in the queue, if one exists.
         */
        dequeueStateChange() {
            const state = this.stateChangeQueue.shift();
            if (state !== undefined) {
                this.processStateChange(state);
            }
        }
        /**
         * Destroys this alerter. Once destroyed, this alerter will no longer update its alert state.
         */
        destroy() {
            var _a, _b, _c;
            this.isAlive = false;
            this.inhibitTimer.clear();
            this.indicatedAlt.destroy();
            this.selectedAltSource.destroy();
            this.selectedAltIsInit.destroy();
            this.isOnGround.destroy();
            this.gpApproachMode.destroy();
            this.vnavPathMode.destroy();
            (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.apLockSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.disableSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    AltitudeAlerter.SELECTED_ALT_CHANGE_INHIBIT_DURATION = 3000; // milliseconds

    /**
     * Minimums alert states.
     */
    exports.MinimumsAlertState = void 0;
    (function (MinimumsAlertState) {
        /** Inhibited. */
        MinimumsAlertState["Inhibited"] = "Inhibited";
        /** Armed. */
        MinimumsAlertState["Armed"] = "Armed";
        /** Greater than 100 feet above minimums. */
        MinimumsAlertState["Above100"] = "Above100";
        /** Less than or equal to 100 feet above minimums. */
        MinimumsAlertState["Within100"] = "Within100";
        /** At or below minimums. */
        MinimumsAlertState["AtOrBelow"] = "AtOrBelow";
    })(exports.MinimumsAlertState || (exports.MinimumsAlertState = {}));
    /**
     * Maintains a minimums alert state based on the relationship between indicated/radar altitude and the appropriate
     * minimums setting.
     */
    class MinimumsAlerter {
        /**
         * Creates an instance of AltitudeAlerter.
         * @param bus The event bus.
         * @param adcIndex The index of the ADC from which this alerter sources indicated altitude data.
         * @param supportRadarMins Whether to support radar minimums.
         */
        constructor(bus, adcIndex, supportRadarMins) {
            this.bus = bus;
            this.supportRadarMins = supportRadarMins;
            this._minimumsMode = msfssdk.ConsumerSubject.create(null, msfssdk.MinimumsMode.OFF);
            this.minimumsMode = this._minimumsMode;
            this._state = msfssdk.Subject.create(exports.MinimumsAlertState.Inhibited);
            this.state = this._state;
            this.stateChangeQueue = [];
            this.isChangingState = false;
            this.indicatedAlt = msfssdk.ConsumerSubject.create(null, 0);
            this.radarAlt = msfssdk.ConsumerSubject.create(null, 0);
            this.baroMinimumsSource = msfssdk.ConsumerSubject.create(null, 0);
            this.radarMinimumsSource = msfssdk.ConsumerSubject.create(null, 0);
            this.isAdcOperating = msfssdk.Subject.create(true);
            this.isRadarAltimeterOperating = msfssdk.Subject.create(true);
            this.minimumsDelta = msfssdk.Subject.create(null);
            this.isOnGround = msfssdk.ConsumerSubject.create(null, false);
            this.isAlertInhibited = msfssdk.MappedSubject.create(([minimumsDelta, isOnGround]) => {
                return isOnGround || minimumsDelta === null;
            }, this._minimumsMode, this.isOnGround);
            this.isInit = false;
            this.isAlive = true;
            this.adcIndex = msfssdk.SubscribableUtils.toSubscribable(adcIndex, true);
        }
        /**
         * Initializes this alerter. Once initialized, this alerter will continuously update its alert state until destroyed.
         * @throws Error if this alerter is dead.
         */
        init() {
            if (!this.isAlive) {
                throw new Error('MinimumsAlerter: cannot initialize a dead alerter');
            }
            if (this.isInit) {
                return;
            }
            const sub = this.bus.getSubscriber();
            this.adcIndexSub = this.adcIndex.sub(index => {
                var _a;
                (_a = this.adcSystemStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
                this.adcSystemStateSub = sub.on(`adc_state_${index}`).handle(state => {
                    if (state.current === msfssdk.AvionicsSystemState.On) {
                        this.isAdcOperating.set(true);
                    }
                    else {
                        this.isAdcOperating.set(false);
                    }
                });
                this.indicatedAlt.setConsumer(sub.on(`adc_indicated_alt_${index}`));
            }, true);
            if (this.supportRadarMins) {
                this.radarAlt.setConsumer(sub.on('radaralt_radio_alt_1'));
                this.radarAltSystemStateSub = sub.on('radaralt_state_1').handle(state => {
                    if (state.current === msfssdk.AvionicsSystemState.On) {
                        this.isRadarAltimeterOperating.set(true);
                    }
                    else {
                        this.isRadarAltimeterOperating.set(false);
                    }
                });
            }
            this._minimumsMode.setConsumer(sub.on('minimums_mode'));
            this.baroMinimumsSource.setConsumer(sub.on('decision_altitude_feet'));
            this.radarMinimumsSource.setConsumer(sub.on('decision_height_feet'));
            const baroMinimumsState = msfssdk.CombinedSubject.create(this.indicatedAlt, this.baroMinimumsSource, this.isAdcOperating);
            const baroMinimumsSub = baroMinimumsState.sub(([indicatedAlt, baroMinimumsSource, isAdcOperating]) => {
                if (isAdcOperating) {
                    this.minimumsDelta.set(indicatedAlt - baroMinimumsSource);
                }
                else {
                    this.minimumsDelta.set(null);
                }
            }, false, true);
            const radarMinimumsState = msfssdk.CombinedSubject.create(this.radarAlt, this.radarMinimumsSource, this.isRadarAltimeterOperating);
            const radarMinimumsSub = radarMinimumsState.sub(([radarAlt, radarMinimumsSource, isRadarAltimeterOperating]) => {
                if (isRadarAltimeterOperating) {
                    this.minimumsDelta.set(radarAlt - radarMinimumsSource);
                }
                else {
                    this.minimumsDelta.set(null);
                }
            }, false, true);
            this._minimumsMode.sub(mode => {
                baroMinimumsSub.pause();
                radarMinimumsSub.pause();
                switch (mode) {
                    case msfssdk.MinimumsMode.BARO:
                        baroMinimumsSub.resume(true);
                        break;
                    case msfssdk.MinimumsMode.RA:
                        if (this.supportRadarMins) {
                            radarMinimumsSub.resume(true);
                            break;
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        this.minimumsDelta.set(null);
                }
            }, true);
            this.isOnGround.setConsumer(sub.on('on_ground'));
            this.isAlertInhibited.sub(isInhibited => {
                if (isInhibited) {
                    this.changeState(exports.MinimumsAlertState.Inhibited);
                }
                else {
                    this.changeState(exports.MinimumsAlertState.Armed);
                }
            }, true);
        }
        /**
         * Requests a change in the state of this alerter. If no state change is currently in progress, the request will be
         * processed immediately. If a state change is currently in progress, the request will be queued and processed after
         * all pending state change requests are processed if no state change other than the one currently in progress is
         * carried out.
         * @param state The alert state to which to change.
         */
        changeState(state) {
            if (this.isChangingState) {
                this.stateChangeQueue.push(state);
            }
            else {
                this.processStateChange(state);
            }
        }
        /**
         * Processes a state change request.
         * @param state The alert state to which to change.
         */
        processStateChange(state) {
            var _a;
            const currentState = this._state.get();
            if (currentState === state) {
                this.dequeueStateChange();
                return;
            }
            if (state !== exports.MinimumsAlertState.Inhibited && this.isAlertInhibited.get()) {
                this.dequeueStateChange();
                return;
            }
            this.isChangingState = true;
            (_a = this.minimumsDeltaSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.minimumsDeltaSub = undefined;
            this.stateChangeQueue.length = 0;
            this._state.set(state);
            switch (state) {
                case exports.MinimumsAlertState.Armed:
                    this.minimumsDeltaSub = this.minimumsDelta.sub(delta => {
                        if (delta !== null && delta > 150) {
                            this.changeState(exports.MinimumsAlertState.Above100);
                        }
                    }, true);
                    break;
                case exports.MinimumsAlertState.Above100:
                    this.minimumsDeltaSub = this.minimumsDelta.sub(delta => {
                        if (delta !== null && delta <= 100) {
                            this.changeState(exports.MinimumsAlertState.Within100);
                        }
                    }, true);
                    break;
                case exports.MinimumsAlertState.Within100:
                    this.minimumsDeltaSub = this.minimumsDelta.sub(delta => {
                        if (delta === null) {
                            return;
                        }
                        if (delta > 150) {
                            this.changeState(exports.MinimumsAlertState.Above100);
                        }
                        else if (delta <= 0) {
                            this.changeState(exports.MinimumsAlertState.AtOrBelow);
                        }
                    }, true);
                    break;
                case exports.MinimumsAlertState.AtOrBelow:
                    this.minimumsDeltaSub = this.minimumsDelta.sub(delta => {
                        if (delta !== null && delta > 50) {
                            this.changeState(exports.MinimumsAlertState.Within100);
                        }
                    }, true);
                    break;
            }
            this.isChangingState = false;
            this.dequeueStateChange();
        }
        /**
         * Processes the next state change request in the queue, if one exists.
         */
        dequeueStateChange() {
            const state = this.stateChangeQueue.shift();
            if (state !== undefined) {
                this.processStateChange(state);
            }
        }
        /**
         * Destroys this alerter. Once destroyed, this alerter will no longer update its alert state.
         */
        destroy() {
            var _a, _b, _c;
            this.isAlive = false;
            this.indicatedAlt.destroy();
            this.radarAlt.destroy();
            this._minimumsMode.destroy();
            this.baroMinimumsSource.destroy();
            this.radarMinimumsSource.destroy();
            this.isOnGround.destroy();
            (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.adcSystemStateSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.radarAltSystemStateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }

    /**
     * A next-generation (NXi, G3000, etc) Garmin PFD altimeter.
     */
    class Altimeter extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.tapeRef = msfssdk.FSComponent.createRef();
            this.selectedAltitudeRef = msfssdk.FSComponent.createRef();
            this.baroSettingRef = msfssdk.FSComponent.createRef();
            this.rootCssClass = msfssdk.SetSubject.create(['altimeter']);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.rootCssClass.add('altimeter-top-visible');
            this.rootCssClass.add('altimeter-bottom-visible');
            this.minimumsAlertSub = this.props.minimumsAlertState.sub(state => {
                this.rootCssClass.delete('minimums-alert-within100');
                this.rootCssClass.delete('minimums-alert-atorbelow');
                switch (state) {
                    case exports.MinimumsAlertState.Within100:
                        this.rootCssClass.add('minimums-alert-within100');
                        break;
                    case exports.MinimumsAlertState.AtOrBelow:
                        this.rootCssClass.add('minimums-alert-atorbelow');
                        break;
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass },
                msfssdk.FSComponent.buildComponent(AltimeterTape, Object.assign({ ref: this.tapeRef, dataProvider: this.props.dataProvider }, this.props.tapeScaleOptions, this.props.trendVectorOptions, { showMetric: this.props.settingManager.getSetting('altMetric') })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-top-container' },
                    msfssdk.FSComponent.buildComponent(SelectedAltitudeDisplay, { show: msfssdk.Subject.create(true), selectedAlt: this.props.dataProvider.selectedAlt, altitudeAlertState: this.props.altitudeAlertState })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-bottom-container' },
                    msfssdk.FSComponent.buildComponent(BaroSettingDisplay, { show: msfssdk.Subject.create(true), baroSetting: this.props.dataProvider.baroSetting, isStdActive: this.props.dataProvider.baroIsStdActive, baroPreselect: this.props.supportBaroPreselect ? this.props.dataProvider.baroPreselect : undefined, isMetric: this.props.settingManager.getSetting('altimeterBaroMetric') }))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.tapeRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.selectedAltitudeRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.baroSettingRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.minimumsAlertSub) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }
    /**
     * A next-generation (NXi, G3000, etc) Garmin altimeter tape.
     */
    class AltimeterTape extends msfssdk.DisplayComponent {
        /** @inheritdoc */
        constructor(props) {
            super(props);
            this.indicatedAltBoxRef = msfssdk.FSComponent.createRef();
            this.minorTickContainerRef = msfssdk.FSComponent.createRef();
            this.majorTickContainerRef = msfssdk.FSComponent.createRef();
            this.labelContainerRef = msfssdk.FSComponent.createRef();
            this.selectedAltBugRef = msfssdk.FSComponent.createRef();
            this.minimumsBugRef = msfssdk.FSComponent.createRef();
            this.rootCssClass = msfssdk.SetSubject.create(['altimeter-tape-container']);
            this.labelAltitudes = [];
            this.tapeStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '50%',
                width: '100%',
                height: '100%',
                transform: 'translate3d(0, 0, 0)'
            });
            this.tapeClipStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '0%',
                width: '100%',
                height: '100%',
                overflow: 'hidden'
            });
            this.tapeOverflowTopStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0%',
                bottom: '100%',
                width: '100%',
                height: '50%'
            });
            this.trendVectorStyle = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                bottom: '50%',
                height: '0%',
                transform: 'rotateX(0deg)',
                'transform-origin': '50% 100%'
            });
            this.vSpeedOffScaleContainerStyle = msfssdk.ObjectSubject.create({
                display: 'flex',
                'flex-flow': 'column-reverse nowrap',
                position: 'absolute',
                bottom: '0%',
                overflow: 'hidden'
            });
            this.currentLength = msfssdk.Subject.create(0);
            this.currentMinimum = 0;
            this.currentTranslate = msfssdk.Subject.create(0);
            this.minimum = msfssdk.SubscribableUtils.toSubscribable(this.props.minimum, true);
            this.maximum = msfssdk.SubscribableUtils.toSubscribable(this.props.maximum, true);
            this.window = msfssdk.SubscribableUtils.toSubscribable(this.props.window, true);
            this.majorTickInterval = msfssdk.SubscribableUtils.toSubscribable(this.props.majorTickInterval, true);
            this.minorTickFactor = msfssdk.SubscribableUtils.toSubscribable(this.props.minorTickFactor, true);
            this.options = msfssdk.CombinedSubject.create(this.minimum, this.maximum, this.window, this.majorTickInterval, this.minorTickFactor);
            this.isIndicatedAltBelowScale = msfssdk.MappedSubject.create(([indicatedAlt, minimum]) => {
                return indicatedAlt < minimum;
            }, this.props.dataProvider.indicatedAlt, this.minimum);
            this.isIndicatedAltAboveScale = msfssdk.MappedSubject.create(([indicatedAlt, maximum]) => {
                return indicatedAlt > maximum;
            }, this.props.dataProvider.indicatedAlt, this.maximum);
            this.isIndicatedAltOffScale = msfssdk.MappedSubject.create(([isIndicatedAltBelowScale, isIndicatedAltAboveScale]) => {
                return isIndicatedAltBelowScale || isIndicatedAltAboveScale;
            }, this.isIndicatedAltBelowScale, this.isIndicatedAltAboveScale);
            this.indicatedAltTapeValue = msfssdk.MappedSubject.create(([indicatedAlt, minimum, maximum]) => {
                return msfssdk.MathUtils.clamp(indicatedAlt, minimum, maximum);
            }, this.props.dataProvider.indicatedAlt, this.minimum, this.maximum);
            this.indicatedAltBoxValue = msfssdk.MappedSubject.create(([indicatedAlt, isIndicatedAltOffScale]) => {
                return isIndicatedAltOffScale ? NaN : indicatedAlt;
            }, this.props.dataProvider.indicatedAlt, this.isIndicatedAltOffScale);
            this.metricIndicatedAltValue = msfssdk.MappedSubject.create(([indicatedAltFeet, minimum, maximum]) => {
                return msfssdk.UnitType.FOOT.convertTo(msfssdk.MathUtils.clamp(indicatedAltFeet, minimum, maximum), msfssdk.UnitType.METER);
            }, this.props.dataProvider.indicatedAlt, this.minimum, this.maximum);
            this.trendThreshold = msfssdk.SubscribableUtils.toSubscribable(this.props.trendThreshold, true);
            this.showTrendVector = msfssdk.MappedSubject.create(([indicatedAlt, minimum, maximum, threshold, altitudeTrend]) => {
                return indicatedAlt >= minimum && indicatedAlt < maximum && Math.abs(altitudeTrend) >= threshold;
            }, this.props.dataProvider.indicatedAlt, this.minimum, this.maximum, this.trendThreshold, this.props.dataProvider.altitudeTrend);
            this.altitudeTrendParams = msfssdk.CombinedSubject.create(this.props.dataProvider.altitudeTrend, this.window);
            this.trendVectorHeight = msfssdk.Subject.create(0);
            this.trendVectorScale = msfssdk.Subject.create(1);
            this.selectedAltMeters = this.props.dataProvider.selectedAlt.map(selectedAltFeet => {
                return selectedAltFeet === null ? null : msfssdk.UnitType.FOOT.convertTo(selectedAltFeet, msfssdk.UnitType.METER);
            });
            this.updateTapeEvent = new msfssdk.SubEvent();
            this.updateTapeWindowEvent = new msfssdk.SubEvent();
            this.indicatedAltTapeValue.pause();
            this.indicatedAltBoxValue.pause();
            this.showTrendVector.pause();
            this.altitudeTrendParams.pause();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.indicatedAltTapeValue.resume();
            this.indicatedAltBoxValue.resume();
            this.indicatedAltTapeValue.sub(this.updateTape.bind(this));
            this.altitudeTrendParams.sub(this.updateTrendVector.bind(this));
            this.showTrendVector.resume();
            this.showTrendVector.sub(show => {
                if (show) {
                    this.trendVectorStyle.set('display', '');
                    this.altitudeTrendParams.resume();
                }
                else {
                    this.altitudeTrendParams.pause();
                    this.trendVectorStyle.set('display', 'none');
                }
            }, true);
            this.trendVectorHeight.sub(height => { this.trendVectorStyle.set('height', `${height}%`); });
            this.trendVectorScale.sub(scale => { this.trendVectorStyle.set('transform', `scale(${scale}) rotateX(0deg)`); });
            this.currentTranslate.sub(translate => {
                this.tapeStyle.set('transform', `translate3d(0, ${translate * 100}%, 0)`);
            });
            this.options.sub(this.rebuildTape.bind(this), true);
            this.isIndicatedAltBelowScale.sub(isIasBelowScale => {
                this.vSpeedOffScaleContainerStyle.set('display', isIasBelowScale ? 'flex' : 'none');
            }, true);
        }
        /**
         * Calculates the absolute vertical position on the tape at which a particular altitude is located, with `0` at the
         * top of the tape and `1` at the bottom.
         * @param indicatedAlt An altitude, in feet.
         * @param clamp Whether the altitude should be clamped to the range defined by this tape's minimum and maximum
         * representable altitudes. Defaults to `false`.
         * @returns The absolute vertical position on the tape at which the specified altitude is located, with `0` at the
         * top of the tape and `1` at the bottom.
         */
        calculateAbsoluteTapePosition(indicatedAlt, clamp = false) {
            if (clamp) {
                indicatedAlt = msfssdk.MathUtils.clamp(indicatedAlt, this.minimum.get(), this.maximum.get());
            }
            return 1 - (indicatedAlt - this.currentMinimum) / this.currentLength.get();
        }
        /**
         * Calculates the vertical position on the tape window at which a particular altitude is located, with `0` at the top
         * of the tape window and `1` at the bottom.
         * @param indicatedAlt An altitude, in knots.
         * @param clamp Whether the altitude should be clamped to the range defined by this tape's minimum and maximum
         * representable altitudes. Defaults to `false`.
         * @returns The vertical position on the tape window at which the specified altitude is located, with `0` at the top
         * of the tape window and `1` at the bottom.
         */
        calculateWindowTapePosition(indicatedAlt, clamp = false) {
            return (this.calculateAbsoluteTapePosition(indicatedAlt, clamp) - 1 + this.currentTranslate.get()) * this.currentLength.get() / this.window.get() + 0.5;
        }
        /**
         * Rebuilds this tape's ticks and labels.
         * @param options Scale options for this tape, as `[minimum, maximum, window, majorTickInterval, minorTickFactor]`.
         */
        rebuildTape(options) {
            const [minimum, maximum, window, majorTickInterval, minorTickFactor] = options;
            this.labelAltitudes.length = 0;
            this.minorTickContainerRef.instance.innerHTML = '';
            const majorTickCount = Math.ceil(window / majorTickInterval) * 2 + 1;
            const desiredRange = (majorTickCount - 1) * majorTickInterval;
            this.currentLength.set(desiredRange);
            const maxRange = maximum - minimum;
            const trueRange = Math.min(maxRange, desiredRange);
            const heightFactor = trueRange / desiredRange;
            const len = (majorTickCount - 1) * minorTickFactor;
            for (let i = 0; i <= len; i++) {
                const y = 100 - (i / len) * 100 / heightFactor;
                if (i % minorTickFactor === 0) {
                    // major tick
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("path", { d: `M 0 ${y} L 100 ${y}`, "vector-effect": 'non-scaling-stroke', class: 'altimeter-tape-tick altimeter-tape-tick-major' }, "."), this.majorTickContainerRef.instance);
                    const altitude = msfssdk.Subject.create(0);
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-label', style: `position: absolute; right: 0%; top: ${y}%; transform: translateY(-50%)` },
                        msfssdk.FSComponent.buildComponent("span", { class: 'altimeter-tape-label-hundreds' }, altitude.map(alt => Math.trunc(alt / 100).toString())),
                        msfssdk.FSComponent.buildComponent("span", { class: 'altimeter-tape-label-tens' }, altitude.map(alt => (Math.abs(alt) % 100).toFixed(0).padStart(2, '0')))), this.labelContainerRef.instance);
                    this.labelAltitudes.push(altitude);
                }
                else {
                    // minor tick
                    msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("path", { d: `M 0 ${y} L 100 ${y}`, "vector-effect": 'non-scaling-stroke', class: 'altimeter-tape-tick altimeter-tape-tick-minor' }, "."), this.minorTickContainerRef.instance);
                }
            }
            this.tapeStyle.set('height', `${100 * desiredRange / window}%`);
            this.tapeClipStyle.set('height', `${100 * heightFactor}%`);
            this.currentMinimum = minimum;
            this.updateTapeEvent.notify(this);
            this.updateTapeLabels();
            this.updateTapeOverflow();
            this.updateTape(this.indicatedAltTapeValue.get());
        }
        /**
         * Updates the tape based on the current indicated altitude.
         * @param indicatedAlt The current indicated altitude, in feet.
         */
        updateTape(indicatedAlt) {
            let tapePos = this.calculateAbsoluteTapePosition(indicatedAlt);
            if (tapePos <= 0.25 || tapePos >= 0.75) {
                const [minimum, maximum, window, majorTickInterval] = this.options.get();
                const desiredMinimum = Math.floor((indicatedAlt - window) / majorTickInterval) * majorTickInterval;
                const constrainedMinimum = Math.ceil((maximum - this.currentLength.get()) / majorTickInterval) * majorTickInterval;
                const minimumToSet = Math.max(minimum, Math.min(constrainedMinimum, desiredMinimum));
                if (this.currentMinimum !== minimumToSet) {
                    this.currentMinimum = minimumToSet;
                    this.updateTapeEvent.notify(this);
                    this.updateTapeLabels();
                    this.updateTapeOverflow();
                    tapePos = msfssdk.MathUtils.clamp(this.calculateAbsoluteTapePosition(indicatedAlt), 0, 1);
                }
            }
            this.currentTranslate.set(msfssdk.MathUtils.round(1 - tapePos, 1e-3));
            this.updateTapeWindowEvent.notify(this);
        }
        /**
         * Updates this tape's labels.
         */
        updateTapeLabels() {
            const interval = this.majorTickInterval.get();
            for (let i = 0; i < this.labelAltitudes.length; i++) {
                this.labelAltitudes[i].set(this.currentMinimum + interval * i);
            }
        }
        /**
         * Updates this tape's overflow regions.
         */
        updateTapeOverflow() {
            const maximumPos = this.calculateAbsoluteTapePosition(this.maximum.get());
            this.tapeOverflowTopStyle.set('bottom', `${Math.min(100, 100 - maximumPos * 100)}%`);
        }
        /**
         * Updates this tape's speed trend vector.
         * @param params Parameters for the speed trend vector, as `[iasTrend, window]`.
         */
        updateTrendVector(params) {
            const [iasTrend, window] = params;
            this.trendVectorHeight.set(msfssdk.MathUtils.clamp(msfssdk.MathUtils.round(Math.abs(iasTrend) / window * 100, 0.1), 0, 50));
            this.trendVectorScale.set(iasTrend < 0 ? -1 : 1);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass },
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-border-top' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-border-bottom' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-window', style: 'overflow: hidden;' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape', style: this.tapeStyle },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-clip', style: this.tapeClipStyle },
                            msfssdk.FSComponent.buildComponent("svg", { ref: this.minorTickContainerRef, class: 'altimeter-tape-tick-minor-container', viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: 'position: absolute; top: 0; height: 100%;' }),
                            msfssdk.FSComponent.buildComponent("svg", { ref: this.majorTickContainerRef, class: 'altimeter-tape-tick-major-container', viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: 'position: absolute; top: 0; height: 100%;' }),
                            msfssdk.FSComponent.buildComponent("div", { ref: this.labelContainerRef, class: 'altimeter-tape-label-container', style: 'position: absolute; top: 0; height: 100%; text-align: right;' })),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-overflow', style: this.tapeOverflowTopStyle }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-tape-overflow', style: 'position: absolute; left: 0; top: 100%; width: 100%; height: 50%;' }))),
                msfssdk.FSComponent.buildComponent(GroundLine, { indicatedAlt: this.props.dataProvider.indicatedAlt, radarAlt: this.props.dataProvider.radarAlt, show: this.isIndicatedAltOffScale.map(msfssdk.SubscribableMapFunctions.not()), updateEvent: this.updateTapeWindowEvent, getPosition: this.calculateWindowTapePosition.bind(this) }),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-trend', style: this.trendVectorStyle }),
                msfssdk.FSComponent.buildComponent(IndicatedAltDisplayBox, { ref: this.indicatedAltBoxRef, indicatedAlt: this.indicatedAltBoxValue }),
                msfssdk.FSComponent.buildComponent(MetricIndicatedAltDisplay, { show: this.props.showMetric, indicatedAltMeters: this.metricIndicatedAltValue }),
                msfssdk.FSComponent.buildComponent(MetricSelectedAltitudeDisplay, { show: this.props.showMetric, selectedAltMeters: this.selectedAltMeters }),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-bug-container', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden;' },
                    msfssdk.FSComponent.buildComponent(MinimumsBug, { ref: this.minimumsBugRef, minimums: this.props.dataProvider.minimums, updateEvent: this.updateTapeWindowEvent, getPosition: this.calculateWindowTapePosition.bind(this) }),
                    msfssdk.FSComponent.buildComponent(SelectedAltitudeBug, { ref: this.selectedAltBugRef, selectedAlt: this.props.dataProvider.selectedAlt, updateEvent: this.updateTapeWindowEvent, getPosition: this.calculateWindowTapePosition.bind(this) }))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.indicatedAltBoxRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.selectedAltBugRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
            this.options.destroy();
            this.isIndicatedAltBelowScale.destroy();
            this.isIndicatedAltAboveScale.destroy();
            this.isIndicatedAltOffScale.destroy();
            this.indicatedAltTapeValue.destroy();
            this.indicatedAltBoxValue.destroy();
            this.metricIndicatedAltValue.destroy();
            this.altitudeTrendParams.destroy();
            this.selectedAltMeters.destroy();
        }
    }
    /**
     * An indicated altitude display box for a next-generation (NXi, G3000, etc) Garmin altimeter tape.
     */
    class IndicatedAltDisplayBox extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.scrollerRefs = [];
            this.negativeSignStyles = Array.from({ length: 3 }, () => {
                return msfssdk.ComputedSubject.create(false, show => show ? '' : 'display: none;');
            });
            this.showNegativeSign = Array.from({ length: 3 }, (val, index) => {
                const topThreshold = index === 0 ? 0 : Math.pow(10, index + 1) - 20;
                const bottomThreshold = Math.pow(10, index + 2) - 20;
                return this.props.indicatedAlt.map(indicatedAlt => {
                    return indicatedAlt < -topThreshold && indicatedAlt >= -bottomThreshold;
                });
            });
        }
        /** @inheritdoc */
        onAfterRender() {
            this.showNegativeSign.forEach((show, index) => {
                show.pipe(this.negativeSignStyles[index]);
            });
        }
        /** @inheritdoc */
        render() {
            const tensScrollerRef = msfssdk.FSComponent.createRef();
            const hundredsScrollerRef = msfssdk.FSComponent.createRef();
            const thousandsScrollerRef = msfssdk.FSComponent.createRef();
            const tenThousandsScrollerRef = msfssdk.FSComponent.createRef();
            this.scrollerRefs.push(tensScrollerRef, tensScrollerRef, hundredsScrollerRef, tenThousandsScrollerRef);
            return (msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box' },
                msfssdk.FSComponent.buildComponent("svg", { viewBox: "0 0 105 70", class: 'altimeter-indicatedalt-box-bg', preserveAspectRatio: 'none' },
                    msfssdk.FSComponent.buildComponent("path", { "vector-effect": 'non-scaling-stroke', d: 'M 4 35 l 8 -6 l 0 -13 c 0 -1 1 -2 2 -2 l 54 0 l 0 -11 c 0 -1 1 -2 2 -2 l 30 0 c 1 0 2 1 2 2 l 0 64 c 0 1 -1 2 -2 2 l -30 0 c -1 0 -2 -1 -2 -2 l 0 -11 l -54 0 c -1 0 -2 -1 -2 -2 l 0 -13 z' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-scrollers', style: 'position: absolute; right: 2.8%; top: 1.5%; width: 85.8%; height: 97%;' },
                    msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-container altimeter-indicatedalt-box-ten-thousands' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: tenThousandsScrollerRef, value: this.props.indicatedAlt, base: 10, factor: 10000, scrollThreshold: 9980, renderDigit: (digit) => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString() }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-negative-sign', style: this.negativeSignStyles[2] }, "\u2013")),
                    msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-container altimeter-indicatedalt-box-thousands' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: thousandsScrollerRef, value: this.props.indicatedAlt, base: 10, factor: 1000, scrollThreshold: 980, renderDigit: (digit) => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString() }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-negative-sign', style: this.negativeSignStyles[1] }, "\u2013")),
                    msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-container altimeter-indicatedalt-box-hundreds' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: hundredsScrollerRef, value: this.props.indicatedAlt, base: 10, factor: 100, scrollThreshold: 80, renderDigit: (digit) => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString() }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-negative-sign', style: this.negativeSignStyles[0] }, "\u2013")),
                    msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-container altimeter-indicatedalt-box-tens' },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-digit-bg' }),
                        msfssdk.FSComponent.buildComponent(msfssdk.DigitScroller, { ref: tensScrollerRef, value: this.props.indicatedAlt, base: 5, factor: 20, renderDigit: (digit) => ((Math.abs(digit) % 5) * 20).toString().padStart(2, '0'), nanString: '' }),
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-indicatedalt-box-scroller-mask' })))));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            for (const show of this.showNegativeSign) {
                show.destroy();
            }
            for (const ref of this.scrollerRefs) {
                (_a = ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            }
        }
    }
    /**
     * A metric indicated altitude display for a next-generation (NXi, G3000, etc) Garmin altimeter tape.
     */
    class MetricIndicatedAltDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.indicatedAlt = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.METER.createNumber(0));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.indicatedAltPipe = this.props.indicatedAltMeters.pipe(this.indicatedAlt, alt => Math.round(alt), true);
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    this.style.set('display', '');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.indicatedAltPipe.resume(true);
                }
                else {
                    this.style.set('display', 'none');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.indicatedAltPipe.pause();
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-metric-indicatedalt', style: this.style },
                msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.indicatedAlt, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1 }), class: 'altimeter-metric-indicatedalt-value' })));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.indicatedAltPipe) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    /**
     * A metric selected altitude display for a next-generation (NXi, G3000, etc) Garmin altimeter tape.
     */
    class MetricSelectedAltitudeDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.textStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.defaultStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.selectedAlt = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.METER.createNumber(0));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.selectedAltSub = this.props.selectedAltMeters.sub(selectedAlt => {
                if (selectedAlt === null) {
                    this.textStyle.set('display', 'none');
                    this.defaultStyle.set('display', '');
                }
                else {
                    this.textStyle.set('display', '');
                    this.defaultStyle.set('display', 'none');
                    this.selectedAlt.set(Math.round(selectedAlt));
                }
            }, false, true);
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    this.rootStyle.set('display', '');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.resume(true);
                }
                else {
                    this.rootStyle.set('display', 'none');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.pause();
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-metric-selectedalt', style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-metric-selectedalt-text', style: this.textStyle },
                    msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.selectedAlt, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1 }), class: 'altimeter-metric-selectedalt-value' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-metric-selectedalt-default', style: this.defaultStyle }, "\u2013\u2013\u2013\u2013")));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.selectedAltSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    /**
     * A radar altimeter ground line for a next-generation (NXi, G3000, etc) Garmin altimeter tape. Depicts the
     * position of the ground on the altitude tape as determined by the radar altimeter.
     */
    class GroundLine extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                bottom: '0%',
                height: '0%',
                transform: 'rotateX(0deg)'
            });
            this.position = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            const updateHandler = this.updatePosition.bind(this);
            this.groundAltitudeRounded = msfssdk.MappedSubject.create(([indicatedAlt, radarAlt]) => {
                return radarAlt === null ? null : Math.round(indicatedAlt - radarAlt);
            }, this.props.indicatedAlt, this.props.radarAlt);
            this.groundAltitudeRounded.pause();
            this.groundAltitudeRounded.sub(updateHandler, true);
            this.updateEventSub = this.props.updateEvent.on(updateHandler, true);
            this.position.sub(translate => {
                this.style.set('height', `${100 - translate}%`);
            });
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.groundAltitudeRounded.resume();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.resume();
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.groundAltitudeRounded.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.pause();
                    this.style.set('display', 'none');
                }
            }, true);
        }
        /**
         * Updates this line's position on its parent altimeter tape window.
         */
        updatePosition() {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const groundAltitudeRounded = this.groundAltitudeRounded.get();
            const pos = groundAltitudeRounded === null ? NaN : this.props.getPosition(groundAltitudeRounded);
            if (isNaN(pos) || pos > 1) {
                this.style.set('display', 'none');
            }
            else {
                this.style.set('display', '');
                this.position.set(msfssdk.MathUtils.round(Math.max(pos, 0) * 100, 0.1));
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-ground-line', style: this.style }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.groundAltitudeRounded) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.showSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.updateEventSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    /**
     * An altitude bug for a next-generation (NXi, G3000, etc) Garmin altimeter tape.
     */
    class AltitudeBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                position: 'absolute',
                top: '50%',
                transform: 'translate3d(0, -50%, 0)'
            });
            this.position = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            const updateHandler = this.updatePosition.bind(this);
            this.altitudeFeetRounded = this.props.altitudeFeet.map(msfssdk.SubscribableMapFunctions.withPrecision(1));
            this.altitudeFeetRounded.pause();
            this.altitudeFeetRounded.sub(updateHandler);
            this.updateEventSub = this.props.updateEvent.on(updateHandler, true);
            this.position.sub(translate => {
                this.style.set('top', `${translate}%`);
            });
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.altitudeFeetRounded.resume();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.resume();
                    this.style.set('display', '');
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.altitudeFeetRounded.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.updateEventSub.pause();
                    this.style.set('display', 'none');
                }
            }, true);
        }
        /**
         * Updates this altitude bug's position on its parent altimeter tape window.
         */
        updatePosition() {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pos = this.props.getPosition(this.altitudeFeetRounded.get());
            this.position.set(msfssdk.MathUtils.round(pos * 100, 0.1));
        }
        /** @inheritdoc */
        render() {
            var _a;
            let cssClass;
            if (typeof this.props.class === 'object') {
                cssClass = msfssdk.SetSubject.create(['altimeter-altitude-bug']);
                this.cssClassSub = msfssdk.FSComponent.bindCssClassSet(cssClass, this.props.class, ['altimeter-altitude-bug']);
            }
            else {
                cssClass = `altimeter-altitude-bug ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
            }
            return (msfssdk.FSComponent.buildComponent("div", { class: cssClass, style: this.style }, this.props.children));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            (_a = this.altitudeFeetRounded) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.showSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.updateEventSub) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }
    /**
     * A selected altitude bug.
     */
    class SelectedAltitudeBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.bugRef = msfssdk.FSComponent.createRef();
            this.isVisible = msfssdk.Subject.create(false);
            this.selectedAltFeet = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.selectedAltSub = this.props.selectedAlt.sub(this.update.bind(this), true);
        }
        /**
         * Updates this bug.
         * @param selectedAlt The current selected altitude, in feet, or `null` if no such value exists.
         */
        update(selectedAlt) {
            if (selectedAlt === null) {
                this.isVisible.set(false);
            }
            else {
                this.selectedAltFeet.set(selectedAlt);
                this.isVisible.set(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(AltitudeBug, { ref: this.bugRef, altitudeFeet: this.selectedAltFeet, show: this.isVisible, updateEvent: this.props.updateEvent, getPosition: (indicatedAlt) => msfssdk.MathUtils.clamp(this.props.getPosition(indicatedAlt, true), 0, 1), class: 'altimeter-selectedalt-bug' },
                msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 100 100', preserveAspectRatio: 'none', class: 'altimeter-selectedalt-bug-icon' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 95 5 h -90 v 90 h 90 v -30 L 45 50 L 95 30 Z', "vector-effect": 'non-scaling-stroke' }))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.bugRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.selectedAltSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    /**
     * A minimums bug.
     */
    class MinimumsBug extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.bugRef = msfssdk.FSComponent.createRef();
            this.isVisible = msfssdk.Subject.create(false);
            this.minimumsFeet = msfssdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.minimumsSub = this.props.minimums.sub(this.update.bind(this), true);
        }
        /**
         * Updates this bug.
         * @param minimums The current active minimums, in feet indicated altitude, or `null` if no such value exists.
         */
        update(minimums) {
            if (minimums === null) {
                this.isVisible.set(false);
            }
            else {
                this.minimumsFeet.set(minimums);
                this.isVisible.set(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(AltitudeBug, { ref: this.bugRef, altitudeFeet: this.minimumsFeet, show: this.isVisible, updateEvent: this.props.updateEvent, getPosition: (indicatedAlt) => msfssdk.MathUtils.clamp(this.props.getPosition(indicatedAlt, true), -0.5, 1.5), class: 'altimeter-minimums-bug' },
                msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 20 40', preserveAspectRatio: 'none', class: 'altimeter-minimums-bug-icon' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 5 20 l 8 -5 l 0 -14 l 3 0 l 0 14 l -9 5 l 9 5 l 0 14 l -3 0 l 0 -14 z', "vector-effect": 'non-scaling-stroke' }))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.bugRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.minimumsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    /**
     * A display for a selected altitude value.
     */
    class SelectedAltitudeDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.textStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.defaultStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.cssClassSet = msfssdk.SetSubject.create(['altimeter-selectedalt-container']);
            this.selectedAlt = msfssdk.Subject.create(0);
            this.animationDebounceTimer = new msfssdk.DebounceTimer();
            this.lastAlertState = undefined;
        }
        /** @inheritdoc */
        onAfterRender() {
            this.selectedAltSub = this.props.selectedAlt.sub(selectedAlt => {
                if (selectedAlt === null) {
                    this.textStyle.set('display', 'none');
                    this.defaultStyle.set('display', '');
                }
                else {
                    this.textStyle.set('display', '');
                    this.defaultStyle.set('display', 'none');
                    this.selectedAlt.set(Math.round(selectedAlt));
                }
            }, false, true);
            this.alertStateSub = this.props.altitudeAlertState.sub(state => {
                this.cssClassSet.delete('alt-alert-within1000-flash');
                this.cssClassSet.delete('alt-alert-within1000');
                this.cssClassSet.delete('alt-alert-deviation-flash');
                this.cssClassSet.delete('alt-alert-deviation');
                // Do not clear the flash animation if we are going from within 200 to captured.
                if (!(state === exports.AltitudeAlertState.Captured && this.lastAlertState === exports.AltitudeAlertState.Within200)) {
                    this.cssClassSet.delete('alt-alert-within200-flash');
                    this.animationDebounceTimer.clear();
                }
                switch (state) {
                    case exports.AltitudeAlertState.Within1000:
                        if (this.lastAlertState === exports.AltitudeAlertState.Armed) {
                            this.cssClassSet.add('alt-alert-within1000-flash');
                            this.animationDebounceTimer.schedule(() => {
                                this.cssClassSet.delete('alt-alert-within1000-flash');
                                this.cssClassSet.add('alt-alert-within1000');
                            }, SelectedAltitudeDisplay.ALERT_FLASH_DURATION);
                        }
                        else {
                            this.cssClassSet.add('alt-alert-within1000');
                        }
                        break;
                    case exports.AltitudeAlertState.Within200:
                        if (this.lastAlertState === exports.AltitudeAlertState.Within1000) {
                            this.cssClassSet.add('alt-alert-within200-flash');
                            this.animationDebounceTimer.schedule(() => {
                                this.cssClassSet.delete('alt-alert-within200-flash');
                            }, SelectedAltitudeDisplay.ALERT_FLASH_DURATION);
                        }
                        break;
                    case exports.AltitudeAlertState.Deviation:
                        this.cssClassSet.add('alt-alert-deviation-flash');
                        this.animationDebounceTimer.schedule(() => {
                            this.cssClassSet.delete('alt-alert-deviation-flash');
                            this.cssClassSet.add('alt-alert-deviation');
                        }, SelectedAltitudeDisplay.ALERT_FLASH_DURATION);
                        break;
                }
                this.lastAlertState = state;
            }, false, true);
            this.showSub = this.props.show.sub(show => {
                if (show) {
                    this.rootStyle.set('display', '');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.resume(true);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.alertStateSub.resume(true);
                }
                else {
                    this.rootStyle.set('display', 'none');
                    this.animationDebounceTimer.clear();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.selectedAltSub.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.alertStateSub.pause();
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.cssClassSet, style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("svg", { class: 'altimeter-selectedalt-icon', viewBox: '0 0 100 100', preserveAspectRatio: 'none' },
                    msfssdk.FSComponent.buildComponent("path", { d: 'M 95 5 h -90 v 90 h 90 v -25 L 50 50 L 95 25 Z', "vector-effect": 'non-scaling-stroke' })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-selectedalt-text', style: this.textStyle },
                    msfssdk.FSComponent.buildComponent("span", { class: 'altimeter-selectedalt-text-hundreds' }, this.selectedAlt.map(alt => Math.abs(alt) < 100 ? '' : Math.trunc(alt / 100).toString())),
                    msfssdk.FSComponent.buildComponent("span", { class: 'altimeter-selectedalt-text-tens' }, this.selectedAlt.map(alt => (Math.abs(alt) % 100).toFixed(0).padStart(alt === 0 ? 1 : 2, '0')))),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-selectedalt-default', style: this.defaultStyle }, "\u2013\u2013\u2013\u2013")));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.selectedAltSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.alertStateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    SelectedAltitudeDisplay.ALERT_FLASH_DURATION = 5000; // milliseconds
    /**
     * A display for altimeter barometric pressure setting.
     */
    class BaroSettingDisplay extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.baroSettingValueStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.baroStdStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.baroPreselectStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.cssClassSet = msfssdk.SetSubject.create(['altimeter-baro-container']);
            this.baroSetting = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.IN_HG.createNumber(29.92));
            this.baroPreselect = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.IN_HG.createNumber(29.92));
            this.displayUnit = this.props.isMetric.map(isMetric => isMetric ? msfssdk.UnitType.HPA : msfssdk.UnitType.IN_HG);
            this.animationDebounceTimer = new msfssdk.DebounceTimer();
        }
        /** @inheritdoc */
        onAfterRender() {
            var _a;
            this.baroSettingPipe = this.props.baroSetting.pipe(this.baroSetting, true);
            this.baroPreselectPipe = (_a = this.props.baroPreselect) === null || _a === void 0 ? void 0 : _a.pipe(this.baroPreselect, true);
            this.isStdActiveSub = this.props.isStdActive.sub(isStdActive => {
                if (isStdActive) {
                    this.baroSettingValueStyle.set('display', 'none');
                    this.baroStdStyle.set('display', '');
                    this.baroPreselectStyle.set('display', '');
                }
                else {
                    this.baroSettingValueStyle.set('display', '');
                    this.baroStdStyle.set('display', 'none');
                    this.baroPreselectStyle.set('display', 'none');
                }
            }, false, true);
            this.showSub = this.props.show.sub(show => {
                var _a, _b;
                if (show) {
                    this.rootStyle.set('display', '');
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.baroSettingPipe.resume(true);
                    (_a = this.baroPreselectPipe) === null || _a === void 0 ? void 0 : _a.resume(true);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.isStdActiveSub.resume(true);
                }
                else {
                    this.rootStyle.set('display', 'none');
                    this.animationDebounceTimer.clear();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.baroSettingPipe.pause();
                    (_b = this.baroPreselectPipe) === null || _b === void 0 ? void 0 : _b.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.isStdActiveSub.pause();
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.cssClassSet, style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-baro-setting-value', style: this.baroSettingValueStyle },
                    msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.baroSetting, displayUnit: this.displayUnit, formatter: (number) => {
                            return (this.props.isMetric.get() ? BaroSettingDisplay.HPA_FORMATTER : BaroSettingDisplay.IN_HG_FORMATTER)(number);
                        } })),
                msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-baro-std', style: this.baroStdStyle }, "STD BARO"),
                this.props.baroPreselect === undefined
                    ? null
                    : (msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-baro-preselect', style: this.baroPreselectStyle },
                        msfssdk.FSComponent.buildComponent("div", { class: 'altimeter-baro-preselect-title' }, "PRE"),
                        msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.baroPreselect, displayUnit: this.displayUnit, formatter: (number) => {
                                return (this.props.isMetric.get() ? BaroSettingDisplay.HPA_FORMATTER : BaroSettingDisplay.IN_HG_FORMATTER)(number);
                            }, class: 'altimeter-baro-preselect-value' })))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            this.displayUnit.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.baroSettingPipe) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.baroPreselectPipe) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.isStdActiveSub) === null || _d === void 0 ? void 0 : _d.destroy();
        }
    }
    BaroSettingDisplay.IN_HG_FORMATTER = msfssdk.NumberFormatter.create({ precision: 0.01 });
    BaroSettingDisplay.HPA_FORMATTER = msfssdk.NumberFormatter.create({ precision: 1 });

    /**
     * A default implementation of {@link AltimeterDataProvider}.
     */
    class DefaultAltimeterDataProvider {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param adcIndex The index of the ADC that is the source of this provider's data.
         * @param options Configuration options for this provider.
         * @param radarAltimeterDataProvider A radar altimeter data provider. If not defined, this data provider will not
         * support radar altitude or radar minimums.
         */
        constructor(bus, adcIndex, options, radarAltimeterDataProvider) {
            this.bus = bus;
            this.radarAltimeterDataProvider = radarAltimeterDataProvider;
            this._indicatedAlt = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.indicatedAlt = this._indicatedAlt;
            this.verticalSpeed = msfssdk.ConsumerSubject.create(null, 0);
            this._baroSetting = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.baroSetting = this._baroSetting;
            this._baroIsStdActive = msfssdk.ConsumerSubject.create(null, false);
            /** @inheritdoc */
            this.baroIsStdActive = this._baroIsStdActive;
            this._baroPreselect = msfssdk.ConsumerSubject.create(null, 0);
            /** @inheritdoc */
            this.baroPreselect = this._baroPreselect;
            this.selectedAltSource = msfssdk.ConsumerSubject.create(null, 0);
            this.selectedAltIsInit = msfssdk.ConsumerSubject.create(null, false);
            this._selectedAlt = msfssdk.MappedSubject.create(([selectedAltSource, isInit]) => {
                return isInit ? selectedAltSource : null;
            }, this.selectedAltSource, this.selectedAltIsInit);
            /** @inheritdoc */
            this.selectedAlt = this._selectedAlt;
            this.minimumsMode = msfssdk.ConsumerSubject.create(null, msfssdk.MinimumsMode.OFF);
            this.baroMinimumsSource = msfssdk.ConsumerSubject.create(null, 0);
            this.radarMinimumsSource = msfssdk.ConsumerSubject.create(null, 0);
            this._minimums = msfssdk.Subject.create(null);
            /** @inheritdoc */
            this.minimums = this._minimums;
            this._radarAlt = msfssdk.Subject.create(null);
            this.radarAlt = this._radarAlt;
            this.simTime = msfssdk.ConsumerSubject.create(null, 0);
            this.isOnGround = msfssdk.ConsumerSubject.create(null, false);
            this.isInit = false;
            this.isAlive = true;
            this.isPaused = false;
            this.adcIndex = msfssdk.SubscribableUtils.toSubscribable(adcIndex, true);
            this.trendLookahead = msfssdk.SubscribableUtils.toSubscribable(options.trendLookahead, true);
            this._altitudeTrend = msfssdk.MappedSubject.create(([verticalSpeed, lookahead]) => {
                return verticalSpeed * lookahead / 60;
            }, this.verticalSpeed, this.trendLookahead);
            this.altitudeTrend = this._altitudeTrend;
        }
        /**
         * Initializes this data provider. Once initialized, this data provider will continuously update its data until
         * paused or destroyed.
         * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
         * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
         * @throws Error if this data provider is dead.
         */
        init(paused = false) {
            if (!this.isAlive) {
                throw new Error('DefaultAltimeterDataProvider: cannot initialize a dead provider');
            }
            if (this.isInit) {
                return;
            }
            this.isInit = true;
            this.isPaused = paused;
            const sub = this.bus.getSubscriber();
            this.simTime.setConsumer(sub.on('simTime'));
            this.isOnGround.setConsumer(sub.on('on_ground'));
            this.adcIndexSub = this.adcIndex.sub(index => {
                this._indicatedAlt.setConsumer(sub.on(`adc_indicated_alt_${index}`));
                this._baroSetting.setConsumer(sub.on(`adc_altimeter_baro_setting_inhg_${index}`));
                this._baroIsStdActive.setConsumer(sub.on(`adc_altimeter_baro_is_std_${index}`));
                this._baroPreselect.setConsumer(sub.on(`adc_altimeter_baro_preselect_inhg_${index}`));
                this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
            }, true);
            this.selectedAltSource.setConsumer(sub.on('ap_altitude_selected'));
            this.selectedAltIsInit.setConsumer(sub.on('alt_select_is_initialized'));
            this.minimumsMode.setConsumer(sub.on('minimums_mode'));
            this.baroMinimumsSource.setConsumer(sub.on('decision_altitude_feet'));
            const baroMinimums = msfssdk.MappedSubject.create(([minimumsMode, baroMinimumsSource]) => {
                return minimumsMode === msfssdk.MinimumsMode.BARO ? baroMinimumsSource : null;
            }, this.minimumsMode, this.baroMinimumsSource);
            if (this.radarAltimeterDataProvider !== undefined) {
                this.radarAltPipe = this.radarAltimeterDataProvider.radarAlt.pipe(this._radarAlt, true);
                this.radarAltIsFailedSub = this.radarAltimeterDataProvider.isDataFailed.sub(isFailed => {
                    if (isFailed) {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        this.radarAltPipe.pause();
                        this._radarAlt.set(null);
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        this.radarAltPipe.resume(true);
                    }
                }, true);
                this.radarMinimumsSource.setConsumer(sub.on('decision_height_feet'));
                baroMinimums.pause();
                const baroPipe = baroMinimums.pipe(this._minimums, true);
                const radarMinimums = msfssdk.MappedSubject.create(([minimumsMode, radarMinimumsSource, radarAlt, indicatedAlt]) => {
                    return minimumsMode === msfssdk.MinimumsMode.RA && radarAlt !== null && isNaN(radarAlt)
                        ? indicatedAlt - radarAlt + radarMinimumsSource
                        : null;
                }, this.minimumsMode, this.radarMinimumsSource, this.radarAlt, this._indicatedAlt);
                radarMinimums.pause();
                const radarPipe = radarMinimums.pipe(this._minimums, true);
                this.minimumsMode.sub(minimumsMode => {
                    baroMinimums.pause();
                    baroPipe.pause();
                    radarMinimums.pause();
                    radarPipe.pause();
                    switch (minimumsMode) {
                        case msfssdk.MinimumsMode.BARO:
                            baroMinimums.resume();
                            baroPipe.resume(true);
                            break;
                        case msfssdk.MinimumsMode.RA:
                            radarMinimums.resume();
                            radarPipe.resume(true);
                            break;
                        default:
                            this._minimums.set(null);
                    }
                }, true);
            }
            else {
                baroMinimums.pipe(this._minimums);
            }
            if (paused) {
                this.pause();
            }
        }
        /**
         * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
         * destroyed.
         * @throws Error if this data provider is dead.
         */
        resume() {
            var _a;
            if (!this.isAlive) {
                throw new Error('DefaultAltimeterDataProvider: cannot resume a dead provider');
            }
            if (!this.isPaused) {
                return;
            }
            this.isPaused = false;
            this.simTime.resume();
            this.isOnGround.resume();
            this._indicatedAlt.resume();
            this._baroSetting.resume();
            this._baroIsStdActive.resume();
            this._baroPreselect.resume();
            this.verticalSpeed.resume();
            this._altitudeTrend.resume();
            this.selectedAltSource.resume();
            this.selectedAltIsInit.resume();
            (_a = this.radarAltIsFailedSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            this.minimumsMode.resume();
            this.baroMinimumsSource.resume();
            this.radarMinimumsSource.resume();
        }
        /**
         * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
         * @throws Error if this data provider is dead.
         */
        pause() {
            var _a, _b;
            if (!this.isAlive) {
                throw new Error('DefaultAltimeterDataProvider: cannot pause a dead provider');
            }
            if (this.isPaused) {
                return;
            }
            this.simTime.pause();
            this.isOnGround.pause();
            this._indicatedAlt.pause();
            this._baroSetting.pause();
            this._baroIsStdActive.pause();
            this._baroPreselect.pause();
            this.verticalSpeed.pause();
            this._altitudeTrend.pause();
            this.selectedAltSource.pause();
            this.selectedAltIsInit.pause();
            (_a = this.radarAltIsFailedSub) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.radarAltPipe) === null || _b === void 0 ? void 0 : _b.pause();
            this.minimumsMode.pause();
            this.baroMinimumsSource.pause();
            this.radarMinimumsSource.pause();
            this.isPaused = true;
        }
        /**
         * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
         * no longer be paused or resumed.
         */
        destroy() {
            var _a, _b, _c;
            this.isAlive = false;
            this.simTime.destroy();
            this.isOnGround.destroy();
            this._indicatedAlt.destroy();
            this._baroSetting.destroy();
            this._baroIsStdActive.destroy();
            this._baroPreselect.destroy();
            this.verticalSpeed.destroy();
            this._altitudeTrend.destroy();
            this.selectedAltSource.destroy();
            this.selectedAltIsInit.destroy();
            this.minimumsMode.destroy();
            this.baroMinimumsSource.destroy();
            this.radarMinimumsSource.destroy();
            (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.radarAltIsFailedSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.radarAltPipe) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }

    /**
     * A next-generation (NXi, G3000, etc) Garmin PFD radar altimeter.
     */
    class RadarAltimeter extends msfssdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.failedStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.operatingStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.rootCssClass = msfssdk.SetSubject.create(['radar-altimeter']);
            this.valueText = msfssdk.Subject.create('');
        }
        /** @inheritdoc */
        onAfterRender() {
            const minimumsAlertSub = this.minimumsAlertSub = this.props.minimumsAlertState.sub(state => {
                this.rootCssClass.delete('minimums-alert-atorbelow');
                if (state === exports.MinimumsAlertState.AtOrBelow) {
                    this.rootCssClass.add('minimums-alert-atorbelow');
                }
            }, false, true);
            const minimumsModeSub = this.minimumsModeSub = this.props.minimumsMode.sub(mode => {
                if (mode === msfssdk.MinimumsMode.RA) {
                    minimumsAlertSub.resume(true);
                }
                else {
                    minimumsAlertSub.pause();
                    this.rootCssClass.delete('minimums-alert-atorbelow');
                }
            }, false, true);
            const radarAltSub = this.radarAltSub = this.props.dataProvider.radarAlt.sub(radarAlt => {
                this.valueText.set(isNaN(radarAlt) ? '' : radarAlt.toFixed(0));
            }, false, true);
            const failedSub = this.failedSub = this.props.dataProvider.isDataFailed.sub(isFailed => {
                if (isFailed) {
                    radarAltSub.pause();
                    minimumsAlertSub.pause();
                    minimumsModeSub.pause();
                    this.operatingStyle.set('display', 'none');
                    this.failedStyle.set('display', '');
                }
                else {
                    this.failedStyle.set('display', 'none');
                    this.operatingStyle.set('display', '');
                    radarAltSub.resume(true);
                    minimumsModeSub.resume(true);
                }
            }, false, true);
            this.isVisibleSub = this.props.dataProvider.radarAlt.sub(radarAlt => {
                if (isNaN(radarAlt)) {
                    failedSub.pause();
                    radarAltSub.pause();
                    minimumsAlertSub.pause();
                    minimumsModeSub.pause();
                    this.rootStyle.set('display', 'none');
                }
                else {
                    this.rootStyle.set('display', '');
                    failedSub.resume(true);
                }
            }, true);
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass, style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'radar-altimeter-failed', style: this.failedStyle }, "RA FAIL"),
                msfssdk.FSComponent.buildComponent("div", { class: 'radar-altimeter-operating', style: this.operatingStyle },
                    msfssdk.FSComponent.buildComponent("div", { class: 'radar-altimeter-title' }, "RA"),
                    msfssdk.FSComponent.buildComponent("div", { class: 'radar-altimeter-value' }, this.valueText))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e;
            super.destroy();
            (_a = this.isVisibleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.radarAltSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.failedSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.minimumsModeSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.minimumsAlertSub) === null || _e === void 0 ? void 0 : _e.destroy();
        }
    }

    /**
     * A default implementation of {@link RadarAltimeterDataProvider}.
     */
    class DefaultRadarAltimeterDataProvider {
        /**
         * Constructor.
         * @param bus The event bus.
         */
        constructor(bus) {
            this.bus = bus;
            this.radarAltSource = msfssdk.ConsumerSubject.create(null, 0);
            this.radarAltRounded = this.radarAltSource.map(radarAlt => {
                if (radarAlt > 2500) {
                    return NaN;
                }
                else {
                    return DefaultRadarAltimeterDataProvider.ROUND_FUNC(radarAlt);
                }
            }, msfssdk.SubscribableUtils.NUMERIC_NAN_EQUALITY);
            this._radarAlt = msfssdk.Subject.create(0, msfssdk.SubscribableUtils.NUMERIC_NAN_EQUALITY);
            /** @inheritdoc */
            this.radarAlt = this._radarAlt;
            this._isDataFailed = msfssdk.Subject.create(false);
            /** @inheritdoc */
            this.isDataFailed = this._isDataFailed;
            this.servo = new msfssdk.LinearServo(150);
            this.currentValue = NaN;
            this.isInit = false;
            this.isAlive = true;
            this.isPaused = false;
        }
        /**
         * Initializes this data provider. Once initialized, this data provider will continuously update its data until
         * paused or destroyed.
         * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
         * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
         * @throws Error if this data provider is dead.
         */
        init(paused = false) {
            if (!this.isAlive) {
                throw new Error('DefaultRadarAltimeterDataProvider: cannot initialize a dead provider');
            }
            if (this.isInit) {
                return;
            }
            this.isInit = true;
            this.isPaused = paused;
            const sub = this.bus.getSubscriber();
            this.radarAltSystemStateSub = sub.on('radaralt_state_1').handle(state => {
                if (state.current === msfssdk.AvionicsSystemState.On) {
                    this._isDataFailed.set(false);
                }
                else {
                    this._isDataFailed.set(true);
                }
            });
            this.radarAltSource.setConsumer(sub.on('radaralt_radio_alt_1'));
            this.radarAltRoundedSub = this.radarAltRounded.sub(() => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.radarAltRoundedSub.pause();
                this.servo.drive(this.currentValue, this.currentValue); // reset servo's internal clock
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.clockSub.resume(true);
            }, false, true);
            this.clockSub = sub.on('realTime').handle(() => {
                const rounded = this.radarAltRounded.get();
                if (isNaN(rounded) || isNaN(this.currentValue)) {
                    this.currentValue = this.servo.drive(rounded, rounded);
                }
                else {
                    this.currentValue = this.servo.drive(this.currentValue, rounded);
                }
                this._radarAlt.set(isNaN(this.currentValue) ? NaN : DefaultRadarAltimeterDataProvider.ROUND_FUNC(this.currentValue));
                if (isNaN(this.currentValue) || this.currentValue === rounded) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.clockSub.pause();
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.radarAltRoundedSub.resume();
                }
            }, true);
            this.radarAltRoundedSub.resume(true);
            if (paused) {
                this.pause();
            }
        }
        /**
         * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
         * destroyed.
         * @throws Error if this data provider is dead.
         */
        resume() {
            var _a, _b;
            if (!this.isAlive) {
                throw new Error('DefaultRadarAltimeterDataProvider: cannot resume a dead provider');
            }
            if (!this.isPaused || !this.isInit) {
                return;
            }
            this.isPaused = false;
            this.radarAltSource.resume();
            (_a = this.radarAltRoundedSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            (_b = this.radarAltSystemStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
        /**
         * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
         * @throws Error if this data provider is dead.
         */
        pause() {
            var _a, _b;
            if (!this.isAlive) {
                throw new Error('DefaultRadarAltimeterDataProvider: cannot pause a dead provider');
            }
            if (this.isPaused || !this.isInit) {
                return;
            }
            (_a = this.radarAltSystemStateSub) === null || _a === void 0 ? void 0 : _a.pause();
            this.radarAltSource.pause();
            (_b = this.clockSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.currentValue = NaN;
            this.isPaused = true;
        }
        /**
         * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
         * no longer be paused or resumed.
         */
        destroy() {
            var _a, _b;
            this.isAlive = false;
            this.radarAltSource.destroy();
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.radarAltSystemStateSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    DefaultRadarAltimeterDataProvider.ROUND_FUNC = (radarAlt) => {
        if (radarAlt > 1500) {
            return msfssdk.MathUtils.round(radarAlt, 50);
        }
        else if (radarAlt > 200) {
            return msfssdk.MathUtils.round(radarAlt, 10);
        }
        else {
            return Math.max(msfssdk.MathUtils.round(radarAlt, 5), 0);
        }
    };

    /**
     * A PFD artificial horizon. Displays a horizon line, and sky and ground boxes.
     */
    class ArtificialHorizon extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                transform: 'translate3d(0, 0, 0)'
            });
            this.pitchTranslation = msfssdk.Subject.create(0);
            this.roll = msfssdk.Subject.create(0);
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.style.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            const transformHandler = () => {
                this.style.set('transform', `rotate(${-this.roll.get()}deg) translate3d(0px, ${this.pitchTranslation.get()}px, 0px)`);
            };
            this.pitchTranslation.map(msfssdk.SubscribableMapFunctions.withPrecision(0.1)).sub(transformHandler);
            this.roll.map(msfssdk.SubscribableMapFunctions.withPrecision(0.1)).sub(transformHandler);
            this.showSub = this.props.show.sub(show => { this.setVisible(show); }, true);
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.ScaleFactor
                | msfssdk.HorizonProjectionChangeType.Fov
                | msfssdk.HorizonProjectionChangeType.Pitch
                | msfssdk.HorizonProjectionChangeType.Roll)) {
                this.needUpdate = true;
            }
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            const pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov();
            const pitch = this.props.projection.getPitch();
            const roll = this.props.projection.getRoll();
            this.pitchTranslation.set(pitch * pitchResolution);
            this.roll.set(roll);
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: 'artificial-horizon', style: this.style },
                msfssdk.FSComponent.buildComponent("div", { class: 'artificial-horizon-sky' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'artificial-horizon-horizon' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'artificial-horizon-ground' })));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * An aircraft symbol for the PFD attitude indicator.
     */
    class AttitudeAircraftSymbol extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: ''
            });
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.style.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.showSub = this.props.show.sub(show => { this.setVisible(show); }, true);
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 414 315', class: 'attitude-aircraft-symbol', style: this.style },
                msfssdk.FSComponent.buildComponent("path", { d: 'M 47 204 l -3 -4 l -43 0 l 0 4 ', fill: 'var(--attitude-aircraft-symbol-fill-light)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-bar-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 47 204 l -3 4 l -43 0 l 0 -4 ', fill: 'var(--attitude-aircraft-symbol-fill-dark)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-bar-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 365 204 l 3 -4 l 43 0 l 0 4 ', fill: 'var(--attitude-aircraft-symbol-fill-light)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-bar-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 365 204 l 3 4 l 43 0 l 0 -4 ', fill: 'var(--attitude-aircraft-symbol-fill-dark)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-bar-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l 0 -1 l -120 31 l 35 0 ', fill: 'var(--attitude-aircraft-symbol-fill-light)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-arrow-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l -66 30 l -19 0 ', fill: 'var(--attitude-aircraft-symbol-fill-dark)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-arrow-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l 0 -1 l 120 31 l -35 0 ', fill: 'var(--attitude-aircraft-symbol-fill-light)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-arrow-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l 66 30 l 19 0 ', fill: 'var(--attitude-aircraft-symbol-fill-dark)', stroke: 'var(--attitude-aircraft-symbol-stroke)', "stroke-width": 'var(--attitude-aircraft-symbol-arrow-stroke-width)' })));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /// <reference types="msfstypes/JS/Avionics" />
    /**
     * A PFD attitude indicator. Displays a roll scale arc with pointer indicating the current roll angle, a pitch ladder
     * indicating the current pitch angle, and a slip/skid indicator.
     */
    class AttitudeIndicator extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.pitchLadderRef = msfssdk.FSComponent.createRef();
            this.slipSkidRef = msfssdk.FSComponent.createRef();
            this.rootCssClass = msfssdk.SetSubject.create(['attitude-container']);
            this.rootStyle = msfssdk.ObjectSubject.create({
                display: ''
            });
            this.bankStyle = msfssdk.ObjectSubject.create({
                transform: 'rotate(0deg)'
            });
            this.reverseBankStyle = msfssdk.ObjectSubject.create({
                transform: 'rotate(0deg)'
            });
            this.ahrsAlignStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.ahrsState = msfssdk.ConsumerSubject.create(null, { previous: undefined, current: msfssdk.AvionicsSystemState.On });
            this.roll = msfssdk.Subject.create(0);
            this.turnCoordinatorBallSource = msfssdk.ConsumerSubject.create(null, 0);
            this.turnCoordinatorBall = msfssdk.Subject.create(0);
            this.needUpdateRoll = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.rootStyle.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.pitchLadderRef.instance.onAttached();
            this.slipSkidRef.instance.onAttached();
            const sub = this.props.bus.getSubscriber();
            this.turnCoordinatorBallPipe = this.turnCoordinatorBallSource.pipe(this.turnCoordinatorBall, true);
            this.roll.map(msfssdk.SubscribableMapFunctions.withPrecision(0.1)).sub(roll => {
                this.bankStyle.set('transform', `rotate(${-roll}deg)`);
                this.reverseBankStyle.set('transform', `rotate(${roll}deg)`);
            });
            this.ahrsState.sub(this.onAhrsStateChanged.bind(this), true);
            this.ahrsIndexSub = this.props.ahrsIndex.sub(index => {
                this.ahrsState.setConsumer(sub.on(`ahrs_state_${index}`));
                this.turnCoordinatorBallSource.setConsumer(sub.on(`ahrs_turn_coordinator_ball_${index}`).withPrecision(2));
            }, true);
        }
        /**
         * Responds to AHRS system state events.
         * @param state An AHRS system state event.
         */
        onAhrsStateChanged(state) {
            if (state.previous === undefined && state.current !== msfssdk.AvionicsSystemState.Off) {
                this.setDisplayState('ok');
            }
            else {
                switch (state.current) {
                    case msfssdk.AvionicsSystemState.Off:
                    case msfssdk.AvionicsSystemState.Failed:
                        this.setDisplayState('failed');
                        break;
                    case msfssdk.AvionicsSystemState.Initializing:
                        this.setDisplayState('align');
                        break;
                    case msfssdk.AvionicsSystemState.On:
                        this.setDisplayState('ok');
                        break;
                }
            }
        }
        /**
         * Sets the display state of the attitude display.
         * @param state The state to set the display to.
         */
        setDisplayState(state) {
            var _a, _b, _c;
            switch (state) {
                case 'failed':
                    this.rootCssClass.add('failed-instr');
                    this.ahrsAlignStyle.set('display', 'none');
                    (_a = this.turnCoordinatorBallPipe) === null || _a === void 0 ? void 0 : _a.pause();
                    this.turnCoordinatorBall.set(0);
                    this.pitchLadderRef.instance.setVisible(false);
                    this.slipSkidRef.instance.setVisible(false);
                    break;
                case 'align':
                    this.rootCssClass.delete('failed-instr');
                    this.ahrsAlignStyle.set('display', '');
                    (_b = this.turnCoordinatorBallPipe) === null || _b === void 0 ? void 0 : _b.pause();
                    this.turnCoordinatorBall.set(0);
                    this.pitchLadderRef.instance.setVisible(false);
                    this.slipSkidRef.instance.setVisible(false);
                    break;
                case 'ok':
                    this.rootCssClass.delete('failed-instr');
                    this.ahrsAlignStyle.set('display', 'none');
                    (_c = this.turnCoordinatorBallPipe) === null || _c === void 0 ? void 0 : _c.resume(true);
                    this.pitchLadderRef.instance.setVisible(true);
                    this.slipSkidRef.instance.setVisible(true);
                    break;
            }
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            this.pitchLadderRef.instance.onProjectionChanged(projection, changeFlags);
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.HorizonProjectionChangeType.Roll)) {
                this.needUpdateRoll = true;
            }
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.isVisible()) {
                return;
            }
            this.pitchLadderRef.instance.onUpdated();
            this.slipSkidRef.instance.onUpdated();
            if (this.needUpdateRoll) {
                this.roll.set(this.props.projection.getRoll());
                this.needUpdateRoll = false;
            }
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass, style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'failed-box' }),
                msfssdk.FSComponent.buildComponent("div", { class: 'attitude-bank', style: this.bankStyle },
                    msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 414 315', class: 'attitude-roll-scale' },
                        msfssdk.FSComponent.buildComponent("path", { d: 'M 207 214 m 0 -193 l -10 -20 l 20 0 l -10 20 a 193 193 0 0 1 32.53 2.76 l 2.43 -13.79 l 1.97 0.35 l -2.43 13.79 a 193 193 0 0 1 29.63 7.86 l 4.79 -13.16 l 1.88 0.68 l -4.79 13.16 a 193 193 0 0 1 28.76 13.22 l 14 -24.25 l 1.73 1 l -14 24.25 a 193 193 0 0 1 38.56 29.26 l 9.9 -9.9 l 1.41 1.41 l -9.9 9.9 a 193 193 0 0 1 29.67 38.24 l 24.24 -14 l 1 1.73 l -25.98 15 a 191 191 0 0 0 -330.8 0 l -25.98 -15 l 1 -1.73 l 24.25 14 a 193 193 0 0 1 29.67 -38.24 l -9.9 -9.9 l 1.41 -1.41 l 9.9 9.9 a 193 193 0 0 1 38.56 -29.26 l -14 -24.25 l 1.73 -1 l 14 24.25 a 193 193 0 0 1 28.76 -13.22 l -4.79 -13.16 l 1.88 -0.68 l 4.79 13.16 a 193 193 0 0 1 29.63 -7.86 l -2.43 -13.79 l 1.97 -0.35 l 2.43 13.79 a 193 193 0 0 1 32.53 -2.76' })),
                    msfssdk.FSComponent.buildComponent("div", { class: 'attitude-cutout', style: this.reverseBankStyle },
                        msfssdk.FSComponent.buildComponent("div", { class: 'attitude-inner-bank', style: this.bankStyle },
                            msfssdk.FSComponent.buildComponent(PitchLadder, Object.assign({ ref: this.pitchLadderRef, projection: this.props.projection, isSVTEnabled: this.props.isSVTEnabled }, this.props.pitchLadderOptions))))),
                msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 414 315', class: 'attitude-roll-pointer' },
                    msfssdk.FSComponent.buildComponent("path", { d: "M 207 214 m 0 -192 l -10 20 l 20 0 l -10 -20 " })),
                msfssdk.FSComponent.buildComponent(SlipSkidIndicator, Object.assign({ ref: this.slipSkidRef, projection: this.props.projection, turnCoordinatorBall: this.turnCoordinatorBall }, this.props.slipSkidOptions)),
                msfssdk.FSComponent.buildComponent("div", { class: 'ahrs-align-msg', style: this.ahrsAlignStyle }, "AHRS ALIGN: Keep Wings Level")));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            this.turnCoordinatorBallSource.destroy();
            this.ahrsState.destroy();
            (_a = this.ahrsIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.pitchLadderRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.slipSkidRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    /**
     * A pitch ladder for the PFD attitude indicator.
     */
    class PitchLadder extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.svgRef = msfssdk.FSComponent.createRef();
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                overflow: 'visible',
                transform: 'translate3d(0px, 0px, 0px)'
            });
            this.pitchResolution = 0; // pixels per degree
            this.translation = msfssdk.Subject.create(0);
            this.needRebuildLadder = false;
            this.needReposition = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.style.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.svtSub = this.props.isSVTEnabled.sub(() => { this.needRebuildLadder = true; }, true);
            this.translation.map(msfssdk.SubscribableMapFunctions.withPrecision(0.1)).sub(translation => {
                this.style.set('transform', `translate3d(0px, ${translation}px, 0px)`);
            });
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.Fov | msfssdk.HorizonProjectionChangeType.ScaleFactor)) {
                this.needRebuildLadder = true;
            }
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.Pitch)) {
                this.needReposition = true;
            }
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needReposition && !this.needRebuildLadder) {
                return;
            }
            if (this.needRebuildLadder) {
                this.rebuildLadder();
                this.needRebuildLadder = false;
            }
            this.repositionLadder();
            this.needReposition = false;
        }
        /**
         * Repositions this ladder based on the current pitch.
         */
        repositionLadder() {
            this.translation.set(this.props.projection.getPitch() * this.pitchResolution);
        }
        /**
         * Rebuilds this ladder.
         */
        rebuildLadder() {
            this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov();
            const styles = this.props.isSVTEnabled.get() ? this.props.svtEnabledStyles : this.props.svtDisabledStyles;
            this.svgRef.instance.innerHTML = '';
            const majorFactor = styles.majorLineFactor * styles.mediumLineFactor;
            const len = Math.floor(90 / styles.minorLineIncrement);
            for (let i = 1; i < len; i++) {
                const pitch = i * styles.minorLineIncrement;
                const y = pitch * this.pitchResolution;
                let lineLength;
                let showNumber = false;
                if (i % majorFactor === 0) {
                    // major line
                    lineLength = styles.majorLineLength;
                    showNumber = styles.majorLineShowNumber;
                }
                else if (i % styles.mediumLineFactor === 0 && pitch <= styles.mediumLineMaxPitch) {
                    // medium line
                    lineLength = styles.mediumLineLength;
                    showNumber = styles.mediumLineShowNumber;
                }
                else if (pitch <= styles.minorLineMaxPitch) {
                    // minor line
                    lineLength = styles.minorLineLength;
                    showNumber = styles.minorLineShowNumber;
                }
                if (lineLength !== undefined) {
                    if (lineLength > 0) {
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: -y, x2: lineLength / 2, y2: -y }, "."), this.svgRef.instance);
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: y, x2: lineLength / 2, y2: y }, "."), this.svgRef.instance);
                    }
                    if (showNumber) {
                        const pitchText = pitch.toString();
                        const leftAnchorX = -lineLength / 2 - 20;
                        const rightAnchorX = lineLength / 2 + 20;
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("text", { x: leftAnchorX, y: -y, "text-anchor": 'middle', "dominant-baseline": 'central' }, pitchText), this.svgRef.instance);
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("text", { x: rightAnchorX, y: -y, "text-anchor": 'middle', "dominant-baseline": 'central' }, pitchText), this.svgRef.instance);
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("text", { x: leftAnchorX, y: y, "text-anchor": 'middle', "dominant-baseline": 'central' }, pitchText), this.svgRef.instance);
                        msfssdk.FSComponent.render(msfssdk.FSComponent.buildComponent("text", { x: rightAnchorX, y: y, "text-anchor": 'middle', "dominant-baseline": 'central' }, pitchText), this.svgRef.instance);
                    }
                }
            }
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { ref: this.svgRef, class: 'attitude-pitchladder', style: this.style }));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.svtSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }
    /**
     * A slip/skid indicator for the PFD attitude indicator.
     */
    class SlipSkidIndicator extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                transform: 'translate3d(0px, 0px, 0px)'
            });
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.style.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.ballSub = this.props.turnCoordinatorBall.sub(() => {
                this.needUpdate = true;
            });
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate) {
                return;
            }
            const ballPosition = this.props.turnCoordinatorBall.get();
            this.style.set('transform', `translate3d(${ballPosition * this.props.translationFactor}px, 0px, 0px)`);
            this.needUpdate = false;
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 30 20', class: 'attitude-slip-skid', style: this.style },
                msfssdk.FSComponent.buildComponent("path", { d: 'M 15 15 l 15 0 l -3 -6 l -24 0 l -3 6 l 15 0' })));
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            super.destroy();
            (_a = this.ballSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }

    /**
     * A PFD flight director.
     */
    class FlightDirector extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                display: '',
                transform: 'translate3d(0, 0, 0)'
            });
            this.isFdActive = msfssdk.ConsumerSubject.create(null, false);
            this.fdPitch = msfssdk.ConsumerSubject.create(null, 0);
            this.fdBank = msfssdk.ConsumerSubject.create(null, 0);
            this.isVisibleSubject = msfssdk.MappedSubject.create(([show, isFdActive]) => show && isFdActive, this.props.show, this.isFdActive);
            this.bankServo = new msfssdk.LinearServo(5);
            this.pitchAverage = new msfssdk.SimpleMovingAverage(20);
            this.pitchBank = msfssdk.Vec2Subject.create(msfssdk.Vec2Math.create());
            this.fdServoBank = 0;
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            if (isVisible) {
                this.style.set('display', '');
                this.fdPitch.resume();
                this.fdBank.resume();
                this.needUpdate = true;
            }
            else {
                this.style.set('display', 'none');
                this.fdPitch.pause();
                this.fdBank.pause();
            }
        }
        /**
         * A callback called after the component renders.
         */
        onAttached() {
            super.onAttached();
            const sub = this.props.bus.getSubscriber();
            const updateHandler = () => { this.needUpdate = true; };
            this.fdPitch.setConsumer(sub.on('flight_director_pitch').withPrecision(2)).sub(updateHandler);
            this.fdBank.setConsumer(sub.on('flight_director_bank').withPrecision(2)).sub(updateHandler);
            this.isFdActive.setConsumer(sub.on('flight_director_is_active_1'));
            this.pitchBank.sub(([pitch, bank]) => {
                this.style.set('transform', `translate3d(0px, ${pitch}px, 0px) rotate(${bank}deg)`);
            });
            this.isVisibleSubject.sub(isVisible => {
                this.setVisible(isVisible);
            }, true);
            const notInstalledSub = sub.on('fd_not_installed').handle(value => {
                if (value) {
                    notInstalledSub.destroy();
                    this.fdPitch.setConsumer(null);
                    this.fdBank.setConsumer(null);
                    this.isFdActive.setConsumer(null);
                    this.needUpdate = false;
                    this.setVisible(false);
                }
            }, true);
            notInstalledSub.resume(true);
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.ScaleFactor
                | msfssdk.HorizonProjectionChangeType.Fov
                | msfssdk.HorizonProjectionChangeType.Pitch
                | msfssdk.HorizonProjectionChangeType.Roll)) {
                this.needUpdate = true;
            }
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            const pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov();
            const pitch = this.props.projection.getPitch();
            const roll = this.props.projection.getRoll();
            const fdRawPitch = this.fdPitch.get();
            const fdRawBank = this.fdBank.get();
            const averagedFdPitch = this.pitchAverage.getAverage(fdRawPitch);
            const correctedFdPitch = msfssdk.MathUtils.clamp(-averagedFdPitch - pitch, -this.props.maxPitch, this.props.maxPitch); // FD pitch
            this.fdServoBank = this.bankServo.drive(this.fdServoBank, fdRawBank);
            const correctedFdBank = this.fdServoBank + roll;
            this.pitchBank.set(msfssdk.MathUtils.round(-correctedFdPitch * pitchResolution, 0.1), msfssdk.MathUtils.round(-correctedFdBank, 0.1));
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { viewBox: '0 0 414 315', class: 'flight-director-container', style: this.style },
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l -120 30 l -14 -9 l 134 -22 z', fill: 'var(--flight-director-fill)', stroke: 'var(--flight-director-stroke)', "stroke-width": 'var(--flight-director-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 73 225 l 0 9 l 14 0 z', fill: 'var(--flight-director-fill)', stroke: 'var(--flight-director-stroke)', "stroke-width": 'var(--flight-director-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 207 204 l 120 30 l 14 -9 l -134 -22 z', fill: 'var(--flight-director-fill)', stroke: 'var(--flight-director-stroke)', "stroke-width": 'var(--flight-director-stroke-width)' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M 341 225 l 0 9 l -14 0 z', fill: 'var(--flight-director-fill)', stroke: 'var(--flight-director-stroke)', "stroke-width": 'var(--flight-director-stroke-width)' })));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.isFdActive.destroy();
            this.fdPitch.destroy();
            this.fdBank.destroy();
        }
    }

    /**
     * A PFD synthetic vision technology (SVT) flight path marker. Displays an icon depicting the estimated position of the
     * airplane projected forward in time given the airplane's current horizontal and vertical speed and track.
     */
    class FlightPathMarker extends msfssdk.HorizonLayer {
        constructor() {
            var _a, _b, _c;
            super(...arguments);
            this.style = msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: 0,
                top: 0,
                display: '',
                transform: 'translate(-50%, -50%) translate3d(0, 0, 0)'
            });
            this.minGs = (_a = this.props.minGroundSpeed) !== null && _a !== void 0 ? _a : FlightPathMarker.DEFAULT_MIN_GS;
            this.lookahead = (_b = this.props.lookahead) !== null && _b !== void 0 ? _b : FlightPathMarker.DEFAULT_LOOKAHEAD;
            this.smoothingTimeConstant = (_c = this.props.smoothingTimeConstant) !== null && _c !== void 0 ? _c : FlightPathMarker.DEFAULT_SMOOTHING_TIME_CONSTANT;
            this.gs = msfssdk.ConsumerSubject.create(null, 0);
            this.track = msfssdk.ConsumerSubject.create(null, 0);
            this.vs = msfssdk.ConsumerSubject.create(null, 0);
            this.isFpmVisible = msfssdk.MappedSubject.create(([show, gs]) => {
                return show && gs >= this.minGs;
            }, this.props.show, this.gs);
            this.groundTrackSmoother = new msfssdk.ExpSmoother(this.smoothingTimeConstant);
            this.gsSmoother = new msfssdk.ExpSmoother(this.smoothingTimeConstant);
            this.projectedPosition = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create());
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            if (isVisible) {
                this.style.set('display', '');
            }
            else {
                this.style.set('display', 'none');
                this.groundTrackSmoother.reset();
                this.gsSmoother.reset();
            }
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            const sub = this.props.bus.getSubscriber();
            this.gs.setConsumer(sub.on('ground_speed'));
            this.track.setConsumer(sub.on('track_deg_true'));
            this.vs.setConsumer(sub.on('vertical_speed'));
            this.isFpmVisible.sub(show => { this.setVisible(show); }, true);
            this.gs.sub(() => { this.needUpdate = true; });
            this.track.sub(() => { this.needUpdate = true; });
            this.vs.sub(() => { this.needUpdate = true; });
            this.projectedPosition.sub(position => {
                this.style.set('transform', `translate(-50%, -50%) translate3d(${position[0]}px, ${position[1]}px, 0)`);
            });
            this.needUpdate = true;
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.Fov
                | msfssdk.HorizonProjectionChangeType.ScaleFactor
                | msfssdk.HorizonProjectionChangeType.Offset
                | msfssdk.HorizonProjectionChangeType.ProjectedOffset
                | msfssdk.HorizonProjectionChangeType.Heading
                | msfssdk.HorizonProjectionChangeType.Pitch
                | msfssdk.HorizonProjectionChangeType.Roll)) {
                this.needUpdate = true;
            }
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            if (!this.needUpdate || !this.isVisible()) {
                return;
            }
            const smoothedGs = this.gsSmoother.next(this.gs.get(), elapsed);
            const smoothedTrack = this.smoothGroundTrack(this.track.get(), elapsed);
            const distance = msfssdk.UnitType.KNOT.convertTo(smoothedGs, msfssdk.UnitType.MPS) * this.lookahead;
            const height = msfssdk.UnitType.FPM.convertTo(this.vs.get(), msfssdk.UnitType.MPS) * this.lookahead; // no need to smooth VS since the data we get is already effectively smoothed
            const projected = this.props.projection.projectRelativeSpherical(smoothedTrack, distance, height, FlightPathMarker.vec2Cache[0]);
            this.projectedPosition.set(msfssdk.MathUtils.round(projected[0], 0.1), msfssdk.MathUtils.round(projected[1], 0.1));
        }
        /**
         * Smooths a ground track value.
         * @param track A ground track value.
         * @param dt The elapsed time, in milliseconds, since the last smoothed value was calculated.
         * @returns A smoothed ground track value.
         */
        smoothGroundTrack(track, dt) {
            const last = this.groundTrackSmoother.last();
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
            const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
            const normalized = (next + 360) % 360; // enforce range 0-359
            return this.groundTrackSmoother.reset(normalized);
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /**
         * Renders the component.
         * @returns The component VNode.
         */
        render() {
            return (msfssdk.FSComponent.buildComponent("svg", { viewBox: '-30 -30 60 60', class: 'flight-path-marker', style: this.style },
                msfssdk.FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 m 16 0 l -16 0 a 14 14 0 1 0 -28 0 l -16 0 m 30 -14 l 0 -12', stroke: 'var(--flight-path-marker-outline-stroke)', "stroke-width": 'var(--flight-path-marker-outline-stroke-width)', fill: 'none' }),
                msfssdk.FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 m 14 0 l -14 0 a 14 14 0 1 0 -28 0 l -14 0 m 28 -14 l 0 -10', stroke: 'var(--flight-path-marker-stroke)', "stroke-width": 'var(--flight-path-marker-stroke-width)', fill: 'none' })));
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            this.isFpmVisible.destroy();
            this.gs.destroy();
            this.track.destroy();
            this.vs.destroy();
        }
    }
    FlightPathMarker.DEFAULT_MIN_GS = 30; // knots
    FlightPathMarker.DEFAULT_LOOKAHEAD = 60; // seconds
    FlightPathMarker.DEFAULT_SMOOTHING_TIME_CONSTANT = 500 / Math.LN2; // milliseconds
    FlightPathMarker.vec2Cache = [msfssdk.Vec2Math.create()];

    /**
     * A synthetic vision technology (SVT) display.
     */
    class SyntheticVision extends msfssdk.HorizonLayer {
        constructor() {
            super(...arguments);
            this.horizonLineRef = msfssdk.FSComponent.createRef();
            this.rootStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                display: '',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%'
            });
            this.bingStyle = msfssdk.ObjectSubject.create({
                position: 'absolute',
                display: '',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%'
            });
            this.resolution = msfssdk.Vec2Subject.createFromVector(msfssdk.Vec2Math.create(100, 100));
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.rootStyle.set('display', isVisible ? '' : 'none');
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.horizonLineRef.instance.onAttached();
            this.isEnabledSub = this.props.isEnabled.sub(isEnabled => { this.setVisible(isEnabled); }, true);
            this.needUpdate = true;
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            this.horizonLineRef.instance.onProjectionChanged(projection, changeFlags);
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.ProjectedSize | msfssdk.HorizonProjectionChangeType.ProjectedOffset)) {
                this.needUpdate = true;
            }
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.isVisible()) {
                return;
            }
            this.horizonLineRef.instance.onUpdated();
            if (!this.needUpdate) {
                return;
            }
            const projectedSize = this.props.projection.getProjectedSize();
            const projectedOffset = this.props.projection.getProjectedOffset();
            const offsetCenterProjected = this.props.projection.getOffsetCenterProjected();
            // We need to move the Bing texture such that its center lies at the center of the projection, including offset.
            // If there is an offset, we need to overdraw the Bing texture in order to fill the entire projection window.
            const xOverdraw = Math.abs(projectedOffset[0]);
            const yOverdraw = Math.abs(projectedOffset[1]);
            const bingWidth = projectedSize[0] + xOverdraw * 2;
            const bingHeight = projectedSize[1] + yOverdraw * 2;
            this.resolution.set(bingWidth, bingHeight);
            this.bingStyle.set('left', `${offsetCenterProjected[0] - bingWidth / 2}px`);
            this.bingStyle.set('top', `${offsetCenterProjected[1] - bingHeight / 2}px`);
            this.bingStyle.set('width', `${bingWidth}px`);
            this.bingStyle.set('height', `${bingHeight}px`);
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onDetached() {
            super.onDetached();
            this.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { style: this.bingStyle },
                    msfssdk.FSComponent.buildComponent(msfssdk.SynVisComponent, { bingId: this.props.bingId, resolution: this.resolution, skyColor: msfssdk.Subject.create(msfssdk.BingComponent.hexaToRGBColor(SyntheticVision.SKY_COLOR)), earthColors: msfssdk.ArraySubject.create(SyntheticVision.createEarthColors()) })),
                msfssdk.FSComponent.buildComponent(HorizonLine, Object.assign({ ref: this.horizonLineRef, projection: this.props.projection, showHeadingLabels: this.props.showHeadingLabels, useMagneticHeading: msfssdk.Subject.create(true) }, this.props.horizonLineOptions))));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.isEnabledSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.horizonLineRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
        }
        /**
         * Creates a full Bing component earth color array.
         * @returns A full Bing component earth color array.
         */
        static createEarthColors() {
            return msfssdk.BingComponent.createEarthColorsArray('#000049', [
                {
                    elev: 0,
                    color: '#0c2e04'
                },
                {
                    elev: 500,
                    color: '#113300'
                },
                {
                    elev: 2000,
                    color: '#463507'
                },
                {
                    elev: 3000,
                    color: '#5c421f'
                },
                {
                    elev: 6000,
                    color: '#50331b'
                },
                {
                    elev: 8000,
                    color: '#512d15'
                },
                {
                    elev: 10500,
                    color: '#673118'
                },
                {
                    elev: 27000,
                    color: '#4d4d4d'
                },
                {
                    elev: 29000,
                    color: '#666666'
                }
            ]);
        }
    }
    SyntheticVision.SKY_COLOR = '#0033E6';
    /**
     * A synthetic vision horizon line. Displays a horizon line with heading tick marks every 10 degrees and optional
     * heading labels every 30 degrees.
     */
    class HorizonLine extends msfssdk.HorizonLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            super(...arguments);
            this.canvasLayerRef = msfssdk.FSComponent.createRef();
            this.lineStrokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : HorizonLine.DEFAULT_LINE_STROKE_WIDTH;
            this.lineStrokeColor = (_b = this.props.strokeColor) !== null && _b !== void 0 ? _b : HorizonLine.DEFAULT_LINE_STROKE_COLOR;
            this.lineOutlineWidth = (_c = this.props.outlineWidth) !== null && _c !== void 0 ? _c : HorizonLine.DEFAULT_LINE_OUTLINE_WIDTH;
            this.lineOutlineColor = (_d = this.props.outlineColor) !== null && _d !== void 0 ? _d : HorizonLine.DEFAULT_LINE_OUTLINE_COLOR;
            this.tickStrokeWidth = (_e = this.props.headingTickWidth) !== null && _e !== void 0 ? _e : HorizonLine.DEFAULT_TICK_STROKE_WIDTH;
            this.tickStrokeColor = (_f = this.props.headingTickColor) !== null && _f !== void 0 ? _f : HorizonLine.DEFAULT_TICK_STROKE_COLOR;
            this.fontColor = (_g = this.props.fontColor) !== null && _g !== void 0 ? _g : HorizonLine.DEFAULT_FONT_COLOR;
            this.fontOutlineWidth = (_h = this.props.fontOutlineWidth) !== null && _h !== void 0 ? _h : HorizonLine.DEFAULT_FONT_OUTLINE_WIDTH;
            this.fontOutlineColor = (_j = this.props.fontOutlineColor) !== null && _j !== void 0 ? _j : HorizonLine.DEFAULT_FONT_OUTLINE_COLOR;
            this.bounds = msfssdk.VecNSubject.createFromVector(msfssdk.VecNMath.create(4, -HorizonLine.BOUNDS_BUFFER, -HorizonLine.BOUNDS_BUFFER, HorizonLine.BOUNDS_BUFFER, HorizonLine.BOUNDS_BUFFER));
            this.pathStream = new msfssdk.ClippedPathStream(msfssdk.NullPathStream.INSTANCE, this.bounds);
            this.nodes = Array.from({ length: HorizonLine.TICK_COUNT }, (v, index) => {
                return {
                    heading: index * HorizonLine.TICK_INCREMENT,
                    projected: msfssdk.Vec2Math.create()
                };
            });
            this.needUpdate = false;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.updateBounds();
            this.canvasLayerRef.instance.onAttached();
            this.pathStream.setConsumer(this.canvasLayerRef.instance.display.context);
            this.canvasLayerRef.instance.display.context.textAlign = 'center';
            this.canvasLayerRef.instance.display.context.fillStyle = this.fontColor;
            this.showLabelsSub = this.props.showHeadingLabels.sub(() => { this.needUpdate = true; });
            this.useMagneticSub = this.props.useMagneticHeading.sub(() => { this.needUpdate = true; });
            this.needUpdate = true;
        }
        /** @inheritdoc */
        onProjectionChanged(projection, changeFlags) {
            this.canvasLayerRef.instance.onProjectionChanged(projection, changeFlags);
            if (msfssdk.BitFlags.isAll(changeFlags, msfssdk.HorizonProjectionChangeType.ProjectedSize)) {
                this.updateBounds();
                // Changing the size of the canvas will reset its state, so we need to re-apply this style.
                this.canvasLayerRef.instance.display.context.textAlign = 'center';
                this.canvasLayerRef.instance.display.context.fillStyle = this.fontColor;
            }
            this.needUpdate = true;
        }
        /**
         * Updates this layer's drawing bounds.
         */
        updateBounds() {
            const projectedSize = this.props.projection.getProjectedSize();
            this.bounds.set(-HorizonLine.BOUNDS_BUFFER, -HorizonLine.BOUNDS_BUFFER, projectedSize[0] + HorizonLine.BOUNDS_BUFFER, projectedSize[1] + HorizonLine.BOUNDS_BUFFER);
        }
        /** @inheritdoc */
        onUpdated() {
            if (!this.needUpdate) {
                return;
            }
            const display = this.canvasLayerRef.instance.display;
            display.clear();
            const projection = this.props.projection;
            const position = projection.getPosition();
            const useMagnetic = this.props.useMagneticHeading.get();
            // Find the most central heading tick
            const headingOffset = useMagnetic ? msfssdk.MagVar.get(position.lat, position.lon) : 0;
            this.recomputeNodes(projection, headingOffset);
            this.drawLine(display.context);
            this.drawTicks(display.context, projection, headingOffset);
            this.needUpdate = false;
        }
        /**
         * Recomputes the projected positions of horizon line nodes.
         * @param projection The horizon projection.
         * @param headingOffset The offset, in degrees, of the heading ticks with respect to true heading.
         */
        recomputeNodes(projection, headingOffset) {
            for (let i = 0; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                projection.projectRelativeEuclidean(node.heading + headingOffset, this.props.ringRadius, 0, node.projected);
            }
        }
        /**
         * Draws the horizon line on a canvas.
         * @param context The canvas rendering context to which to draw the line.
         */
        drawLine(context) {
            this.pathStream.beginPath();
            const first = this.nodes[0].projected;
            this.pathStream.moveTo(first[0], first[1]);
            for (let i = 1; i < this.nodes.length; i++) {
                const projected = this.nodes[i].projected;
                this.pathStream.lineTo(projected[0], projected[1]);
            }
            this.pathStream.lineTo(first[0], first[1]);
            this.strokePath(context, this.lineStrokeWidth, this.lineStrokeColor, this.lineOutlineWidth, this.lineOutlineColor);
        }
        /**
         * Draws this horizon line's heading ticks on a canvas.
         * @param context The canvas rendering context to which to draw the ticks.
         * @param projection The horizon projection.
         * @param headingOffset The offset, in degrees, of the heading ticks with respect to true heading.
         */
        drawTicks(context, projection, headingOffset) {
            const showLabels = this.props.showHeadingLabels.get();
            for (let i = 0; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                this.drawTick(context, projection, node.projected, node.heading, headingOffset, i % HorizonLine.LABEL_FACTOR === 0 && showLabels ? this.props.fontVirtualSize : undefined, this.props.labelVirtualOffset);
            }
        }
        /**
         * Draws a heading tick on a canvas.
         * @param context The canvas rendering context to which to draw the tick.
         * @param projection The horizon projection.
         * @param originProjected The projected position of the origin of the tick.
         * @param heading The heading of the tick.
         * @param headingOffset The offset, in degrees, of the heading ticks with respect to true heading.
         * @param fontVirtualSize The virtual font size of the tick's heading label, or `undefined` if there is no label.
         * @param labelVirtualOffset The virtual offset of the tick's heading label, or `undefined` if there is no label.
         */
        drawTick(context, projection, originProjected, heading, headingOffset, fontVirtualSize, labelVirtualOffset) {
            if (!projection.isInProjectedBounds(originProjected, this.bounds.get())) {
                return;
            }
            const endProjected = projection.projectRelativeEuclidean(heading + headingOffset, this.props.ringRadius, this.props.headingTickVirtualLength, HorizonLine.vec2Cache[0]);
            context.beginPath();
            context.moveTo(originProjected[0], originProjected[1]);
            context.lineTo(endProjected[0], endProjected[1]);
            this.strokePath(context, this.tickStrokeWidth, this.tickStrokeColor);
            if (fontVirtualSize !== undefined && labelVirtualOffset !== undefined) {
                const text = (heading === 0 ? 360 : heading).toFixed(0);
                const labelOriginProjected = projection.projectRelativeEuclidean(heading + headingOffset, this.props.ringRadius, this.props.headingTickVirtualLength + labelVirtualOffset, HorizonLine.vec2Cache[0]);
                const labelTopProjected = projection.projectRelativeEuclidean(heading + headingOffset, this.props.ringRadius, this.props.headingTickVirtualLength + labelVirtualOffset + fontVirtualSize, HorizonLine.vec2Cache[1]);
                const delta = msfssdk.Vec2Math.sub(labelTopProjected, labelOriginProjected, HorizonLine.vec2Cache[1]);
                context.translate(labelOriginProjected[0], labelOriginProjected[1]);
                context.rotate(-projection.getRoll() * Avionics.Utils.DEG2RAD);
                context.translate(-labelOriginProjected[0], -labelOriginProjected[1]);
                context.font = `${Math.max(msfssdk.Vec2Math.abs(delta), this.props.minFontSize)}px ${this.props.font}`;
                context.lineWidth = this.fontOutlineWidth * 2;
                context.strokeStyle = this.fontOutlineColor;
                context.strokeText(text, labelOriginProjected[0], labelOriginProjected[1]);
                context.fillText(text, labelOriginProjected[0], labelOriginProjected[1]);
                context.resetTransform();
            }
        }
        /**
         * Strokes a path on a canvas.
         * @param context The canvas rendering context with which to stroke the path.
         * @param strokeWidth The width of the stroke.
         * @param strokeStyle The style of the stroke.
         * @param outlineWidth The outline width of the stroke. Defaults to `0`.
         * @param outlineStyle The outline style of the stroke. Required to draw an outline.
         */
        strokePath(context, strokeWidth, strokeStyle, outlineWidth = 0, outlineStyle) {
            if (outlineWidth > 0 && outlineStyle !== undefined) {
                context.lineWidth = strokeWidth + 2 * outlineWidth;
                context.strokeStyle = outlineStyle;
                context.stroke();
            }
            context.lineWidth = strokeWidth;
            context.strokeStyle = strokeStyle;
            context.stroke();
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent(msfssdk.HorizonSyncedCanvasLayer, { ref: this.canvasLayerRef, projection: this.props.projection }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.showLabelsSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.useMagneticSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.canvasLayerRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    HorizonLine.TICK_INCREMENT = 10; // degrees per tick
    HorizonLine.TICK_COUNT = 360 / HorizonLine.TICK_INCREMENT;
    HorizonLine.LABEL_FACTOR = 3; // number of ticks per label
    HorizonLine.BOUNDS_BUFFER = 20; // pixels
    HorizonLine.DEFAULT_LINE_STROKE_WIDTH = 2; // pixels
    HorizonLine.DEFAULT_LINE_STROKE_COLOR = 'white';
    HorizonLine.DEFAULT_LINE_OUTLINE_WIDTH = 1; // pixels
    HorizonLine.DEFAULT_LINE_OUTLINE_COLOR = 'black';
    HorizonLine.DEFAULT_TICK_STROKE_WIDTH = 1; // pixels
    HorizonLine.DEFAULT_TICK_STROKE_COLOR = 'white';
    HorizonLine.DEFAULT_FONT_COLOR = 'white';
    HorizonLine.DEFAULT_FONT_OUTLINE_WIDTH = 1;
    HorizonLine.DEFAULT_FONT_OUTLINE_COLOR = 'black';
    HorizonLine.vec2Cache = [msfssdk.Vec2Math.create(), msfssdk.Vec2Math.create()];

    /**
     * A next-generation (NXi, G3000, etc) Garmin PFD horizon display. Includes an artificial horizon, attitude indicator,
     * aircraft symbol, flight director, and synthetic vision technology (SVT) display.
     */
    class HorizonDisplay extends msfssdk.DisplayComponent {
        constructor() {
            var _a, _b;
            super(...arguments);
            this.horizonRef = msfssdk.FSComponent.createRef();
            this.projectionParams = {
                position: new msfssdk.GeoPoint(0, 0),
                altitude: 0,
                heading: 0,
                pitch: 0,
                roll: 0
            };
            this.ahrsIndex = msfssdk.SubscribableUtils.toSubscribable(this.props.ahrsIndex, true);
            this.position = msfssdk.ConsumerSubject.create(null, new LatLongAlt(0, 0, 0));
            this.heading = msfssdk.ConsumerSubject.create(null, 0);
            this.pitch = msfssdk.ConsumerSubject.create(null, 0);
            this.roll = msfssdk.ConsumerSubject.create(null, 0);
            this.paramSubjects = [
                this.position,
                this.heading,
                this.pitch,
                this.roll
            ];
            this.ahrsState = msfssdk.ConsumerSubject.create(null, { previous: undefined, current: msfssdk.AvionicsSystemState.On });
            this.isAhrsOn = msfssdk.Subject.create(true);
            this.isSvtEnabled = msfssdk.MappedSubject.create(([isAhrsOn, svtEnabledSetting]) => isAhrsOn && svtEnabledSetting, this.isAhrsOn, this.props.svtSettingManager.getSetting('svtEnabled'));
            this.normalFov = (_a = this.props.normalFov) !== null && _a !== void 0 ? _a : HorizonDisplay.DEFAULT_NORMAL_FOV;
            this.extendedFov = (_b = this.props.extendedFov) !== null && _b !== void 0 ? _b : HorizonDisplay.DEFAULT_EXTENDED_FOV;
            this.fov = this.props.useExtendedFov
                ? this.isSvtEnabled.map(isEnabled => isEnabled ? HorizonDisplay.BING_FOV : this.extendedFov)
                : this.isSvtEnabled.map(isEnabled => isEnabled ? HorizonDisplay.BING_FOV : this.normalFov);
            this.nonSvtFovEndpoints = msfssdk.VecNMath.create(4, 0.5, 0, 0.5, 1);
            this.svtFovEndpoints = msfssdk.VecNSubject.createFromVector(msfssdk.VecNMath.create(4, 0.5, 0, 0.5, 1));
            this.fovEndpoints = msfssdk.VecNSubject.createFromVector(msfssdk.VecNMath.create(4, 0.5, 0, 0.5, 1));
            this.isAlive = true;
            this.isAwake = true;
            this.updateFreq = msfssdk.SubscribableUtils.toSubscribable(this.props.updateFreq, true);
            this.updateCycleHandler = this.onUpdated.bind(this);
        }
        /** @inheritdoc */
        onAfterRender() {
            var _a;
            this.horizonRef.instance.projection.onChange(this.onProjectionChanged.bind(this));
            if (!this.isAwake) {
                this.horizonRef.instance.sleep();
            }
            const sub = this.props.bus.getSubscriber();
            this.position.sub(pos => {
                this.projectionParams.position.set(pos.lat, pos.long);
                this.projectionParams.altitude = pos.alt;
            }, true);
            this.headingSub = this.heading.sub(heading => {
                this.projectionParams.heading = heading;
            }, true);
            this.pitchSub = this.pitch.sub(pitch => {
                this.projectionParams.pitch = -pitch;
            }, true);
            this.rollSub = this.roll.sub(roll => {
                this.projectionParams.roll = -roll;
            }, true);
            this.ahrsState.sub(this.onAhrsStateChanged.bind(this), true);
            this.isAhrsOn.sub(value => {
                var _a, _b, _c, _d, _e, _f;
                if (value) {
                    (_a = this.headingSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                    (_b = this.pitchSub) === null || _b === void 0 ? void 0 : _b.resume(true);
                    (_c = this.rollSub) === null || _c === void 0 ? void 0 : _c.resume(true);
                }
                else {
                    (_d = this.headingSub) === null || _d === void 0 ? void 0 : _d.pause();
                    (_e = this.pitchSub) === null || _e === void 0 ? void 0 : _e.pause();
                    (_f = this.rollSub) === null || _f === void 0 ? void 0 : _f.pause();
                    this.projectionParams.heading = 0;
                    this.projectionParams.pitch = 0;
                    this.projectionParams.roll = 0;
                }
            }, true);
            this.position.setConsumer(sub.on('gps-position'));
            this.ahrsIndexSub = this.ahrsIndex.sub(index => {
                this.heading.setConsumer(sub.on(`ahrs_hdg_deg_true_${index}`));
                this.pitch.setConsumer(sub.on(`ahrs_pitch_deg_${index}`));
                this.roll.setConsumer(sub.on(`ahrs_roll_deg_${index}`));
                this.ahrsState.setConsumer(sub.on(`ahrs_state_${index}`));
            }, true);
            const svtEndpointsPipe = this.svtFovEndpoints.pipe(this.fovEndpoints, true);
            this.isSvtEnabled.sub(isEnabled => {
                if (isEnabled) {
                    svtEndpointsPipe.resume(true);
                }
                else {
                    svtEndpointsPipe.pause();
                    this.fovEndpoints.set(this.nonSvtFovEndpoints);
                }
            }, true);
            this.recomputeSvtFovEndpoints(this.horizonRef.instance.projection);
            this.updateFreqSub = (_a = this.updateFreq) === null || _a === void 0 ? void 0 : _a.sub(freq => {
                var _a;
                (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
                this.updateCycleSub = this.props.bus.getSubscriber()
                    .on('realTime')
                    .atFrequency(freq)
                    .handle(this.updateCycleHandler, !this.isAwake);
            }, true);
        }
        /**
         * Responds to AHRS system state events.
         * @param state An AHRS system state event.
         */
        onAhrsStateChanged(state) {
            if (state.previous === undefined && state.current !== msfssdk.AvionicsSystemState.Off) {
                this.isAhrsOn.set(true);
            }
            else {
                this.isAhrsOn.set(state.current === msfssdk.AvionicsSystemState.On);
            }
        }
        /**
         * Wakes this horizon display. While awake, this display will be updated.
         * @throws Error if this horizon display is dead.
         */
        wake() {
            var _a, _b;
            if (!this.isAlive) {
                throw new Error('HorizonDisplay: cannot wake a dead display');
            }
            if (this.isAwake) {
                return;
            }
            this.paramSubjects.forEach(subject => { subject.resume(); });
            (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.wake();
            (_b = this.updateCycleSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
        /**
         * Puts this horizon display to sleep. While asleep, this display will not be updated.
         * @throws Error if this horizon display is dead.
         */
        sleep() {
            var _a, _b;
            if (!this.isAlive) {
                throw new Error('HorizonDisplay: cannot sleep a dead display');
            }
            if (!this.isAwake) {
                return;
            }
            this.paramSubjects.forEach(subject => { subject.pause(); });
            (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.sleep();
            (_b = this.updateCycleSub) === null || _b === void 0 ? void 0 : _b.pause();
        }
        /**
         * Responds to changes in this horizon display's projection.
         * @param projection This display's horizon projection.
         * @param changeFlags The types of changes made to the projection.
         */
        onProjectionChanged(projection, changeFlags) {
            if (msfssdk.BitFlags.isAny(changeFlags, msfssdk.HorizonProjectionChangeType.ProjectedOffset
                | msfssdk.HorizonProjectionChangeType.ProjectedSize)) {
                this.recomputeSvtFovEndpoints(projection);
            }
        }
        /**
         * Recomputes the endpoints at which the field of view of this display's projection is measured when synthetic
         * vision is enabled.
         * @param projection This display's horizon projection.
         */
        recomputeSvtFovEndpoints(projection) {
            const projectedSize = projection.getProjectedSize();
            const projectedOffset = projection.getProjectedOffset();
            const offsetCenterProjected = projection.getOffsetCenterProjected();
            // If there is a projected offset, then the Bing texture for synthetic vision needs to be overdrawn. This reduces
            // the effective FOV of the Bing texture if it is overdrawn vertically. In order to match this reduced FOV with the
            // horizon projection, we need to adjust the FOV endpoints so that they span the height of the entire Bing texture.
            const yOverdraw = Math.abs(projectedOffset[1]);
            const bingHeight = projectedSize[1] + yOverdraw * 2;
            const top = offsetCenterProjected[1] - bingHeight / 2;
            const bottom = top + bingHeight;
            this.svtFovEndpoints.set(0.5, top / projectedSize[1], 0.5, bottom / projectedSize[1]);
        }
        /**
         * This method is called every update cycle.
         * @param time The current time, as a UNIX timestamp in milliseconds.
         */
        onUpdated(time) {
            this.horizonRef.instance.projection.set(this.projectionParams);
            this.horizonRef.instance.update(time);
        }
        /** @inheritdoc */
        render() {
            const projection = new msfssdk.HorizonProjection(100, 100, 60);
            return (msfssdk.FSComponent.buildComponent(msfssdk.HorizonComponent, { ref: this.horizonRef, projection: projection, projectedSize: this.props.projectedSize, fov: this.fov, fovEndpoints: this.fovEndpoints, projectedOffset: this.props.projectedOffset, class: this.props.class },
                msfssdk.FSComponent.buildComponent(ArtificialHorizon, { projection: projection, bus: this.props.bus, show: msfssdk.MappedSubject.create(([isAhrsOn, isSvtEnabled]) => isAhrsOn && !isSvtEnabled, this.isAhrsOn, this.isSvtEnabled) }),
                msfssdk.FSComponent.buildComponent(SyntheticVision, Object.assign({ projection: projection, bingId: this.props.bingId, isEnabled: this.isSvtEnabled, showHeadingLabels: this.props.svtSettingManager.getSetting('svtHeadingLabelShow') }, this.props.svtOptions)),
                msfssdk.FSComponent.buildComponent(AttitudeIndicator, Object.assign({ projection: projection, bus: this.props.bus, ahrsIndex: this.ahrsIndex, isSVTEnabled: this.isSvtEnabled, pitchLadderOptions: {
                        svtDisabledStyles: this.props.useExtendedFov ? HorizonDisplay.getExtendedFovPitchLadderStyles() : HorizonDisplay.getNormalFovPitchLadderStyles(),
                        svtEnabledStyles: HorizonDisplay.getNormalFovPitchLadderStyles()
                    } }, this.props.attitudeIndicatorOptions)),
                msfssdk.FSComponent.buildComponent(FlightPathMarker, { projection: projection, bus: this.props.bus, show: this.isSvtEnabled }),
                msfssdk.FSComponent.buildComponent(FlightDirector, Object.assign({ projection: projection, bus: this.props.bus, show: this.isAhrsOn }, this.props.flightDirectorOptions)),
                msfssdk.FSComponent.buildComponent(AttitudeAircraftSymbol, { projection: projection, show: msfssdk.Subject.create(true) })));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d;
            super.destroy();
            this.isAlive = false;
            this.isSvtEnabled.destroy();
            this.paramSubjects.forEach(subject => { subject.destroy(); });
            this.ahrsState.destroy();
            (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.updateCycleSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.ahrsIndexSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.horizonRef.getOrDefault()) === null || _d === void 0 ? void 0 : _d.destroy();
        }
        /**
         * Gets pitch ladder styling options for a normal field of view.
         * @returns Pitch ladder styling options for a normal field of view.
         */
        static getNormalFovPitchLadderStyles() {
            return {
                minorLineIncrement: 2.5,
                mediumLineFactor: 2,
                majorLineFactor: 2,
                minorLineMaxPitch: 20,
                mediumLineMaxPitch: 30,
                minorLineShowNumber: false,
                mediumLineShowNumber: true,
                majorLineShowNumber: true,
                minorLineLength: 25,
                mediumLineLength: 50,
                majorLineLength: 100
            };
        }
        /**
         * Gets pitch ladder styling options for an extended field of view.
         * @returns Pitch ladder styling options for an extended field of view.
         */
        static getExtendedFovPitchLadderStyles() {
            return {
                minorLineIncrement: 2.5,
                mediumLineFactor: 2,
                majorLineFactor: 2,
                minorLineMaxPitch: 20,
                mediumLineMaxPitch: 30,
                minorLineShowNumber: false,
                mediumLineShowNumber: false,
                majorLineShowNumber: true,
                minorLineLength: 25,
                mediumLineLength: 50,
                majorLineLength: 100
            };
        }
    }
    HorizonDisplay.BING_FOV = 50; // degrees
    HorizonDisplay.DEFAULT_NORMAL_FOV = 55; // degrees
    HorizonDisplay.DEFAULT_EXTENDED_FOV = 110; // degrees

    /**
     * The operating mode of a Garmin weather radar.
     */
    exports.WeatherRadarOperatingMode = void 0;
    (function (WeatherRadarOperatingMode) {
        WeatherRadarOperatingMode["Standby"] = "Standby";
        WeatherRadarOperatingMode["Weather"] = "Weather";
    })(exports.WeatherRadarOperatingMode || (exports.WeatherRadarOperatingMode = {}));
    /**
     * The scan mode of a Garmin weather radar.
     */
    exports.WeatherRadarScanMode = void 0;
    (function (WeatherRadarScanMode) {
        WeatherRadarScanMode["Horizontal"] = "Horizontal";
        WeatherRadarScanMode["Vertical"] = "Vertical";
    })(exports.WeatherRadarScanMode || (exports.WeatherRadarScanMode = {}));
    /**
     * A Garmin weather radar display.
     */
    class WeatherRadar extends msfssdk.DisplayComponent {
        constructor() {
            var _a, _b, _c, _d;
            super(...arguments);
            this.bingRef = msfssdk.FSComponent.createRef();
            this.rangeLabelRefs = Array.from({ length: 4 }, () => msfssdk.FSComponent.createRef());
            this.rootStyle = msfssdk.ObjectSubject.create({
                width: '0px',
                height: '0px',
                '--weather-radar-arc-origin-x': '0px',
                '--weather-radar-arc-origin-y': '0px',
                '--weather-radar-arc-radius': '0px',
                '--weather-radar-arc-left': '0px',
                '--weather-radar-arc-top': '0px',
                '--weather-radar-arc-right': '0px',
                '--weather-radar-arc-bottom': '0px',
            });
            this.bingStyle = msfssdk.ObjectSubject.create({
                display: 'none',
                position: 'absolute',
                left: '0',
                top: '0',
                width: '0px',
                height: '0px'
            });
            this.rangeLabelStyles = Array.from({ length: 4 }, () => msfssdk.ObjectSubject.create({
                position: 'absolute',
                left: '0',
                right: '0',
                top: '0',
                bottom: '0'
            }));
            this.verticalRangeLineStyle = msfssdk.ObjectSubject.create({
                display: 'none'
            });
            this.verticalRangeLabelTopStyle = msfssdk.ObjectSubject.create({
                display: 'none',
                position: 'absolute',
                left: '0',
                bottom: '0'
            });
            this.verticalRangeLabelBottomStyle = msfssdk.ObjectSubject.create({
                display: 'none',
                position: 'absolute',
                left: '0',
                top: '0'
            });
            this.referenceLineContainerStyle = msfssdk.ObjectSubject.create({
                display: 'none',
                position: 'absolute',
                left: '0',
                top: '0',
                width: '0px',
                height: '0px',
                transform: 'rotate3d(0, 0, 1, 0deg)',
                'transform-origin': '0% 50%'
            });
            this.rootCssClass = msfssdk.SetSubject.create(['weather-radar']);
            this.wxrModes = {
                [exports.WeatherRadarScanMode.Horizontal]: { mode: EWeatherRadar.HORIZONTAL, arcRadians: msfssdk.MathUtils.HALF_PI },
                [exports.WeatherRadarScanMode.Vertical]: { mode: EWeatherRadar.VERTICAL, arcRadians: Math.PI / 3 }
            };
            this.svgPathStream = new msfssdk.SvgPathStream(0.1);
            this.svgTransformPathStream = new msfssdk.AffineTransformPathStream(this.svgPathStream);
            this.horizontalScanAngularWidth = msfssdk.SubscribableUtils.toSubscribable(this.props.horizontalScanAngularWidth, true);
            this.verticalScanAngularWidth = msfssdk.SubscribableUtils.toSubscribable(this.props.verticalScanAngularWidth, true);
            this.size = msfssdk.SubscribableUtils.toSubscribable(this.props.size, true);
            this.horizontalScanPadding = msfssdk.SubscribableUtils.toSubscribable((_a = this.props.horizontalScanPadding) !== null && _a !== void 0 ? _a : WeatherRadar.DEFAULT_PADDING, true);
            this.verticalScanPadding = msfssdk.SubscribableUtils.toSubscribable((_b = this.props.verticalScanPadding) !== null && _b !== void 0 ? _b : WeatherRadar.DEFAULT_PADDING, true);
            this.verticalRangeLineExtend = msfssdk.SubscribableUtils.toSubscribable((_c = this.props.verticalRangeLineExtend) !== null && _c !== void 0 ? _c : WeatherRadar.DEFAULT_VERTICAL_RANGE_LINE_EXTEND, true);
            this.referenceLineAngularWidth = ((_d = this.props.referenceLineAngularWidth) !== null && _d !== void 0 ? _d : WeatherRadar.DEFAULT_BEARING_LINE_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
            /** The [x, y] position, in pixels, of the center of the weather radar arc. */
            this.arcOrigin = msfssdk.Vec2Math.create();
            /** The radius, in pixels, of the weather radar arc. */
            this.arcRadius = 0;
            /** The angular width, in radians, of the weather radar arc. */
            this.arcAngularWidth = 0;
            /** The bounding rect of the weather radar arc. */
            this.arcBounds = msfssdk.VecNMath.create(4);
            this.overlayViewBox = msfssdk.Subject.create('0 0 0 0');
            this.boundaryLinePath = msfssdk.Subject.create('');
            this.rangeLinesPath = msfssdk.Subject.create('');
            this.referenceLineContainerViewBox = msfssdk.Subject.create('0 0 0 0');
            this.referenceLinePath = msfssdk.Subject.create('');
            this.verticalRangeLinesPath = msfssdk.Subject.create('');
            this.positionSource = msfssdk.ConsumerSubject.create(null, new LatLongAlt(), (a, b) => a.lat === b.lat && a.long === b.long);
            this.position = this.positionSource.map(lla => new LatLong(lla.lat, lla.long));
            this.wxrMode = msfssdk.Subject.create(this.wxrModes[exports.WeatherRadarScanMode.Horizontal], (a, b) => a.mode === b.mode && a.arcRadians === b.arcRadians);
            this.ranges = Array.from({ length: 4 }, () => msfssdk.NumberUnitSubject.create(msfssdk.UnitType.NMILE.createNumber(0)));
            this.verticalRangeTop = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.FOOT.createNumber(0));
            this.verticalRangeBottom = msfssdk.NumberUnitSubject.create(msfssdk.UnitType.FOOT.createNumber(0));
            this.isReferenceLineVisible = msfssdk.MappedSubject.create(([showBearing, showTilt, scanMode]) => {
                return scanMode === exports.WeatherRadarScanMode.Horizontal ? showBearing : showTilt;
            }, this.props.showBearingLine, this.props.showTiltLine, this.props.scanMode);
            this.needResize = false;
            this.needReposition = false;
            this.needRedrawOverlay = false;
            this.needRedrawVerticalRangeLines = false;
            this.needUpdateBing = false;
            this.needUpdateReferenceLineVisibility = false;
            this.needRotateReferenceLine = false;
            this.isAlive = true;
            this.isInit = false;
            this.isAwake = true;
        }
        /** @inheritdoc */
        onAfterRender() {
            this.sizeSub = this.size.sub(() => { this.needResize = true; }, true);
            this.horizontalScanPaddingSub = this.horizontalScanPadding.sub(() => {
                this.needReposition || (this.needReposition = this.props.scanMode.get() === exports.WeatherRadarScanMode.Horizontal);
            }, true);
            this.verticalScanPaddingSub = this.verticalScanPadding.sub(() => {
                this.needReposition || (this.needReposition = this.props.scanMode.get() === exports.WeatherRadarScanMode.Vertical);
            }, true);
            this.verticalRangeLineExtendSub = this.verticalRangeLineExtend.sub(() => {
                this.needRedrawVerticalRangeLines || (this.needRedrawVerticalRangeLines = this.props.scanMode.get() === exports.WeatherRadarScanMode.Vertical);
            }, true);
            this.operatingModeSub = this.props.operatingMode.sub(() => { this.needUpdateBing = true; }, true);
            this.isDataFailedSub = this.props.isDataFailed.sub(() => { this.needUpdateBing = true; }, true);
            this.scanModeSub = this.props.scanMode.sub(mode => {
                if (mode === exports.WeatherRadarScanMode.Horizontal) {
                    this.rootCssClass.delete('scan-vertical');
                    this.rootCssClass.add('scan-horizontal');
                }
                else {
                    this.rootCssClass.delete('scan-horizontal');
                    this.rootCssClass.add('scan-vertical');
                }
                this.needReposition = true;
                this.needRotateReferenceLine = true;
            }, true);
            this.horizontalScanAngularWidthSub = this.horizontalScanAngularWidth.sub(() => {
                this.needReposition || (this.needReposition = this.props.scanMode.get() === exports.WeatherRadarScanMode.Horizontal);
            }, true);
            this.verticalScanAngularWidthSub = this.verticalScanAngularWidth.sub(() => {
                this.needReposition || (this.needReposition = this.props.scanMode.get() === exports.WeatherRadarScanMode.Vertical);
            }, true);
            this.rangeSub = this.props.range.sub(range => {
                for (let i = 0; i < this.ranges.length; i++) {
                    this.ranges[i].set(range.asUnit(msfssdk.UnitType.NMILE) * (i + 1) / 4);
                }
                this.needUpdateBing = true;
                this.needRedrawVerticalRangeLines || (this.needRedrawVerticalRangeLines = this.props.scanMode.get() === exports.WeatherRadarScanMode.Vertical);
            }, true);
            this.positionSource.setConsumer(this.props.bus.getSubscriber().on('gps-position'));
            this.position.sub(() => { this.needUpdateBing = true; }, true);
            this.isReferenceLineVisible.sub(() => {
                this.needUpdateReferenceLineVisibility = true;
            }, true);
            this.isInit = true;
            if (!this.isAwake) {
                this.bingRef.instance.sleep();
            }
        }
        /**
         * Wakes this weather radar. Once awake, this radar will be able to update.
         * @throws Error if this weather radar is dead.
         */
        wake() {
            if (!this.isAlive) {
                throw new Error('WeatherRadar: cannot wake a dead component');
            }
            if (this.isAwake) {
                return;
            }
            this.isAwake = true;
            if (!this.isInit) {
                return;
            }
            this.bingRef.instance.wake();
        }
        /**
         * Puts this weather radar to sleep. Once asleep, this radar will not be able to update until it is awakened.
         * @throws Error if this weather radar is dead.
         */
        sleep() {
            if (!this.isAlive) {
                throw new Error('WeatherRadar: cannot sleep a dead component');
            }
            if (!this.isAwake) {
                return;
            }
            this.isAwake = false;
            if (!this.isInit) {
                return;
            }
            this.bingRef.instance.sleep();
        }
        /**
         * Updates this weather radar.
         * @throws Error if this weather radar is dead.
         */
        update() {
            if (!this.isAlive) {
                throw new Error('WeatherRadar: cannot update a dead component');
            }
            if (!this.isInit || !this.isAwake) {
                return;
            }
            if (this.needResize) {
                this.resizeContainer(this.size.get());
                this.needReposition = true;
            }
            if (this.needReposition) {
                this.recomputePositioning();
                this.repositionBing();
                this.needRedrawOverlay = true;
            }
            if (this.needRedrawOverlay) {
                this.redrawOverlay();
            }
            else if (this.needRedrawVerticalRangeLines) {
                this.drawVerticalRangeLines(this.size.get(), this.arcOrigin, this.arcRadius, this.arcAngularWidth, this.props.range.get().asUnit(msfssdk.UnitType.FOOT));
            }
            if (this.needUpdateBing) {
                if (!this.props.isDataFailed.get() && this.props.operatingMode.get() === exports.WeatherRadarOperatingMode.Weather) {
                    this.bingStyle.set('display', '');
                    this.bingRef.instance.setPositionRadius(this.position.get(), this.props.range.get().asUnit(msfssdk.UnitType.METER));
                }
                else {
                    this.bingStyle.set('display', 'none');
                }
            }
            if (this.needUpdateReferenceLineVisibility) {
                this.referenceLineContainerStyle.set('display', this.isReferenceLineVisible.get() ? '' : 'none');
            }
            if (this.needRotateReferenceLine) {
                this.referenceLineContainerStyle.set('transform', `rotate3d(0, 0, 1, ${this.props.scanMode.get() === exports.WeatherRadarScanMode.Horizontal ? -90 : 0}deg)`);
            }
            this.needResize = false;
            this.needReposition = false;
            this.needRedrawOverlay = false;
            this.needRedrawVerticalRangeLines = false;
            this.needUpdateBing = false;
            this.needUpdateReferenceLineVisibility = false;
            this.needRotateReferenceLine = false;
        }
        /**
         * Resizes this weather radar's root container.
         * @param size The size of the root container.
         */
        resizeContainer(size) {
            this.rootStyle.set('width', `${size[0]}px`);
            this.rootStyle.set('height', `${size[1]}px`);
        }
        /**
         * Recomputes the size and positioning of this weather radar's radar arc.
         */
        recomputePositioning() {
            var _a, _b, _c;
            const scanMode = this.props.scanMode.get();
            const size = this.size.get();
            const width = size[0], height = size[1];
            this.arcAngularWidth = scanMode === exports.WeatherRadarScanMode.Horizontal ? this.horizontalScanAngularWidth.get() : this.verticalScanAngularWidth.get();
            const aspectRatio = 1 / (2 * Math.sin(this.arcAngularWidth / 2));
            this.wxrModes[scanMode].arcRadians = this.arcAngularWidth;
            this.wxrMode.set(this.wxrModes[scanMode]);
            if (scanMode === exports.WeatherRadarScanMode.Horizontal) {
                const padding = this.horizontalScanPadding.get();
                this.arcRadius = Math.max(0, Math.min(height - padding[1] - padding[3], (width - padding[0] - padding[2]) * aspectRatio));
                msfssdk.Vec2Math.set((padding[0] + width - padding[2]) / 2, height - padding[3], this.arcOrigin);
                const arcWidth = this.arcRadius / aspectRatio;
                msfssdk.VecNMath.set(this.arcBounds, this.arcOrigin[0] - arcWidth / 2, this.arcOrigin[1] - this.arcRadius, this.arcOrigin[0] + arcWidth / 2, this.arcOrigin[1]);
            }
            else {
                const padding = this.verticalScanPadding.get();
                this.arcRadius = Math.max(0, Math.min((width - padding[0] - padding[2]), (height - padding[1] - padding[3]) * aspectRatio));
                msfssdk.Vec2Math.set(padding[0], (padding[1] + height - padding[3]) / 2, this.arcOrigin);
                const arcHeight = this.arcRadius / aspectRatio;
                msfssdk.VecNMath.set(this.arcBounds, this.arcOrigin[0], this.arcOrigin[1] - arcHeight / 2, this.arcOrigin[0] + this.arcRadius, this.arcOrigin[1] + arcHeight / 2);
            }
            this.rootStyle.set('--weather-radar-arc-origin-x', `${this.arcOrigin[0]}px`);
            this.rootStyle.set('--weather-radar-arc-origin-y', `${this.arcOrigin[1]}px`);
            this.rootStyle.set('--weather-radar-arc-radius', `${this.arcRadius}px`);
            this.rootStyle.set('--weather-radar-arc-left', `${this.arcBounds[0]}px`);
            this.rootStyle.set('--weather-radar-arc-top', `${this.arcBounds[1]}px`);
            this.rootStyle.set('--weather-radar-arc-right', `${this.arcBounds[2]}px`);
            this.rootStyle.set('--weather-radar-arc-bottom', `${this.arcBounds[3]}px`);
            (_a = this.props.arcOrigin) === null || _a === void 0 ? void 0 : _a.set(this.arcOrigin);
            (_b = this.props.arcRadius) === null || _b === void 0 ? void 0 : _b.set(this.arcRadius);
            (_c = this.props.arcBounds) === null || _c === void 0 ? void 0 : _c.set(this.arcBounds);
        }
        /**
         * Repositions this weather radar's Bing component.
         */
        repositionBing() {
            const size = this.arcRadius * 2;
            this.bingStyle.set('width', `${size}px`);
            this.bingStyle.set('height', `${size}px`);
            this.bingStyle.set('left', `${this.arcOrigin[0] - size / 2}px`);
            this.bingStyle.set('top', `${this.arcOrigin[1] - size / 2}px`);
        }
        /**
         * Redraws this weather radar's overlay elements, including the radar arc boundary lines, range lines, and reference
         * line.
         */
        redrawOverlay() {
            const size = this.size.get();
            const isScanHorizontal = this.props.scanMode.get() === exports.WeatherRadarScanMode.Horizontal;
            this.overlayViewBox.set(`0 0 ${size[0]} ${size[1]}`);
            const facing = isScanHorizontal ? -msfssdk.MathUtils.HALF_PI : 0;
            this.drawBoundaryLines(this.arcOrigin, this.arcRadius, facing, this.arcAngularWidth);
            this.drawRangeLines(size, this.arcOrigin, this.arcRadius, facing, this.arcAngularWidth);
            this.drawReferenceLine(this.arcOrigin, this.arcRadius);
            if (isScanHorizontal) {
                this.hideVerticalRangeLines();
            }
            else {
                this.drawVerticalRangeLines(size, this.arcOrigin, this.arcRadius, this.arcAngularWidth, this.props.range.get().asUnit(msfssdk.UnitType.FOOT));
            }
        }
        /**
         * Draws radar arc boundary lines.
         * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
         * @param arcRadius The radius of the radar arc, in pixels.
         * @param facing The facing angle of the radar arc, in radians. An angle of `0` points in the positive x-direction,
         * with positive angles proceeding clockwise.
         * @param arcAngularWidth The angular width of the radar arc, in radians.
         */
        drawBoundaryLines(arcOrigin, arcRadius, facing, arcAngularWidth) {
            this.svgTransformPathStream
                .resetTransform()
                .addRotation(facing - arcAngularWidth / 2)
                .addTranslation(arcOrigin[0], arcOrigin[1]);
            this.svgTransformPathStream.beginPath();
            this.svgTransformPathStream.moveTo(arcRadius, 0);
            this.svgTransformPathStream.lineTo(0, 0);
            this.svgTransformPathStream.addRotation(arcAngularWidth, 'before');
            this.svgTransformPathStream.lineTo(arcRadius, 0);
            this.boundaryLinePath.set(this.svgPathStream.getSvgPath());
        }
        /**
         * Draws radar arc range lines.
         * @param size The size of this weather radar display, as `[width, height]` in pixels.
         * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
         * @param arcRadius The radius of the radar arc, in pixels.
         * @param facing The facing angle of the radar arc, in radians. An angle of `0` points in the positive x-direction,
         * with positive angles proceeding clockwise.
         * @param arcAngularWidth The angular width of the radar arc, in radians.
         */
        drawRangeLines(size, arcOrigin, arcRadius, facing, arcAngularWidth) {
            const leftAngle = facing - arcAngularWidth / 2;
            const rightAngle = leftAngle + arcAngularWidth;
            // set anchor point for range labels based on quadrant they appear in
            const useLeft = Math.sin(rightAngle) <= 0;
            const useTop = Math.cos(rightAngle) >= 0;
            const labelXToSet = useLeft ? 'left' : 'right';
            const labelXScale = useLeft ? 1 : -1;
            const labelXOffset = useLeft ? 0 : size[0];
            const labelYToSet = useTop ? 'top' : 'bottom';
            const labelYScale = useTop ? 1 : -1;
            const labelYOffset = useTop ? 0 : size[1];
            const labelXToClear = useLeft ? 'right' : 'left';
            const labelYToClear = useTop ? 'bottom' : 'top';
            const leftEndpoint = msfssdk.Vec2Math.setFromPolar(1, leftAngle, WeatherRadar.vec2Cache[0]);
            const rightEndpoint = msfssdk.Vec2Math.setFromPolar(1, rightAngle, WeatherRadar.vec2Cache[1]);
            this.svgPathStream.beginPath();
            for (let i = 4; i > 0; i--) {
                const radius = arcRadius * i / 4;
                this.svgPathStream.moveTo(leftEndpoint[0] * radius + arcOrigin[0], leftEndpoint[1] * radius + arcOrigin[1]);
                this.svgPathStream.arc(arcOrigin[0], arcOrigin[1], radius, leftAngle, rightAngle);
                const labelStyle = this.rangeLabelStyles[i - 1];
                labelStyle.set(labelXToSet, `${(rightEndpoint[0] * radius + arcOrigin[0]) * labelXScale + labelXOffset}px`);
                labelStyle.set(labelYToSet, `${(rightEndpoint[1] * radius + arcOrigin[1]) * labelYScale + labelYOffset}px`);
                labelStyle.set(labelXToClear, '');
                labelStyle.set(labelYToClear, '');
            }
            this.rangeLinesPath.set(this.svgPathStream.getSvgPath());
        }
        /**
         * Draws a reference line.
         * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
         * @param arcRadius The radius of the radar arc, in pixels.
         */
        drawReferenceLine(arcOrigin, arcRadius) {
            this.referenceLineContainerViewBox.set(`0 ${-arcRadius / 2} ${arcRadius} ${arcRadius}`);
            this.referenceLineContainerStyle.set('left', `${arcOrigin[0]}px`);
            this.referenceLineContainerStyle.set('top', `${arcOrigin[1] - arcRadius / 2}px`);
            this.referenceLineContainerStyle.set('width', `${arcRadius}px`);
            this.referenceLineContainerStyle.set('height', `${arcRadius}px`);
            this.svgTransformPathStream
                .resetTransform()
                .addRotation(-this.referenceLineAngularWidth / 2);
            this.svgTransformPathStream.beginPath();
            this.svgTransformPathStream.moveTo(arcRadius * 0.15, 0);
            this.svgTransformPathStream.lineTo(arcRadius, 0);
            this.svgTransformPathStream.addRotation(this.referenceLineAngularWidth, 'before');
            this.svgTransformPathStream.lineTo(arcRadius, 0);
            this.svgTransformPathStream.lineTo(arcRadius * 0.15, 0);
            this.svgTransformPathStream.closePath();
            this.referenceLinePath.set(this.svgPathStream.getSvgPath());
        }
        /**
         * Draws radar arc vertical range lines.
         * @param size The size of this weather radar display, as `[width, height]` in pixels.
         * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
         * @param arcRadius The radius of the radar arc, in pixels.
         * @param arcAngularWidth The angular width of the radar arc, in radians.
         * @param range The display range of this weather radar.
         */
        drawVerticalRangeLines(size, arcOrigin, arcRadius, arcAngularWidth, range) {
            const maxLineOffset = arcRadius * Math.sin(arcAngularWidth / 2) * 0.75;
            if (maxLineOffset <= 0) {
                this.hideVerticalRangeLines();
                return;
            }
            let height = WeatherRadar.VERTICAL_RANGE_MARKER_HEIGHT;
            let lineOffset = height / range * arcRadius;
            while (lineOffset > maxLineOffset) {
                lineOffset *= 0.5;
                height *= 0.5;
            }
            const lineExtend = this.verticalRangeLineExtend.get();
            const lineStartX = arcOrigin[0] + lineOffset / Math.tan(arcAngularWidth / 2) - lineExtend;
            const lineEndX = arcOrigin[0] + arcRadius + lineExtend;
            this.verticalRangeLinesPath.set(`M ${lineStartX} ${arcOrigin[1] + lineOffset} L ${lineEndX} ${arcOrigin[1] + lineOffset} M ${lineStartX} ${arcOrigin[1] - lineOffset} L ${lineEndX} ${arcOrigin[1] - lineOffset}`);
            this.verticalRangeLineStyle.set('display', '');
            this.verticalRangeLabelTopStyle.set('display', '');
            this.verticalRangeLabelTopStyle.set('left', `${lineEndX}px`);
            this.verticalRangeLabelTopStyle.set('bottom', `${size[1] - (arcOrigin[1] - lineOffset)}px`);
            this.verticalRangeLabelBottomStyle.set('display', '');
            this.verticalRangeLabelBottomStyle.set('left', `${lineEndX}px`);
            this.verticalRangeLabelBottomStyle.set('top', `${arcOrigin[1] + lineOffset}px`);
            this.verticalRangeTop.set(height);
            this.verticalRangeBottom.set(-height);
        }
        /**
         * Hides this weather radar's vertical range lines.
         */
        hideVerticalRangeLines() {
            this.verticalRangeLineStyle.set('display', 'none');
            this.verticalRangeLabelTopStyle.set('display', 'none');
            this.verticalRangeLabelBottomStyle.set('display', 'none');
        }
        /** @inheritdoc */
        render() {
            return (msfssdk.FSComponent.buildComponent("div", { class: this.rootCssClass, style: this.rootStyle },
                msfssdk.FSComponent.buildComponent("div", { class: 'weather-radar-bing-container', style: this.bingStyle },
                    msfssdk.FSComponent.buildComponent(msfssdk.BingComponent, { ref: this.bingRef, id: this.props.bingId, mode: EBingMode.PLANE, wxrMode: this.wxrMode })),
                msfssdk.FSComponent.buildComponent("svg", { viewBox: this.overlayViewBox, class: 'weather-radar-overlay', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
                    msfssdk.FSComponent.buildComponent("path", { d: this.boundaryLinePath, class: 'weather-radar-boundary-line' }),
                    msfssdk.FSComponent.buildComponent("path", { d: this.rangeLinesPath, class: 'weather-radar-range-lines' }),
                    msfssdk.FSComponent.buildComponent("path", { d: this.verticalRangeLinesPath, class: 'weather-radar-vertical-range-lines', style: this.verticalRangeLineStyle })),
                msfssdk.FSComponent.buildComponent("svg", { viewBox: this.referenceLineContainerViewBox, class: 'weather-radar-reference-line-container', style: this.referenceLineContainerStyle },
                    msfssdk.FSComponent.buildComponent("path", { d: this.referenceLinePath, class: 'weather-radar-reference-line' })),
                msfssdk.FSComponent.buildComponent("div", { style: this.verticalRangeLabelTopStyle },
                    msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.verticalRangeTop, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1, showCommas: true, forceSign: true }), class: 'weather-radar-vertical-range-label weather-radar-vertical-range-label-top' })),
                msfssdk.FSComponent.buildComponent("div", { style: this.verticalRangeLabelBottomStyle },
                    msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { value: this.verticalRangeBottom, displayUnit: null, formatter: msfssdk.NumberFormatter.create({ precision: 1, showCommas: true, forceSign: true }), class: 'weather-radar-vertical-range-label weather-radar-vertical-range-label-bottom' })),
                this.ranges.map((range, index) => {
                    return (msfssdk.FSComponent.buildComponent("div", { style: this.rangeLabelStyles[index] },
                        msfssdk.FSComponent.buildComponent(NumberUnitDisplay, { ref: this.rangeLabelRefs[index], value: range, displayUnit: this.props.rangeUnit, formatter: msfssdk.NumberFormatter.create({ precision: 0.1, forceDecimalZeroes: false, maxDigits: 3 }), class: `weather-radar-range-label weather-radar-range-label-${index + 1}` })));
                }),
                this.props.children));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            super.destroy();
            this.isAlive = false;
            (_a = this.bingRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            this.rangeLabelRefs.forEach(ref => { var _a; (_a = ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy(); });
            this.positionSource.destroy();
            (_b = this.operatingModeSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.scanModeSub) === null || _c === void 0 ? void 0 : _c.destroy();
            (_d = this.horizontalScanAngularWidthSub) === null || _d === void 0 ? void 0 : _d.destroy();
            (_e = this.verticalScanAngularWidthSub) === null || _e === void 0 ? void 0 : _e.destroy();
            (_f = this.rangeSub) === null || _f === void 0 ? void 0 : _f.destroy();
            (_g = this.isDataFailedSub) === null || _g === void 0 ? void 0 : _g.destroy();
            (_h = this.sizeSub) === null || _h === void 0 ? void 0 : _h.destroy();
            (_j = this.horizontalScanPaddingSub) === null || _j === void 0 ? void 0 : _j.destroy();
            (_k = this.verticalScanPaddingSub) === null || _k === void 0 ? void 0 : _k.destroy();
            (_l = this.verticalRangeLineExtendSub) === null || _l === void 0 ? void 0 : _l.destroy();
        }
    }
    WeatherRadar.DEFAULT_PADDING = msfssdk.VecNMath.create(4); // px
    WeatherRadar.DEFAULT_VERTICAL_RANGE_LINE_EXTEND = 0; // px
    WeatherRadar.DEFAULT_BEARING_LINE_ANGULAR_WIDTH = 1; // degrees
    WeatherRadar.VERTICAL_RANGE_MARKER_HEIGHT = 60000; // feet
    WeatherRadar.vec2Cache = [msfssdk.Vec2Math.create(), msfssdk.Vec2Math.create()];

    /**
     * Keys for a DefaultWaypointIconImageCache.
     */
    exports.DefaultWaypointIconImageKey = void 0;
    (function (DefaultWaypointIconImageKey) {
        DefaultWaypointIconImageKey["AirportToweredServiced"] = "AIRPORT_TOWERED_SERVICED";
        DefaultWaypointIconImageKey["AirportToweredUnserviced"] = "AIRPORT_TOWERED_NONSERVICED";
        DefaultWaypointIconImageKey["AirportUntoweredServiced"] = "AIRPORT_NONTOWERED_SERVICED";
        DefaultWaypointIconImageKey["AirportUntoweredUnserviced"] = "AIRPORT_NONTOWERED_NONSERVICED";
        DefaultWaypointIconImageKey["AirportSmallServiced"] = "AIRPORT_SMALL_SERVICED";
        DefaultWaypointIconImageKey["AirportSmallUnserviced"] = "AIRPORT_SMALL_NONSERVICED";
        DefaultWaypointIconImageKey["AirportPrivate"] = "AIRPORT_PRIVATE";
        DefaultWaypointIconImageKey["AirportUnknown"] = "AIRPORT_UNKNOWN";
        DefaultWaypointIconImageKey["Vor"] = "VOR";
        DefaultWaypointIconImageKey["VorDme"] = "VORDME";
        DefaultWaypointIconImageKey["Vortac"] = "VORTAC";
        DefaultWaypointIconImageKey["Tacan"] = "TACAN";
        DefaultWaypointIconImageKey["DmeOnly"] = "DME";
        DefaultWaypointIconImageKey["Ndb"] = "NDB";
        DefaultWaypointIconImageKey["Intersection"] = "INTERSECTION";
        DefaultWaypointIconImageKey["User"] = "USER";
        DefaultWaypointIconImageKey["FlightPath"] = "FPLN";
        DefaultWaypointIconImageKey["VNav"] = "VNAV";
    })(exports.DefaultWaypointIconImageKey || (exports.DefaultWaypointIconImageKey = {}));
    /**
     * A default implementation of {@link WaypointIconImageCache}.
     */
    class DefaultWaypointIconImageCache {
        constructor() {
            this.cache = new Map();
        }
        /**
         * Registers an image with this cache.
         * @param key The key of the image to register.
         * @param src The source URI of the image to register.
         */
        register(key, src) {
            const img = new Image();
            img.src = src;
            this.cache.set(key, img);
        }
        /**
         * Retrieves an image from this cache.
         * @param key The key of the image to retrieve.
         * @returns The image registered under the specified key, or `undefined` if one could not be found.
         */
        get(key) {
            return this.cache.get(key);
        }
        /** @inheritdoc */
        getForWaypoint(waypoint) {
            if (waypoint instanceof msfssdk.FacilityWaypoint) {
                switch (msfssdk.ICAO.getFacilityType(waypoint.facility.get().icao)) {
                    case msfssdk.FacilityType.Airport:
                        return this.getForAirport(waypoint);
                    case msfssdk.FacilityType.VOR:
                        return this.getForVor(waypoint);
                    case msfssdk.FacilityType.NDB:
                        return this.get(exports.DefaultWaypointIconImageKey.Ndb);
                    case msfssdk.FacilityType.Intersection:
                    case msfssdk.FacilityType.RWY:
                    case msfssdk.FacilityType.VIS:
                        return this.get(exports.DefaultWaypointIconImageKey.Intersection);
                    case msfssdk.FacilityType.USR:
                        return this.get(exports.DefaultWaypointIconImageKey.User);
                }
            }
            else if (waypoint instanceof msfssdk.FlightPathWaypoint) {
                return this.get(exports.DefaultWaypointIconImageKey.FlightPath);
            }
            else if (waypoint instanceof msfssdk.VNavWaypoint) {
                return this.get(exports.DefaultWaypointIconImageKey.VNav);
            }
        }
        /**
         * Retrieves an image for an airport.
         * @param airport The airport for which to retrieve the image.
         * @returns The image for the specified airport, or `undefined` if one could not be found.
         */
        getForAirport(airport) {
            const fac = airport.facility.get();
            // HINT class 1 airports are always assumed serviced
            const serviced = (fac.fuel1 !== '' || fac.fuel2 !== '') || fac.airportClass === 1;
            if (fac.airportPrivateType !== msfssdk.AirportPrivateType.Public) {
                return this.get(exports.DefaultWaypointIconImageKey.AirportPrivate);
            }
            else if (serviced && fac.towered) {
                return this.get(exports.DefaultWaypointIconImageKey.AirportToweredServiced);
            }
            else if (serviced && !fac.towered) {
                if (fac.airportClass === 1) {
                    return this.get(exports.DefaultWaypointIconImageKey.AirportUntoweredServiced);
                }
                else {
                    return this.get(exports.DefaultWaypointIconImageKey.AirportSmallServiced);
                }
            }
            else if (!serviced && fac.towered) {
                return this.get(exports.DefaultWaypointIconImageKey.AirportToweredUnserviced);
            }
            else if (!serviced && !fac.towered) {
                if (fac.airportClass === 1) {
                    return this.get(exports.DefaultWaypointIconImageKey.AirportUntoweredUnserviced);
                }
                else {
                    return this.get(exports.DefaultWaypointIconImageKey.AirportSmallUnserviced);
                }
            }
            else {
                return this.get(exports.DefaultWaypointIconImageKey.AirportUnknown);
            }
        }
        /**
         * Retrieves an image for a VOR.
         * @param vor The VOR for which to retrieve the image.
         * @returns The image for the specified VOR, or `undefined` if one could not be found.
         */
        getForVor(vor) {
            switch (vor.facility.get().type) {
                case msfssdk.VorType.DME:
                    return this.get(exports.DefaultWaypointIconImageKey.DmeOnly);
                case msfssdk.VorType.ILS:
                case msfssdk.VorType.VORDME:
                    return this.get(exports.DefaultWaypointIconImageKey.VorDme);
                case msfssdk.VorType.VORTAC:
                case msfssdk.VorType.TACAN:
                    return this.get(exports.DefaultWaypointIconImageKey.Vortac);
                default:
                    return this.get(exports.DefaultWaypointIconImageKey.Vor);
            }
        }
    }

    /**
     * Utility class for retrieving navigation data bar user setting managers.
     */
    class NavDataBarUserSettings {
        /**
         * Creates a manager for navigation data bar user settings.
         * @param bus The event bus.
         * @param defaultValues The default values for the settings. One indexed setting will be created for each default
         * value, in order.
         * @returns A new manager for navigation data bar user settings.
         */
        static createManager(bus, defaultValues) {
            return new msfssdk.DefaultUserSettingManager(bus, defaultValues.map((defaultValue, index) => {
                return { name: `navDataBarField${index}`, defaultValue };
            }));
        }
    }

    /**
     * A Garmin ADC system.
     */
    class AdcSystem extends msfssdk.BasicAvionicsSystem {
        /**
         * Creates an instance of an ADC system.
         * @param index The index of the ADC.
         * @param bus An instance of the event bus.
         * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
         * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
         * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
         * system's power.
         */
        constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
            super(index, bus, `adc_state_${index}`);
            this.airspeedIndicatorIndex = airspeedIndicatorIndex;
            this.altimeterIndex = altimeterIndex;
            this.dataSubs = [];
            if (powerSource !== undefined) {
                this.connectToPower(powerSource);
            }
            this.startDataPublish();
        }
        /**
         * Starts publishing ADC data on the event bus.
         */
        startDataPublish() {
            const sub = this.bus.getSubscriber();
            const pub = this.bus.getPublisher();
            const paused = this.state === msfssdk.AvionicsSystemState.Failed || this.state === msfssdk.AvionicsSystemState.Off;
            this.dataSubs.push(sub.on(`ias_${this.airspeedIndicatorIndex}`).handle(val => { pub.pub(`adc_ias_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`tas_${this.airspeedIndicatorIndex}`).handle(val => { pub.pub(`adc_tas_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`mach_to_kias_factor_${this.airspeedIndicatorIndex}`).handle(val => { pub.pub(`adc_mach_to_kias_factor_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`indicated_alt_${this.altimeterIndex}`).handle(val => { pub.pub(`adc_indicated_alt_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`altimeter_baro_setting_inhg_${this.altimeterIndex}`).handle(val => { pub.pub(`adc_altimeter_baro_setting_inhg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`altimeter_baro_preselect_inhg_${this.altimeterIndex}`).handle(val => { pub.pub(`adc_altimeter_baro_preselect_inhg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`altimeter_baro_is_std_${this.altimeterIndex}`).handle(val => { pub.pub(`adc_altimeter_baro_is_std_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('mach_number').handle(val => { pub.pub(`adc_mach_number_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('pressure_alt').handle(val => { pub.pub(`adc_pressure_alt_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('vertical_speed').handle(val => { pub.pub(`adc_vertical_speed_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('aoa').handle(val => { pub.pub(`adc_aoa_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('ambient_temp_c').handle(val => { pub.pub(`adc_ambient_temp_c_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('ambient_pressure_inhg').handle(val => { pub.pub(`adc_ambient_pressure_inhg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('ram_air_temp_c').handle(val => { pub.pub(`adc_ram_air_temp_c_${this.index}`, val); }, paused));
        }
        /** @inheritdoc */
        onStateChanged(previousState, currentState) {
            if (currentState === msfssdk.AvionicsSystemState.Failed || currentState === msfssdk.AvionicsSystemState.Off) {
                for (const sub of this.dataSubs) {
                    sub.pause();
                }
            }
            else {
                for (const sub of this.dataSubs) {
                    sub.resume(true);
                }
            }
        }
    }

    /**
     * A Garmin AHRS system.
     */
    class AhrsSystem extends msfssdk.BasicAvionicsSystem {
        /**
         * Creates an instance of an AHRS system.
         * @param index The index of the AHRS.
         * @param bus An instance of the event bus.
         * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this AHRS derives its data.
         * @param directionIndicatorIndex The index of the sim direction indicator from which this AHRS derives its data.
         * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
         * system's power.
         */
        constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, powerSource) {
            super(index, bus, `ahrs_state_${index}`);
            this.attitudeIndicatorIndex = attitudeIndicatorIndex;
            this.directionIndicatorIndex = directionIndicatorIndex;
            this.initializationTime = 45000;
            this.rollSub = this.bus.getSubscriber().on('roll_deg').whenChanged().handle(this.onRollChanged.bind(this), true);
            this.dataSubs = [];
            if (powerSource !== undefined) {
                this.connectToPower(powerSource);
            }
            this.bus.getSubscriber()
                .on(`magnetometer_state_${index}`)
                .handle(evt => {
                this.onUpstreamStatesChanged(this.isPowered, evt.current);
            });
            this.startDataPublish();
        }
        /** @inheritdoc */
        onPowerChanged(isPowered) {
            this.onUpstreamStatesChanged(isPowered, this.magState);
        }
        /**
         * Starts publishing AHRS data on the event bus.
         */
        startDataPublish() {
            const sub = this.bus.getSubscriber();
            const pub = this.bus.getPublisher();
            const paused = this.state === msfssdk.AvionicsSystemState.Failed || this.state === msfssdk.AvionicsSystemState.Off;
            this.dataSubs.push(sub.on(`hdg_deg_${this.directionIndicatorIndex}`).handle(val => { pub.pub(`ahrs_hdg_deg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`hdg_deg_true_${this.directionIndicatorIndex}`).handle(val => { pub.pub(`ahrs_hdg_deg_true_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`delta_heading_rate_${this.attitudeIndicatorIndex}`).handle(val => { pub.pub(`ahrs_delta_heading_rate_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`pitch_deg_${this.attitudeIndicatorIndex}`).handle(val => { pub.pub(`ahrs_pitch_deg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on(`roll_deg_${this.attitudeIndicatorIndex}`).handle(val => { pub.pub(`ahrs_roll_deg_${this.index}`, val); }, paused));
            this.dataSubs.push(sub.on('turn_coordinator_ball').handle(val => { pub.pub(`ahrs_turn_coordinator_ball_${this.index}`, val); }, paused));
        }
        /** @inheritdoc */
        onStateChanged(previousState, currentState) {
            if (currentState === msfssdk.AvionicsSystemState.Failed || currentState === msfssdk.AvionicsSystemState.Off) {
                for (const sub of this.dataSubs) {
                    sub.pause();
                }
            }
            else {
                for (const sub of this.dataSubs) {
                    sub.resume(true);
                }
            }
        }
        /**
         * A callback called when changes occur in this system's upstream states.
         * @param isPowered Whether or not the AHRS is powered.
         * @param magState The current state of the magnetometer.
         */
        onUpstreamStatesChanged(isPowered, magState) {
            if (this.isPowered === undefined || this.magState === undefined) {
                if (isPowered && magState === msfssdk.AvionicsSystemState.On) {
                    this.setState(msfssdk.AvionicsSystemState.On);
                }
            }
            else {
                if (isPowered) {
                    if (magState === msfssdk.AvionicsSystemState.On) {
                        this.setState(msfssdk.AvionicsSystemState.Initializing);
                        this.rollSub.resume(true);
                        this.initializationTimer.schedule(() => {
                            this.rollSub.pause();
                            this.setState(msfssdk.AvionicsSystemState.On);
                        }, 45000);
                    }
                    else {
                        this.rollSub.pause();
                        this.initializationTimer.clear();
                        this.setState(msfssdk.AvionicsSystemState.Failed);
                    }
                }
                else {
                    this.rollSub.pause();
                    this.initializationTimer.clear();
                    this.setState(msfssdk.AvionicsSystemState.Off);
                }
            }
            this.isPowered = isPowered;
            this.magState = magState;
        }
        /**
         * Handles when the bank angle changes while AHRS is initializing.
         * @param bankAngle The bank angle of the aircraft.
         */
        onRollChanged(bankAngle) {
            if (Math.abs(bankAngle) >= 20) {
                this.initializationTimer.schedule(() => {
                    this.rollSub.pause();
                    this.setState(msfssdk.AvionicsSystemState.On);
                }, 45000);
            }
        }
    }

    /**
     * The GMU44 magnetometer system.
     */
    class MagnetometerSystem extends msfssdk.BasicAvionicsSystem {
        /**
         * Creates an instance of the MagnetometerSystem.
         * @param index The index of the system.
         * @param bus The instance of the event bus for the system to use.
         * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
         * system's power.
         */
        constructor(index, bus, powerSource) {
            super(index, bus, `magnetometer_state_${index}`);
            this.index = index;
            this.bus = bus;
            this.initializationTime = 5000;
            if (powerSource !== undefined) {
                this.connectToPower(powerSource);
            }
        }
    }

    /**
     * A Garmin GRA 55(00) radar altimeter system.
     */
    class RadarAltimeterSystem extends msfssdk.BasicAvionicsSystem {
        /**
         * Creates an instance of an ADC system.
         * @param index The index of the ADC.
         * @param bus An instance of the event bus.
         * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
         * system's power.
         */
        constructor(index, bus, powerSource) {
            super(index, bus, `radaralt_state_${index}`);
            const sub = this.bus.getSubscriber();
            const pub = this.bus.getPublisher();
            const paused = this.state === msfssdk.AvionicsSystemState.Failed || this.state === msfssdk.AvionicsSystemState.Off;
            this.radioAltSub = sub.on('radio_alt').handle(radarAlt => { pub.pub(`radaralt_radio_alt_${this.index}`, radarAlt); }, paused);
            if (powerSource !== undefined) {
                this.connectToPower(powerSource);
            }
        }
        /** @inheritdoc */
        onStateChanged(previousState, currentState) {
            if (currentState === msfssdk.AvionicsSystemState.Failed || currentState === msfssdk.AvionicsSystemState.Off) {
                this.radioAltSub.pause();
            }
            else {
                this.radioAltSub.resume(true);
            }
        }
    }

    /**
     * ADS-B Conflict Situational Awareness (CSA) sensitivity parameters.
     */
    class AdsbSensitivityParameters {
        /**
         * Selects a sensitivity level for a specified environment.
         * @param altitude The indicated altitude of the own airplane.
         * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns The sensitivity level for the specified environment.
         */
        selectLevel(altitude, cdiScalingLabel, radarAltitude) {
            const altFeet = altitude.asUnit(msfssdk.UnitType.FOOT);
            const radarAltFeet = radarAltitude === null || radarAltitude === void 0 ? void 0 : radarAltitude.asUnit(msfssdk.UnitType.FOOT);
            let isApproach = false;
            switch (cdiScalingLabel) {
                case exports.CDIScaleLabel.LNav:
                case exports.CDIScaleLabel.LNavPlusV:
                case exports.CDIScaleLabel.LNavVNav:
                case exports.CDIScaleLabel.LP:
                case exports.CDIScaleLabel.LPPlusV:
                case exports.CDIScaleLabel.LPV:
                case exports.CDIScaleLabel.MissedApproach:
                    isApproach = true;
            }
            let level;
            if ((radarAltFeet === undefined || radarAltFeet > 2350)
                && (!isApproach && cdiScalingLabel !== exports.CDIScaleLabel.Terminal)) {
                if (altFeet > 42000) {
                    level = 6;
                }
                else if (altFeet > 20000) {
                    level = 5;
                }
                else if (altFeet > 10000) {
                    level = 4;
                }
                else if (altFeet > 5000) {
                    level = 3;
                }
                else {
                    level = 2;
                }
            }
            else if (cdiScalingLabel === exports.CDIScaleLabel.Terminal
                || (radarAltFeet !== undefined && radarAltFeet > 1000)) {
                level = 1;
            }
            else {
                level = 0;
            }
            return level;
        }
        /**
         * Selects Traffic Advisory sensitivity settings for a specified environment.
         * @param altitude The indicated altitude of the own airplane.
         * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns Traffic Advisory sensitivity settings for the specified environment.
         */
        selectTA(altitude, cdiScalingLabel, radarAltitude) {
            return AdsbSensitivityParameters.TA_LEVELS[this.selectLevel(altitude, cdiScalingLabel, radarAltitude)];
        }
        /**
         * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
         * @param level A sensitivity level.
         * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
         */
        getTA(level) {
            return AdsbSensitivityParameters.TA_LEVELS[msfssdk.MathUtils.clamp(level, 0, AdsbSensitivityParameters.TA_LEVELS.length - 1)];
        }
    }
    AdsbSensitivityParameters.TA_LEVELS = [
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(20),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.2),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(25),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.2),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(30),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.35),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(40),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.55),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(45),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.8),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(48),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(1.1),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(850)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(48),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(1.1),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(1200)
        }
    ];

    /**
     * A Garmin ADS-B system.
     */
    class GarminAdsb extends msfssdk.Adsb {
        constructor() {
            super(...arguments);
            this.adsbEnabledSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficAdsbEnabled');
        }
        /** @inheritdoc */
        init() {
            super.init();
            this.adsbEnabledSetting.sub(isEnabled => {
                // TODO: Support surface mode
                this.operatingMode.set(isEnabled ? msfssdk.AdsbOperatingMode.Airborne : msfssdk.AdsbOperatingMode.Standby);
            }, true);
        }
    }

    /**
     * An intruder tracked by Garmin traffic systems.
     */
    class GarminTcasIntruder extends msfssdk.AbstractTcasIntruder {
        /**
         * Constructor.
         * @param contact The traffic contact associated with this intruder.
         * @param simTime A subscribable which provides the current sim time, as a UNIX timestamp in milliseconds.
         */
        constructor(contact, simTime) {
            super(contact);
            this.simTime = simTime;
            this._taOnTime = 0;
            this._taOffTime = 0;
            this.lastAlertLevel = this.alertLevel.get();
            this.alertLevel.sub(this.onAlertLevelChanged.bind(this));
        }
        // eslint-disable-next-line jsdoc/require-returns
        /**
         * The sim time, as a UNIX timestamp in milliseconds, at which this intruder's alert level was most recently switched
         * to Traffic Advisory from another alert level.
         */
        get taOnTime() {
            return this._taOnTime;
        }
        // eslint-disable-next-line jsdoc/require-returns
        /**
         * The sim time, as a UNIX timestamp in milliseconds, at which this intruder's alert level was most recently switched
         * from Traffic Advisory to another alert level.
         */
        get taOffTime() {
            return this._taOffTime;
        }
        /**
         * Responds to changes in this intruder's alert level.
         * @param alertLevel The new alert level.
         */
        onAlertLevelChanged(alertLevel) {
            if (alertLevel === msfssdk.TcasAlertLevel.TrafficAdvisory) {
                this._taOnTime = this.simTime.get();
            }
            else if (this.lastAlertLevel === msfssdk.TcasAlertLevel.TrafficAdvisory) {
                this._taOffTime = this.simTime.get();
            }
            this.lastAlertLevel = alertLevel;
        }
    }

    /**
     * Garmin TCAS-II.
     */
    class GarminTcasII extends msfssdk.Tcas {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
         * @param adsb The ADS-B system associated with this TCAS, or `null` if this TCAS does not support ADS-B.
         * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS. Defaults to
         * {@link GarminTcasII.DEFAULT_MAX_INTRUDER_COUNT}.
         * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
         * {@link GarminTcasII.DEFAULT_REAL_TIME_UPDATE_FREQ}.
         * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
         * {@link GarminTcasII.DEFAULT_SIM_TIME_UPDATE_FREQ}.
         */
        constructor(bus, tfcInstrument, adsb, maxIntruderCount = GarminTcasII.DEFAULT_MAX_INTRUDER_COUNT, realTimeUpdateFreq = GarminTcasII.DEFAULT_REAL_TIME_UPDATE_FREQ, simTimeUpdateFreq = GarminTcasII.DEFAULT_SIM_TIME_UPDATE_FREQ) {
            super(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq);
            this.adsb = adsb;
            this.type = exports.TrafficSystemType.TcasII;
            this.cdiScalingLabel = exports.CDIScaleLabel.Enroute;
            this.operatingModeSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficOperatingMode');
            this.raAltitudeInhibitFlag = msfssdk.MappedSubject.create(([radarAlt, isClimbing]) => {
                return radarAlt < (isClimbing ? 900 : 1100);
            }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(msfssdk.UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
        }
        /** @inheritdoc */
        createSensitivity() {
            return new GarminTcasIISensitivity();
        }
        /** @inheritdoc */
        init() {
            var _a;
            super.init();
            this.bus.getSubscriber().on('lnavdata_cdi_scale_label').whenChanged().handle(label => { this.cdiScalingLabel = label; });
            this.operatingModeSetting.sub(value => {
                switch (value) {
                    case exports.TrafficOperatingModeSetting.Operating:
                    case exports.TrafficOperatingModeSetting.Auto:
                        if (this.raAltitudeInhibitFlag.get()) {
                            this.setOperatingMode(msfssdk.TcasOperatingMode.TAOnly);
                        }
                        else {
                            this.setOperatingMode(msfssdk.TcasOperatingMode.TA_RA);
                        }
                        break;
                    case exports.TrafficOperatingModeSetting.TAOnly:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.TAOnly);
                        break;
                    default:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.Standby);
                }
            }, true);
            this.raAltitudeInhibitFlag.sub(inhibit => {
                if (this.operatingModeSetting.value === exports.TrafficOperatingModeSetting.Auto) {
                    this.setOperatingMode(inhibit ? msfssdk.TcasOperatingMode.TAOnly : msfssdk.TcasOperatingMode.TA_RA);
                }
            });
            (_a = this.adsb) === null || _a === void 0 ? void 0 : _a.init();
        }
        /** @inheritdoc */
        createIntruderEntry(contact) {
            return new GarminTcasIntruder(contact, this.simTime);
        }
        /** @inheritdoc */
        updateSensitivity() {
            var _a, _b;
            this.sensitivity.update((_b = (_a = this.adsb) === null || _a === void 0 ? void 0 : _a.getOperatingMode()) !== null && _b !== void 0 ? _b : msfssdk.AdsbOperatingMode.Standby, this.ownAirplaneSubs.altitude.get(), this.cdiScalingLabel, this.ownAirplaneSubs.radarAltitude.get());
        }
        /** @inheritdoc */
        canIssueTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return false;
            }
            if (intruder.alertLevel.get() !== msfssdk.TcasAlertLevel.TrafficAdvisory) {
                const dt = simTime - intruder.taOffTime;
                return dt < 0 || dt >= GarminTcasII.TA_ON_HYSTERESIS;
            }
            return true;
        }
        /** @inheritdoc */
        canCancelTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return true;
            }
            const dt = simTime - intruder.taOnTime;
            return dt < 0 || dt >= GarminTcasII.TA_OFF_HYSTERESIS;
        }
    }
    GarminTcasII.DEFAULT_MAX_INTRUDER_COUNT = 40;
    GarminTcasII.DEFAULT_REAL_TIME_UPDATE_FREQ = 2; // hz
    GarminTcasII.DEFAULT_SIM_TIME_UPDATE_FREQ = 1; // hz
    GarminTcasII.TA_ON_HYSTERESIS = 2000; // ms
    GarminTcasII.TA_OFF_HYSTERESIS = 8000; // ms
    /**
     * An implementation of {@link TCASSensitivity} which provides sensitivity parameters for the Garmin TCAS-II. When
     * ADS-B is operating, Traffic Advisory sensitivity is selected based on the ADS-B Conflict Situational Awareness (CSA)
     * algorithm. When ADS-B is not operating, Traffic Advisory sensitivity is selected based on the TCAS-II algorithm.
     * Resolution Advisory sensitivity is always determined by the TCAS-II algorithm.
     */
    class GarminTcasIISensitivity {
        constructor() {
            this.tcasIISensitivity = new msfssdk.TcasIISensitivityParameters();
            this.adsbSensitivity = new AdsbSensitivityParameters();
            this.tcasIIParams = {
                parametersPA: this.tcasIISensitivity.getPA(0),
                parametersTA: this.tcasIISensitivity.getTA(0),
                parametersRA: this.tcasIISensitivity.getRA(0)
            };
            this.adsbParams = {
                parametersPA: this.tcasIISensitivity.getPA(0),
                parametersTA: this.adsbSensitivity.getTA(0),
                parametersRA: this.tcasIISensitivity.getRA(0)
            };
            this.tcasIILevel = 0;
            this.adsbLevel = 0;
            this.activeParams = this.tcasIIParams;
        }
        /** @inheritdoc */
        selectParameters() {
            return this.activeParams;
        }
        /** @inheritdoc */
        selectRAAlim() {
            return this.tcasIISensitivity.getRAAlim(this.tcasIILevel);
        }
        /**
         * Updates the sensitivity.
         * @param adsbMode The ADS-B operating mode.
         * @param altitude The indicated altitude of the own airplane.
         * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         */
        update(adsbMode, altitude, cdiScalingLabel, radarAltitude) {
            this.tcasIILevel = this.tcasIISensitivity.selectLevel(altitude, radarAltitude);
            this.adsbLevel = this.adsbSensitivity.selectLevel(altitude, cdiScalingLabel, radarAltitude);
            this.tcasIIParams.parametersPA = this.tcasIISensitivity.getPA(this.tcasIILevel);
            this.tcasIIParams.parametersTA = this.tcasIISensitivity.getTA(this.tcasIILevel);
            this.tcasIIParams.parametersRA = this.tcasIISensitivity.getRA(this.tcasIILevel);
            this.adsbParams.parametersPA = this.tcasIISensitivity.getPA(this.tcasIILevel);
            this.adsbParams.parametersTA = this.adsbSensitivity.getTA(this.adsbLevel);
            this.adsbParams.parametersRA = this.tcasIISensitivity.getRA(this.tcasIILevel);
            // Right now we just assume every intruder is tracked by ADS-B if ADS-B is operating
            this.activeParams = adsbMode === msfssdk.AdsbOperatingMode.Standby ? this.tcasIIParams : this.adsbParams;
        }
    }

    /**
     * Garmin Traffic Advisory System (TAS).
     */
    class TrafficAdvisorySystem extends msfssdk.Tcas {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param tfcInstrument The traffic instrument which provides traffic contacts for this TAS.
         * @param adsb The ADS-B system associated with this TAS, or `null` if this TAS does not support ADS-B.
         * @param supportsRadarAltitude Whether this TAS supports radar altitude.
         * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TAS. Defaults to
         * {@link TrafficAdvisorySystem.DEFAULT_MAX_INTRUDER_COUNT}.
         * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
         * {@link TrafficAdvisorySystem.DEFAULT_REAL_TIME_UPDATE_FREQ}.
         * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
         * {@link TrafficAdvisorySystem.DEFAULT_SIM_TIME_UPDATE_FREQ}.
         */
        constructor(bus, tfcInstrument, adsb, supportsRadarAltitude, maxIntruderCount = TrafficAdvisorySystem.DEFAULT_MAX_INTRUDER_COUNT, realTimeUpdateFreq = TrafficAdvisorySystem.DEFAULT_REAL_TIME_UPDATE_FREQ, simTimeUpdateFreq = TrafficAdvisorySystem.DEFAULT_SIM_TIME_UPDATE_FREQ) {
            super(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq);
            this.adsb = adsb;
            this.supportsRadarAltitude = supportsRadarAltitude;
            this.type = exports.TrafficSystemType.Tas;
            this.operatingModeSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficOperatingMode');
            this.cdiScalingLabel = exports.CDIScaleLabel.Enroute;
            this.operatingModeChangeTimer = new msfssdk.DebounceTimer();
        }
        /** @inheritdoc */
        createSensitivity() {
            return new TasSensitivity();
        }
        /** @inheritdoc */
        init() {
            var _a;
            super.init();
            this.bus.getSubscriber().on('lnavdata_cdi_scale_label').whenChanged().handle(label => { this.cdiScalingLabel = label; });
            this.operatingModeSetting.sub(value => {
                switch (value) {
                    case exports.TrafficOperatingModeSetting.Operating:
                    case exports.TrafficOperatingModeSetting.Auto:
                    case exports.TrafficOperatingModeSetting.TAOnly:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.TAOnly);
                        break;
                    default:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.Standby);
                }
            }, true);
            this.operatingModeSub.sub(this.cancelOperatingModeChange.bind(this));
            this.ownAirplaneSubs.isOnGround.sub(this.onGroundChanged.bind(this));
            if (!this.ownAirplaneSubs.isOnGround.get()) {
                this.operatingModeSetting.value = exports.TrafficOperatingModeSetting.Operating;
            }
            (_a = this.adsb) === null || _a === void 0 ? void 0 : _a.init();
        }
        /** @inheritdoc */
        createIntruderEntry(contact) {
            return new GarminTcasIntruder(contact, this.simTime);
        }
        /** @inheritdoc */
        updateSensitivity() {
            var _a, _b;
            this.sensitivity.update((_b = (_a = this.adsb) === null || _a === void 0 ? void 0 : _a.getOperatingMode()) !== null && _b !== void 0 ? _b : msfssdk.AdsbOperatingMode.Standby, this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.groundSpeed.get(), this.cdiScalingLabel, this.supportsRadarAltitude ? this.ownAirplaneSubs.radarAltitude.get() : undefined);
        }
        /** @inheritdoc */
        canIssueTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return false;
            }
            if (intruder.alertLevel.get() !== msfssdk.TcasAlertLevel.TrafficAdvisory) {
                const dt = simTime - intruder.taOffTime;
                return dt < 0 || dt >= TrafficAdvisorySystem.TA_ON_HYSTERESIS;
            }
            return true;
        }
        /** @inheritdoc */
        canCancelTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return true;
            }
            const dt = simTime - intruder.taOnTime;
            return dt < 0 || dt >= TrafficAdvisorySystem.TA_OFF_HYSTERESIS;
        }
        /**
         * A callback which is called when whether own airplane is on the ground changes.
         * @param isOnGround Whether own airplane is on the ground.
         */
        onGroundChanged(isOnGround) {
            this.cancelOperatingModeChange();
            if (isOnGround) {
                if (this.operatingModeSetting.value === exports.TrafficOperatingModeSetting.Operating) {
                    this.scheduleOperatingModeChange(exports.TrafficOperatingModeSetting.Standby, TrafficAdvisorySystem.LANDING_STANDBY_DELAY);
                }
            }
            else {
                if (this.operatingModeSetting.value === exports.TrafficOperatingModeSetting.Standby) {
                    this.scheduleOperatingModeChange(exports.TrafficOperatingModeSetting.Operating, TrafficAdvisorySystem.TAKEOFF_OPER_DELAY);
                }
            }
        }
        /**
         * Schedules a delayed operating mode change.
         * @param toMode The target operating mode.
         * @param delay The delay, in milliseconds.
         */
        scheduleOperatingModeChange(toMode, delay) {
            this.operatingModeChangeTimer.schedule(() => {
                this.operatingModeSetting.value = toMode;
            }, delay);
        }
        /**
         * Cancels the currently scheduled operating mode change, if one exists.
         */
        cancelOperatingModeChange() {
            this.operatingModeChangeTimer.clear();
        }
    }
    TrafficAdvisorySystem.DEFAULT_MAX_INTRUDER_COUNT = 30;
    TrafficAdvisorySystem.DEFAULT_REAL_TIME_UPDATE_FREQ = 2; // hz
    TrafficAdvisorySystem.DEFAULT_SIM_TIME_UPDATE_FREQ = 1; // hz
    TrafficAdvisorySystem.TA_ON_HYSTERESIS = 2000; // ms
    TrafficAdvisorySystem.TA_OFF_HYSTERESIS = 8000; // ms
    TrafficAdvisorySystem.TAKEOFF_OPER_DELAY = 8000; // milliseconds
    TrafficAdvisorySystem.LANDING_STANDBY_DELAY = 24000; // milliseconds
    /**
     * Garmin TAS sensitivity settings.
     */
    class TasSensitivityParameters {
        /**
         * Selects a sensitivity level for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns The sensitivity level for the specified environment.
         */
        selectLevel(groundSpeed, radarAltitude) {
            var _a;
            if (((_a = radarAltitude === null || radarAltitude === void 0 ? void 0 : radarAltitude.compare(2000, msfssdk.UnitType.FOOT)) !== null && _a !== void 0 ? _a : 1) < 0 || groundSpeed.compare(120, msfssdk.UnitType.KNOT) < 0) {
                return 0;
            }
            else {
                return 1;
            }
        }
        /**
         * Selects Proximity Advisory sensitivity settings for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns Proximity Advisory sensitivity settings for the specified environment.
         */
        selectPA(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        groundSpeed, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        radarAltitude) {
            return TasSensitivityParameters.PA;
        }
        /**
         * Selects Traffic Advisory sensitivity settings for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns Traffic Advisory sensitivity settings for the specified environment.
         */
        selectTA(groundSpeed, radarAltitude) {
            return TasSensitivityParameters.TA_LEVELS[this.selectLevel(groundSpeed, radarAltitude)];
        }
        /**
         * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
         * @param level A sensitivity level.
         * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getPA(level) {
            return TasSensitivityParameters.PA;
        }
        /**
         * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
         * @param level A sensitivity level.
         * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
         */
        getTA(level) {
            return TasSensitivityParameters.TA_LEVELS[msfssdk.MathUtils.clamp(level, 0, TasSensitivityParameters.TA_LEVELS.length - 1)];
        }
    }
    TasSensitivityParameters.PA = {
        protectedRadius: msfssdk.UnitType.NMILE.createNumber(6),
        protectedHeight: msfssdk.UnitType.FOOT.createNumber(1200)
    };
    TasSensitivityParameters.TA_LEVELS = [
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(20),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.2),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(600)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(30),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.55),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(800)
        }
    ];
    /**
     * An implementation of {@link TCASSensitivity} which provides sensitivity parameters for the Garmin Traffic Advisory
     * System (TAS). When ADS-B is operating, Traffic Advisory sensitivity is selected based on the ADS-B Conflict
     * Situational Awareness (CSA) algorithm. When ADS-B is not operating, Traffic Advisory sensitivity is selected based
     * on the TAS algorithm.
     */
    class TasSensitivity {
        constructor() {
            this.adsbTASensitivity = new AdsbSensitivityParameters();
            this.tasSensitivity = new TasSensitivityParameters();
            this.tasParams = {
                parametersPA: this.tasSensitivity.getPA(0),
                parametersTA: this.tasSensitivity.getTA(0),
                parametersRA: {
                    lookaheadTime: msfssdk.UnitType.SECOND.createNumber(NaN),
                    protectedRadius: msfssdk.UnitType.NMILE.createNumber(NaN),
                    protectedHeight: msfssdk.UnitType.FOOT.createNumber(NaN),
                    alim: msfssdk.UnitType.FOOT.createNumber(NaN)
                }
            };
            this.adsbParams = {
                parametersPA: this.tasSensitivity.getPA(0),
                parametersTA: this.adsbTASensitivity.getTA(0),
                parametersRA: {
                    lookaheadTime: msfssdk.UnitType.SECOND.createNumber(NaN),
                    protectedRadius: msfssdk.UnitType.NMILE.createNumber(NaN),
                    protectedHeight: msfssdk.UnitType.FOOT.createNumber(NaN),
                    alim: msfssdk.UnitType.FOOT.createNumber(NaN)
                }
            };
            this.activeParams = this.tasParams;
        }
        /** @inheritdoc */
        selectParameters() {
            return this.activeParams;
        }
        /** @inheritdoc */
        selectRAAlim() {
            return this.tasParams.parametersRA.alim;
        }
        /**
         * Updates the sensitivity.
         * @param adsbMode The ADS-B operating mode.
         * @param altitude The indicated altitude of the own airplane.
         * @param groundSpeed The ground speed of the own airplane.
         * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         */
        update(adsbMode, altitude, groundSpeed, cdiScalingLabel, radarAltitude) {
            const tasLevel = this.tasSensitivity.selectLevel(groundSpeed, radarAltitude);
            const adsbLevel = this.adsbTASensitivity.selectLevel(altitude, cdiScalingLabel, radarAltitude);
            this.tasParams.parametersPA = this.tasSensitivity.getPA(tasLevel);
            this.tasParams.parametersTA = this.tasSensitivity.getTA(tasLevel);
            this.tasParams.parametersPA = this.tasSensitivity.getPA(tasLevel);
            this.tasParams.parametersTA = this.adsbTASensitivity.getTA(adsbLevel);
            // Right now we just assume every intruder is tracked by ADS-B if ADS-B is operating
            this.activeParams = adsbMode === msfssdk.AdsbOperatingMode.Standby ? this.tasParams : this.adsbParams;
        }
    }

    /**
     * Garmin Traffic Information Service.
     */
    class TrafficInfoService extends msfssdk.Tcas {
        /**
         * Constructor.
         * @param bus The event bus.
         * @param tfcInstrument The traffic instrument which provides traffic contacts for this TIS.
         * @param supportsRadarAltitude Whether this TIS supports radar altitude.
         * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TIS. Defaults to
         * {@link TrafficInfoService.DEFAULT_MAX_INTRUDER_COUNT}.
         * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
         * {@link TrafficInfoService.DEFAULT_REAL_TIME_UPDATE_FREQ}.
         * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
         * {@link TrafficInfoService.DEFAULT_SIM_TIME_UPDATE_FREQ}.
         */
        constructor(bus, tfcInstrument, supportsRadarAltitude, maxIntruderCount = TrafficInfoService.DEFAULT_MAX_INTRUDER_COUNT, realTimeUpdateFreq = TrafficInfoService.DEFAULT_REAL_TIME_UPDATE_FREQ, simTimeUpdateFreq = TrafficInfoService.DEFAULT_SIM_TIME_UPDATE_FREQ) {
            super(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq);
            this.supportsRadarAltitude = supportsRadarAltitude;
            this.type = exports.TrafficSystemType.Tis;
            this.adsb = null;
            this.operatingModeSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficOperatingMode');
            this.operatingModeChangeTimer = new msfssdk.DebounceTimer();
        }
        /** @inheritdoc */
        createSensitivity() {
            return new TisSensitivity();
        }
        /** @inheritdoc */
        init() {
            super.init();
            this.operatingModeSetting.sub(value => {
                switch (value) {
                    case exports.TrafficOperatingModeSetting.Operating:
                    case exports.TrafficOperatingModeSetting.Auto:
                    case exports.TrafficOperatingModeSetting.TAOnly:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.TAOnly);
                        break;
                    default:
                        this.operatingModeSub.set(msfssdk.TcasOperatingMode.Standby);
                }
            }, true);
            this.operatingModeSub.sub(this.cancelOperatingModeChange.bind(this));
            this.ownAirplaneSubs.isOnGround.sub(this.onGroundChanged.bind(this));
            if (!this.ownAirplaneSubs.isOnGround.get()) {
                this.operatingModeSetting.value = exports.TrafficOperatingModeSetting.Operating;
            }
        }
        /** @inheritdoc */
        createIntruderEntry(contact) {
            return new GarminTcasIntruder(contact, this.simTime);
        }
        /** @inheritdoc */
        filterIntruder(intruder) {
            const relativePosVec = intruder.relativePositionVec;
            return TrafficInfoService.MAX_INTRUDER_ALTITUDE_BELOW.compare(-relativePosVec[2], msfssdk.UnitType.METER) >= 0
                && TrafficInfoService.MAX_INTRUDER_ALTITUDE_ABOVE.compare(relativePosVec[2], msfssdk.UnitType.METER) >= 0
                && TrafficInfoService.MAX_INTRUDER_DISTANCE.compare(msfssdk.Vec2Math.abs(relativePosVec), msfssdk.UnitType.METER) >= 0;
        }
        /** @inheritdoc */
        updateSensitivity() {
            this.sensitivity.update(this.ownAirplaneSubs.groundSpeed.get(), this.supportsRadarAltitude ? this.ownAirplaneSubs.radarAltitude.get() : undefined);
        }
        /** @inheritdoc */
        canIssueTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return false;
            }
            if (intruder.alertLevel.get() !== msfssdk.TcasAlertLevel.TrafficAdvisory) {
                const dt = simTime - intruder.taOffTime;
                return dt < 0 || dt >= TrafficInfoService.TA_ON_HYSTERESIS;
            }
            return true;
        }
        /** @inheritdoc */
        canCancelTrafficAdvisory(simTime, intruder) {
            if (this.ownAirplaneSubs.isOnGround.get()) {
                return true;
            }
            const dt = simTime - intruder.taOnTime;
            return dt < 0 || dt >= TrafficInfoService.TA_OFF_HYSTERESIS;
        }
        /**
         * A callback which is called when whether own airplane is on the ground changes.
         * @param isOnGround Whether own airplane is on the ground.
         */
        onGroundChanged(isOnGround) {
            this.cancelOperatingModeChange();
            if (isOnGround) {
                if (this.operatingModeSetting.value === exports.TrafficOperatingModeSetting.Operating) {
                    this.scheduleOperatingModeChange(exports.TrafficOperatingModeSetting.Standby, TrafficInfoService.LANDING_STANDBY_DELAY);
                }
            }
            else {
                if (this.operatingModeSetting.value === exports.TrafficOperatingModeSetting.Standby) {
                    this.scheduleOperatingModeChange(exports.TrafficOperatingModeSetting.Operating, TrafficInfoService.TAKEOFF_OPER_DELAY);
                }
            }
        }
        /**
         * Schedules a delayed operating mode change.
         * @param toMode The target operating mode.
         * @param delay The delay, in milliseconds.
         */
        scheduleOperatingModeChange(toMode, delay) {
            this.operatingModeChangeTimer.schedule(() => {
                this.operatingModeSetting.value = toMode;
            }, delay);
        }
        /**
         * Cancels the currently scheduled operating mode change, if one exists.
         */
        cancelOperatingModeChange() {
            this.operatingModeChangeTimer.clear();
        }
    }
    TrafficInfoService.DEFAULT_MAX_INTRUDER_COUNT = 8;
    TrafficInfoService.DEFAULT_REAL_TIME_UPDATE_FREQ = 2; // hz
    TrafficInfoService.DEFAULT_SIM_TIME_UPDATE_FREQ = 0.2; // hz
    TrafficInfoService.MAX_INTRUDER_ALTITUDE_BELOW = msfssdk.UnitType.FOOT.createNumber(3000);
    TrafficInfoService.MAX_INTRUDER_ALTITUDE_ABOVE = msfssdk.UnitType.FOOT.createNumber(3500);
    TrafficInfoService.MAX_INTRUDER_DISTANCE = msfssdk.UnitType.NMILE.createNumber(7.5);
    TrafficInfoService.TA_ON_HYSTERESIS = 2000; // ms
    TrafficInfoService.TA_OFF_HYSTERESIS = 8000; // ms
    TrafficInfoService.TAKEOFF_OPER_DELAY = 8000; // milliseconds
    TrafficInfoService.LANDING_STANDBY_DELAY = 24000; // milliseconds
    /**
     * Garmin TIS sensitivity settings.
     */
    class TisSensitivityParameters {
        /**
         * Selects a sensitivity level for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns The sensitivity level for the specified environment.
         */
        selectLevel(groundSpeed, radarAltitude) {
            // TODO: I couldn't find any specific details on how TIS determines sensitivity levels, so for now this is
            // identical to the TAS algorithm.
            var _a;
            if (((_a = radarAltitude === null || radarAltitude === void 0 ? void 0 : radarAltitude.compare(2000, msfssdk.UnitType.FOOT)) !== null && _a !== void 0 ? _a : 1) < 0 || groundSpeed.compare(120, msfssdk.UnitType.KNOT) < 0) {
                return 0;
            }
            else {
                return 1;
            }
        }
        /**
         * Selects Proximity Advisory sensitivity settings for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns Proximity Advisory sensitivity settings for the specified environment.
         */
        selectPA(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        groundSpeed, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        radarAltitude) {
            return TisSensitivityParameters.PA;
        }
        /**
         * Selects Traffic Advisory sensitivity settings for a specified environment.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         * @returns Traffic Advisory sensitivity settings for the specified environment.
         */
        selectTA(groundSpeed, radarAltitude) {
            return TisSensitivityParameters.TA_LEVELS[this.selectLevel(groundSpeed, radarAltitude)];
        }
        /**
         * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
         * @param level A sensitivity level.
         * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getPA(level) {
            return TisSensitivityParameters.PA;
        }
        /**
         * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
         * @param level A sensitivity level.
         * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
         */
        getTA(level) {
            return TisSensitivityParameters.TA_LEVELS[msfssdk.MathUtils.clamp(level, 0, TisSensitivityParameters.TA_LEVELS.length - 1)];
        }
    }
    TisSensitivityParameters.PA = {
        protectedRadius: msfssdk.UnitType.NMILE.createNumber(6),
        protectedHeight: msfssdk.UnitType.FOOT.createNumber(1200)
    };
    TisSensitivityParameters.TA_LEVELS = [
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(20),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.2),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(600)
        },
        {
            lookaheadTime: msfssdk.UnitType.SECOND.createNumber(30),
            protectedRadius: msfssdk.UnitType.NMILE.createNumber(0.55),
            protectedHeight: msfssdk.UnitType.FOOT.createNumber(800)
        }
    ];
    /**
     * An implementation of {@link TCASSensitivity} which provides sensitivity parameters for the Garmin Traffic
     * Information Service.
     */
    class TisSensitivity {
        constructor() {
            this.sensitivity = new TisSensitivityParameters();
            this.params = {
                parametersPA: this.sensitivity.getPA(0),
                parametersTA: this.sensitivity.getTA(0),
                parametersRA: {
                    lookaheadTime: msfssdk.UnitType.SECOND.createNumber(NaN),
                    protectedRadius: msfssdk.UnitType.NMILE.createNumber(NaN),
                    protectedHeight: msfssdk.UnitType.FOOT.createNumber(NaN),
                    alim: msfssdk.UnitType.FOOT.createNumber(NaN)
                }
            };
        }
        /** @inheritdoc */
        selectParameters() {
            return this.params;
        }
        /** @inheritdoc */
        selectRAAlim() {
            return this.params.parametersRA.alim;
        }
        /**
         * Updates the sensitivity.
         * @param groundSpeed The ground speed of the own airplane.
         * @param radarAltitude The radar altitude of the own airplane.
         */
        update(groundSpeed, radarAltitude) {
            const level = this.sensitivity.selectLevel(groundSpeed, radarAltitude);
            this.params.parametersPA = this.sensitivity.getPA(level);
            this.params.parametersTA = this.sensitivity.getTA(level);
        }
    }

    exports.AbstractFlightPlanLegWaypointsRecord = AbstractFlightPlanLegWaypointsRecord;
    exports.AdcSystem = AdcSystem;
    exports.AdsbSensitivityParameters = AdsbSensitivityParameters;
    exports.AhrsSystem = AhrsSystem;
    exports.AirportWaypoint = AirportWaypoint;
    exports.AirspeedIndicator = AirspeedIndicator;
    exports.Altimeter = Altimeter;
    exports.AltitudeAlerter = AltitudeAlerter;
    exports.ArtificialHorizon = ArtificialHorizon;
    exports.AttitudeAircraftSymbol = AttitudeAircraftSymbol;
    exports.AttitudeIndicator = AttitudeIndicator;
    exports.BearingDisplay = BearingDisplay;
    exports.DateTimeNavDataBarFieldTypeRenderer = DateTimeNavDataBarFieldTypeRenderer;
    exports.DateTimeUserSettings = DateTimeUserSettings;
    exports.DefaultAirspeedIndicatorDataProvider = DefaultAirspeedIndicatorDataProvider;
    exports.DefaultAltimeterDataProvider = DefaultAltimeterDataProvider;
    exports.DefaultBaseFlightPathPlanRenderer = DefaultBaseFlightPathPlanRenderer;
    exports.DefaultFlightPathPlanRenderer = DefaultFlightPathPlanRenderer;
    exports.DefaultFullFlightPathPlanRenderer = DefaultFullFlightPathPlanRenderer;
    exports.DefaultNavDataBarFieldModelFactory = DefaultNavDataBarFieldModelFactory;
    exports.DefaultNavDataBarFieldRenderer = DefaultNavDataBarFieldRenderer;
    exports.DefaultRadarAltimeterDataProvider = DefaultRadarAltimeterDataProvider;
    exports.DefaultWaypointIconImageCache = DefaultWaypointIconImageCache;
    exports.DisplayUnitNavDataBarFieldTypeRenderer = DisplayUnitNavDataBarFieldTypeRenderer;
    exports.EventBusNavDataBarFieldTypeModelFactory = EventBusNavDataBarFieldTypeModelFactory;
    exports.FixIcaoWaypointsRecord = FixIcaoWaypointsRecord;
    exports.FlightDirector = FlightDirector;
    exports.FlightPathMarker = FlightPathMarker;
    exports.FlightPathTerminatorWaypointsRecord = FlightPathTerminatorWaypointsRecord;
    exports.Fms = Fms;
    exports.FmsUtils = FmsUtils;
    exports.GarminAPConfig = GarminAPConfig;
    exports.GarminAPStateManager = GarminAPStateManager;
    exports.GarminAdsb = GarminAdsb;
    exports.GarminAirspaceShowTypeMap = GarminAirspaceShowTypeMap;
    exports.GarminFacilityWaypointCache = GarminFacilityWaypointCache;
    exports.GarminMapBuilder = GarminMapBuilder;
    exports.GarminMapKeys = GarminMapKeys;
    exports.GarminNavToNavManager = GarminNavToNavManager;
    exports.GarminObsDirector = GarminObsDirector;
    exports.GarminTcasII = GarminTcasII;
    exports.GarminTcasIISensitivity = GarminTcasIISensitivity;
    exports.GarminTcasIntruder = GarminTcasIntruder;
    exports.GarminVNavManager = GarminVNavManager;
    exports.GenericNavDataBarFieldModelFactory = GenericNavDataBarFieldModelFactory;
    exports.GenericNavDataBarFieldRenderer = GenericNavDataBarFieldRenderer;
    exports.HorizonDisplay = HorizonDisplay;
    exports.HsiSource = HsiSource;
    exports.LNavDataSimVarPublisher = LNavDataSimVarPublisher;
    exports.MagVarDisplay = MagVarDisplay;
    exports.MagnetometerSystem = MagnetometerSystem;
    exports.MapActiveFlightPlanDataProvider = MapActiveFlightPlanDataProvider;
    exports.MapAirportIcon = MapAirportIcon;
    exports.MapAirspaceRendering = MapAirspaceRendering;
    exports.MapAirspaceVisController = MapAirspaceVisController;
    exports.MapAltitudeArcLayer = MapAltitudeArcLayer;
    exports.MapAltitudeArcModule = MapAltitudeArcModule;
    exports.MapBannerIndicator = MapBannerIndicator;
    exports.MapCrosshairLayer = MapCrosshairLayer;
    exports.MapCrosshairModule = MapCrosshairModule;
    exports.MapDataIntegrityRTRController = MapDataIntegrityRTRController;
    exports.MapDeclutterModule = MapDeclutterModule;
    exports.MapDetailIndicator = MapDetailIndicator;
    exports.MapFlightPathStyles = MapFlightPathStyles;
    exports.MapFlightPlanFocusCalculator = MapFlightPlanFocusCalculator;
    exports.MapFlightPlanFocusModule = MapFlightPlanFocusModule;
    exports.MapFlightPlanFocusRTRController = MapFlightPlanFocusRTRController;
    exports.MapFlightPlanLayer = MapFlightPlanLayer;
    exports.MapFlightPlanWaypointRecordManager = MapFlightPlanWaypointRecordManager;
    exports.MapFlightPlannerPlanDataProvider = MapFlightPlannerPlanDataProvider;
    exports.MapGarminTrafficController = MapGarminTrafficController;
    exports.MapGarminTrafficModule = MapGarminTrafficModule;
    exports.MapMiniCompassLayer = MapMiniCompassLayer;
    exports.MapNexradController = MapNexradController;
    exports.MapNexradModule = MapNexradModule;
    exports.MapOrientationController = MapOrientationController;
    exports.MapOrientationIndicator = MapOrientationIndicator;
    exports.MapOrientationModule = MapOrientationModule;
    exports.MapOrientationRTRController = MapOrientationRTRController;
    exports.MapPointerController = MapPointerController;
    exports.MapPointerInfoLayer = MapPointerInfoLayer;
    exports.MapPointerLayer = MapPointerLayer;
    exports.MapPointerModule = MapPointerModule;
    exports.MapPointerRTRController = MapPointerRTRController;
    exports.MapProcedurePreviewLayer = MapProcedurePreviewLayer;
    exports.MapProcedurePreviewModule = MapProcedurePreviewModule;
    exports.MapRangeCompassController = MapRangeCompassController;
    exports.MapRangeCompassLayer = MapRangeCompassLayer;
    exports.MapRangeCompassModule = MapRangeCompassModule;
    exports.MapRangeController = MapRangeController;
    exports.MapRangeDisplay = MapRangeDisplay;
    exports.MapRangeRTRController = MapRangeRTRController;
    exports.MapRangeRingLayer = MapRangeRingLayer;
    exports.MapRangeRingModule = MapRangeRingModule;
    exports.MapResourcePriority = MapResourcePriority;
    exports.MapStandaloneFlightPlanPlanDataProvider = MapStandaloneFlightPlanPlanDataProvider;
    exports.MapSymbolVisController = MapSymbolVisController;
    exports.MapTerrainColorsController = MapTerrainColorsController;
    exports.MapTerrainController = MapTerrainController;
    exports.MapTerrainModule = MapTerrainModule;
    exports.MapTerrainScaleIndicator = MapTerrainScaleIndicator;
    exports.MapTrackVectorLayer = MapTrackVectorLayer;
    exports.MapTrackVectorModule = MapTrackVectorModule;
    exports.MapTrafficController = MapTrafficController;
    exports.MapTrafficIntruderIcon = MapTrafficIntruderIcon;
    exports.MapTrafficOffScaleIndicator = MapTrafficOffScaleIndicator;
    exports.MapTrafficStatusIndicator = MapTrafficStatusIndicator;
    exports.MapUnitsModule = MapUnitsModule;
    exports.MapUserSettingsUtils = MapUserSettingsUtils;
    exports.MapUtils = MapUtils;
    exports.MapWaypointDisplayBuilderClass = MapWaypointDisplayBuilderClass;
    exports.MapWaypointHighlightIcon = MapWaypointHighlightIcon;
    exports.MapWaypointHighlightLayer = MapWaypointHighlightLayer;
    exports.MapWaypointHighlightModule = MapWaypointHighlightModule;
    exports.MapWaypointRenderer = MapWaypointRenderer;
    exports.MapWaypointStyles = MapWaypointStyles;
    exports.MapWaypointsLayer = MapWaypointsLayer;
    exports.MapWaypointsModule = MapWaypointsModule;
    exports.MapWaypointsVisController = MapWaypointsVisController;
    exports.MapWxrController = MapWxrController;
    exports.MinimumsAlerter = MinimumsAlerter;
    exports.NavDataBar = NavDataBar;
    exports.NavDataBarFieldBrgModelFactory = NavDataBarFieldBrgModelFactory;
    exports.NavDataBarFieldBrgRenderer = NavDataBarFieldBrgRenderer;
    exports.NavDataBarFieldConsumerModel = NavDataBarFieldConsumerModel;
    exports.NavDataBarFieldConsumerNumberUnitModel = NavDataBarFieldConsumerNumberUnitModel;
    exports.NavDataBarFieldDestModelFactory = NavDataBarFieldDestModelFactory;
    exports.NavDataBarFieldDestRenderer = NavDataBarFieldDestRenderer;
    exports.NavDataBarFieldDisModelFactory = NavDataBarFieldDisModelFactory;
    exports.NavDataBarFieldDisRenderer = NavDataBarFieldDisRenderer;
    exports.NavDataBarFieldDtgModelFactory = NavDataBarFieldDtgModelFactory;
    exports.NavDataBarFieldDtgRenderer = NavDataBarFieldDtgRenderer;
    exports.NavDataBarFieldDtkModelFactory = NavDataBarFieldDtkModelFactory;
    exports.NavDataBarFieldDtkRenderer = NavDataBarFieldDtkRenderer;
    exports.NavDataBarFieldEndModelFactory = NavDataBarFieldEndModelFactory;
    exports.NavDataBarFieldEndRenderer = NavDataBarFieldEndRenderer;
    exports.NavDataBarFieldEnrModelFactory = NavDataBarFieldEnrModelFactory;
    exports.NavDataBarFieldEnrRenderer = NavDataBarFieldEnrRenderer;
    exports.NavDataBarFieldEtaModelFactory = NavDataBarFieldEtaModelFactory;
    exports.NavDataBarFieldEtaRenderer = NavDataBarFieldEtaRenderer;
    exports.NavDataBarFieldEteModelFactory = NavDataBarFieldEteModelFactory;
    exports.NavDataBarFieldEteRenderer = NavDataBarFieldEteRenderer;
    exports.NavDataBarFieldFobModelFactory = NavDataBarFieldFobModelFactory;
    exports.NavDataBarFieldFobRenderer = NavDataBarFieldFobRenderer;
    exports.NavDataBarFieldFodModelFactory = NavDataBarFieldFodModelFactory;
    exports.NavDataBarFieldFodRenderer = NavDataBarFieldFodRenderer;
    exports.NavDataBarFieldGenericModel = NavDataBarFieldGenericModel;
    exports.NavDataBarFieldGsModelFactory = NavDataBarFieldGsModelFactory;
    exports.NavDataBarFieldGsRenderer = NavDataBarFieldGsRenderer;
    exports.NavDataBarFieldIsaModelFactory = NavDataBarFieldIsaModelFactory;
    exports.NavDataBarFieldIsaRenderer = NavDataBarFieldIsaRenderer;
    exports.NavDataBarFieldLdgModelFactory = NavDataBarFieldLdgModelFactory;
    exports.NavDataBarFieldLdgRenderer = NavDataBarFieldLdgRenderer;
    exports.NavDataBarFieldTasModelFactory = NavDataBarFieldTasModelFactory;
    exports.NavDataBarFieldTasRenderer = NavDataBarFieldTasRenderer;
    exports.NavDataBarFieldTkeModelFactory = NavDataBarFieldTkeModelFactory;
    exports.NavDataBarFieldTkeRenderer = NavDataBarFieldTkeRenderer;
    exports.NavDataBarFieldTrkModelFactory = NavDataBarFieldTrkModelFactory;
    exports.NavDataBarFieldTrkRenderer = NavDataBarFieldTrkRenderer;
    exports.NavDataBarFieldVsrModelFactory = NavDataBarFieldVsrModelFactory;
    exports.NavDataBarFieldVsrRenderer = NavDataBarFieldVsrRenderer;
    exports.NavDataBarFieldXtkModelFactory = NavDataBarFieldXtkModelFactory;
    exports.NavDataBarFieldXtkRenderer = NavDataBarFieldXtkRenderer;
    exports.NavDataBarUserSettings = NavDataBarUserSettings;
    exports.NavDataBearingField = NavDataBearingField;
    exports.NavDataDurationField = NavDataDurationField;
    exports.NavDataField = NavDataField;
    exports.NavDataGenericField = NavDataGenericField;
    exports.NavDataNumberUnitField = NavDataNumberUnitField;
    exports.NavDataTimeField = NavDataTimeField;
    exports.NavIndicatorController = NavIndicatorController;
    exports.NavdataComputer = NavdataComputer;
    exports.NearestMapRTRController = NearestMapRTRController;
    exports.NextGenHsiMapBuilder = NextGenHsiMapBuilder;
    exports.NextGenNavMapBuilder = NextGenNavMapBuilder;
    exports.NextGenNearestMapBuilder = NextGenNearestMapBuilder;
    exports.NextGenProcMapBuilder = NextGenProcMapBuilder;
    exports.NextGenWaypointMapBuilder = NextGenWaypointMapBuilder;
    exports.NumberUnitDisplay = NumberUnitDisplay;
    exports.ProcMapFlightPathPlanRenderer = ProcMapFlightPathPlanRenderer;
    exports.ProcMapFullFlightPathPlanRenderer = ProcMapFullFlightPathPlanRenderer;
    exports.ProcMapTransitionWaypointRecordManager = ProcMapTransitionWaypointRecordManager;
    exports.ProcedureTurnLegWaypoint = ProcedureTurnLegWaypoint;
    exports.ProcedureTurnLegWaypointsRecord = ProcedureTurnLegWaypointsRecord;
    exports.RadarAltimeter = RadarAltimeter;
    exports.RadarAltimeterSystem = RadarAltimeterSystem;
    exports.Regions = Regions;
    exports.SetValueTouchButton = SetValueTouchButton;
    exports.SyntheticVision = SyntheticVision;
    exports.TasSensitivity = TasSensitivity;
    exports.TasSensitivityParameters = TasSensitivityParameters;
    exports.TimeDisplay = TimeDisplay;
    exports.TisSensitivity = TisSensitivity;
    exports.TisSensitivityParameters = TisSensitivityParameters;
    exports.ToggleStatusBar = ToggleStatusBar;
    exports.ToggleTouchButton = ToggleTouchButton;
    exports.TouchButton = TouchButton;
    exports.TrafficAdvisorySystem = TrafficAdvisorySystem;
    exports.TrafficInfoService = TrafficInfoService;
    exports.TrafficMapAdsbModeIndicator = TrafficMapAdsbModeIndicator;
    exports.TrafficMapAdsbOffBannerIndicator = TrafficMapAdsbOffBannerIndicator;
    exports.TrafficMapAltitudeModeIndicator = TrafficMapAltitudeModeIndicator;
    exports.TrafficMapBuilder = TrafficMapBuilder;
    exports.TrafficMapOperatingModeIndicator = TrafficMapOperatingModeIndicator;
    exports.TrafficMapRangeController = TrafficMapRangeController;
    exports.TrafficMapRangeLayer = TrafficMapRangeLayer;
    exports.TrafficMapStandbyBannerIndicator = TrafficMapStandbyBannerIndicator;
    exports.TrafficUserSettings = TrafficUserSettings;
    exports.UnitFormatter = UnitFormatter;
    exports.UnitsUserSettingManager = UnitsUserSettingManager;
    exports.UnitsUserSettings = UnitsUserSettings;
    exports.ValueTouchButton = ValueTouchButton;
    exports.WaypointMapRTRController = WaypointMapRTRController;
    exports.WeatherRadar = WeatherRadar;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({}, msfssdk);
